{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"draft-documentation/","text":"Draft documentation, not yet included in the product The Art Language - State Machine - Transition - Frequent Transition Frequent Transition Sometimes you may have a state where one or a few outgoing transitions can be expected to execute much more frequently than others. You can then set a frequent property on the transition trigger that you expect will trigger the transition frequently. The Art compiler uses this information to optimize generated C++ code so that such transition triggers are evaluated before other triggers that are expected to trigger the transition less frequently. interrupted: Working -> Stopped on [[rt::properties( frequent=true )]] external.interrupt ` // Interrupted while working... `; Note The frequent property relies on optimization features in the C++ compiler that may or may not be available depending on which target compiler that is used. Only use frequent transitions if profiling has shown that you have a need to do this optimization. ======================================================== The Art Language - Template Template A template is a type that is parameterized by means of template parameters to make it more generic. When a template is used (a.k.a. instantiated), actual template parameters must be provided that match the formal template parameters defined in the template. Both capsules and classes can have template parameters. Just like in C++ two kinds of template parameters are supported: Type template parameter Replaced with a type when the template is instantiated. Non-type template parameters Replaced with a non-type, for example a constant value, when the template is instantiated. Template parameters may have defaults that will be used if a matching actual template parameter is not provided when instantiating the template. Below is an example of a capsule and a class with template parameters, some of which have defaults specified. The keywords typename and class can both be used for defining a type template parameter. A non-type template parameter is defined by specifying its type as a C++ code snippet. template <typename T = `int`, `int` p1 = `5`> capsule TemplateCapsule { [[rt::decl]] ` void func(T arg1) { // impl } ` service port mp : MachineEvents[`p1`]; statemachine { state State; initial -> State; }; }; template <typename T, class U, `int` p1> class TemplateClass : `Base<T,U,p1>` { statemachine { state State; initial -> State; }; }; Template parameters can only be used from C++ code snippets, and above you see some examples of how they can be used. It's not possible to instantiate a template in Art itself. For example, even if class Base above was defined as an Art class, a C++ code snippet has to be used since it has template parameters.","title":"Draft documentation"},{"location":"draft-documentation/#draft-documentation-not-yet-included-in-the-product","text":"The Art Language - State Machine - Transition - Frequent Transition","title":"Draft documentation, not yet included in the product"},{"location":"draft-documentation/#frequent-transition","text":"Sometimes you may have a state where one or a few outgoing transitions can be expected to execute much more frequently than others. You can then set a frequent property on the transition trigger that you expect will trigger the transition frequently. The Art compiler uses this information to optimize generated C++ code so that such transition triggers are evaluated before other triggers that are expected to trigger the transition less frequently. interrupted: Working -> Stopped on [[rt::properties( frequent=true )]] external.interrupt ` // Interrupted while working... `; Note The frequent property relies on optimization features in the C++ compiler that may or may not be available depending on which target compiler that is used. Only use frequent transitions if profiling has shown that you have a need to do this optimization. ======================================================== The Art Language - Template","title":"Frequent Transition"},{"location":"draft-documentation/#template","text":"A template is a type that is parameterized by means of template parameters to make it more generic. When a template is used (a.k.a. instantiated), actual template parameters must be provided that match the formal template parameters defined in the template. Both capsules and classes can have template parameters. Just like in C++ two kinds of template parameters are supported: Type template parameter Replaced with a type when the template is instantiated. Non-type template parameters Replaced with a non-type, for example a constant value, when the template is instantiated. Template parameters may have defaults that will be used if a matching actual template parameter is not provided when instantiating the template. Below is an example of a capsule and a class with template parameters, some of which have defaults specified. The keywords typename and class can both be used for defining a type template parameter. A non-type template parameter is defined by specifying its type as a C++ code snippet. template <typename T = `int`, `int` p1 = `5`> capsule TemplateCapsule { [[rt::decl]] ` void func(T arg1) { // impl } ` service port mp : MachineEvents[`p1`]; statemachine { state State; initial -> State; }; }; template <typename T, class U, `int` p1> class TemplateClass : `Base<T,U,p1>` { statemachine { state State; initial -> State; }; }; Template parameters can only be used from C++ code snippets, and above you see some examples of how they can be used. It's not possible to instantiate a template in Art itself. For example, even if class Base above was defined as an Art class, a C++ code snippet has to be used since it has template parameters.","title":"Template"},{"location":"installing/","text":"Installing Code RealTime can be installed on top of Visual Studio Code or Eclipse Theia. The latest version of Code RealTime is available on the Visual Studio Marketplace and on the Open VSX Registry . To install that version into Visual Studio Code or Eclipse Theia follow these steps: 1) Click \"Extensions\" in the activity bar to open the Extensions view. 2) Type \"Code RealTime\" in the search field. 3) Click the \"Install\" button to install the Code RealTime extension Once the installation is finished you will see Code RealTime appear in the \"Installed\" section of the Extensions view: The screenshot above also shows that an extension for working with C/C++ has been installed. See Setup C++ Build Tools for more information. After you have installed Code RealTime it's recommended to restart Visual Studio Code or Eclipse Theia, or at least to perform the command Developer: Reload Window which is available in the Command Palette ( Ctrl + Shift + P ). Install from VSIX Another way to install Code RealTime is to use a .vsix file. This can be useful if you want to install another version than the latest. You can download .vsix files for all released versions of Code RealTime from both the Visual Studio Marketplace and the Open VSX Registry (click \"Version History\"). Once you have downloaded the .vsix file follow these steps to install it: 1) If you already have a version of Code RealTime installed, you can manually uninstall it first (see Uninstalling ). Note that this step is usually not required since the newly installed version of the extension will automatically replace the old one. 2) Open the menu of the Extensions view and select the command \"Install from VSIX\". 3) In the file dialog that appears, select the .vsix file to install. If the installation completes successfully you should see the following message: If instead the installation fails, this message will tell you the reason. One common reason for failure is that your version of Visual Studio Code or Eclipse Theia is not compatible (i.e. too old) for Code RealTime. It should also be noted that it's possible to directly install any published version of Code RealTime by using the \"Install Another Version\" command that is available in the context menu of an extension shown in the \"Installed\" section. Install from Docker Image Yet another way to install Code RealTime is to use the Docker image that is available on DockerHub . This image contains Eclipse Theia with the latest version of Code RealTime installed. Run the docker image using this command: docker run -p <host-port>:<container-port> baravich/theia-code-realtime:1.0 Replace <host-port> with a port that is available on your computer, and <container-port> with the port you want the Docker container to use. For example, if you run this command docker run -p 4000:3000 baravich/theia-code-realtime:1.0 then after less than a minute you can access Code RealTime from a web browser at http://localhost:4000 . Viewing Installation Information If you are unsure about which version of Code RealTime you have installed, you can see the version in the extension's tooltip, and the full build version is available in the page that appears if you double-click the extension: You can also see the version and the exact date of the installed Code RealTime in the Changelog that is present on the extension's page. There you can also see what has been fixed and improved compared to older releases. Note that for Theia this information is not present on the extension's page, but you can see it if you double-click on the extension's name (the web page of the extension will then open). Portable Mode Installation You can install multiple versions of Code RealTime by using the portable mode of Visual Studio Code. See Portable Mode for how to install Visual Studio Code in portable mode, which will allow you to install a version of Code RealTime that won't affect other Visual Studio Code installations on the machine. Portable mode also allows to move or copy an installation from one machine to another, which makes it useful in scenarios where installs should be centralized in an organization. Post-Installation Configuration After a successful installation you need to perform a few configuration steps before you can start to use Code RealTime. Setup Java Code RealTime uses a Java language server and hence needs a Java Virtual Machine (JVM). It's required to use a Java 17 JVM. If an appropriate JVM cannot be found when the Code RealTime extension is activated (which for example happens the first time you open an Art file), you will receive an error message. Code RealTime follows the steps below in priority order when it looks for an appropriate JVM to use: 1) The setting code-rt.languageServer.jvm is examined. If it specifies a path to a JVM it will be used. You can edit this setting by invoking File - Preferences - Settings and then type the setting id mentioned above in the filter box. 2) The environment variable JAVA_HOME is examined. If it specifies a path to a JVM it will be used. 3) An attempt is made to launch the java command without using a path. The first JVM found in the system path, if any, will be used. You may also need to adjust the arguments for the JVM. By default the JVM is launched with the below argument: -Xmx4024m To change the JVM arguments set the setting code-rt.languageServer.jvmArgs shown in the image above. When the Code RealTime extension is activated information about which Java that is used is printed to the Art Server output channel. Here you will also see if the launching of the language server for some reason failed. Setup C++ Build Tools When Code RealTime builds generated C++ code it uses C++ build tools such as a make tool, a C++ compiler, a C++ linker etc. These tools need to be in the path when you start Visual Studio Code or Eclipse Theia. If you have multiple C++ build tools installed, make sure the correct ones are present in the path before launching Visual Studio Code or Eclipse Theia. For example, if you use the Microsoft C++ compiler, it's recommended to launch from a Visual Studio native tools command prompt with the correct version (e.g. 32 bit or 64 bit). Build errors caused by inconsistent versions of C++ build tools being used can be tricky to find. You also need to install an extension for C/C++ development into Visual Studio Code or Eclipse Theia. Even if you can use any such extension, Code RealTime provides the best integration with either C/C++ for Visual Studio Code or clangd . Uninstalling To uninstall Code RealTime follow these steps: 1) Click \"Extensions\" in the left side-bar. 1) Find the Code RealTime extension in the \"Installed\" section and invoke the \"Uninstall\" command (in Visual Studio Code the command is available in the context menu, while in Theia it shows up as a button to click). Once the uninstallation is finished you will no longer see Code RealTime in the \"Installed\" section.","title":"Installing"},{"location":"installing/#installing","text":"Code RealTime can be installed on top of Visual Studio Code or Eclipse Theia. The latest version of Code RealTime is available on the Visual Studio Marketplace and on the Open VSX Registry . To install that version into Visual Studio Code or Eclipse Theia follow these steps: 1) Click \"Extensions\" in the activity bar to open the Extensions view. 2) Type \"Code RealTime\" in the search field. 3) Click the \"Install\" button to install the Code RealTime extension Once the installation is finished you will see Code RealTime appear in the \"Installed\" section of the Extensions view: The screenshot above also shows that an extension for working with C/C++ has been installed. See Setup C++ Build Tools for more information. After you have installed Code RealTime it's recommended to restart Visual Studio Code or Eclipse Theia, or at least to perform the command Developer: Reload Window which is available in the Command Palette ( Ctrl + Shift + P ).","title":"Installing"},{"location":"installing/#install-from-vsix","text":"Another way to install Code RealTime is to use a .vsix file. This can be useful if you want to install another version than the latest. You can download .vsix files for all released versions of Code RealTime from both the Visual Studio Marketplace and the Open VSX Registry (click \"Version History\"). Once you have downloaded the .vsix file follow these steps to install it: 1) If you already have a version of Code RealTime installed, you can manually uninstall it first (see Uninstalling ). Note that this step is usually not required since the newly installed version of the extension will automatically replace the old one. 2) Open the menu of the Extensions view and select the command \"Install from VSIX\". 3) In the file dialog that appears, select the .vsix file to install. If the installation completes successfully you should see the following message: If instead the installation fails, this message will tell you the reason. One common reason for failure is that your version of Visual Studio Code or Eclipse Theia is not compatible (i.e. too old) for Code RealTime. It should also be noted that it's possible to directly install any published version of Code RealTime by using the \"Install Another Version\" command that is available in the context menu of an extension shown in the \"Installed\" section.","title":"Install from VSIX"},{"location":"installing/#install-from-docker-image","text":"Yet another way to install Code RealTime is to use the Docker image that is available on DockerHub . This image contains Eclipse Theia with the latest version of Code RealTime installed. Run the docker image using this command: docker run -p <host-port>:<container-port> baravich/theia-code-realtime:1.0 Replace <host-port> with a port that is available on your computer, and <container-port> with the port you want the Docker container to use. For example, if you run this command docker run -p 4000:3000 baravich/theia-code-realtime:1.0 then after less than a minute you can access Code RealTime from a web browser at http://localhost:4000 .","title":"Install from Docker Image"},{"location":"installing/#viewing-installation-information","text":"If you are unsure about which version of Code RealTime you have installed, you can see the version in the extension's tooltip, and the full build version is available in the page that appears if you double-click the extension: You can also see the version and the exact date of the installed Code RealTime in the Changelog that is present on the extension's page. There you can also see what has been fixed and improved compared to older releases. Note that for Theia this information is not present on the extension's page, but you can see it if you double-click on the extension's name (the web page of the extension will then open).","title":"Viewing Installation Information"},{"location":"installing/#portable-mode-installation","text":"You can install multiple versions of Code RealTime by using the portable mode of Visual Studio Code. See Portable Mode for how to install Visual Studio Code in portable mode, which will allow you to install a version of Code RealTime that won't affect other Visual Studio Code installations on the machine. Portable mode also allows to move or copy an installation from one machine to another, which makes it useful in scenarios where installs should be centralized in an organization.","title":"Portable Mode Installation"},{"location":"installing/#post-installation-configuration","text":"After a successful installation you need to perform a few configuration steps before you can start to use Code RealTime.","title":"Post-Installation Configuration"},{"location":"installing/#setup-java","text":"Code RealTime uses a Java language server and hence needs a Java Virtual Machine (JVM). It's required to use a Java 17 JVM. If an appropriate JVM cannot be found when the Code RealTime extension is activated (which for example happens the first time you open an Art file), you will receive an error message. Code RealTime follows the steps below in priority order when it looks for an appropriate JVM to use: 1) The setting code-rt.languageServer.jvm is examined. If it specifies a path to a JVM it will be used. You can edit this setting by invoking File - Preferences - Settings and then type the setting id mentioned above in the filter box. 2) The environment variable JAVA_HOME is examined. If it specifies a path to a JVM it will be used. 3) An attempt is made to launch the java command without using a path. The first JVM found in the system path, if any, will be used. You may also need to adjust the arguments for the JVM. By default the JVM is launched with the below argument: -Xmx4024m To change the JVM arguments set the setting code-rt.languageServer.jvmArgs shown in the image above. When the Code RealTime extension is activated information about which Java that is used is printed to the Art Server output channel. Here you will also see if the launching of the language server for some reason failed.","title":"Setup Java"},{"location":"installing/#setup-c-build-tools","text":"When Code RealTime builds generated C++ code it uses C++ build tools such as a make tool, a C++ compiler, a C++ linker etc. These tools need to be in the path when you start Visual Studio Code or Eclipse Theia. If you have multiple C++ build tools installed, make sure the correct ones are present in the path before launching Visual Studio Code or Eclipse Theia. For example, if you use the Microsoft C++ compiler, it's recommended to launch from a Visual Studio native tools command prompt with the correct version (e.g. 32 bit or 64 bit). Build errors caused by inconsistent versions of C++ build tools being used can be tricky to find. You also need to install an extension for C/C++ development into Visual Studio Code or Eclipse Theia. Even if you can use any such extension, Code RealTime provides the best integration with either C/C++ for Visual Studio Code or clangd .","title":"Setup C++ Build Tools"},{"location":"installing/#uninstalling","text":"To uninstall Code RealTime follow these steps: 1) Click \"Extensions\" in the left side-bar. 1) Find the Code RealTime extension in the \"Installed\" section and invoke the \"Uninstall\" command (in Visual Studio Code the command is available in the context menu, while in Theia it shows up as a button to click). Once the uninstallation is finished you will no longer see Code RealTime in the \"Installed\" section.","title":"Uninstalling"},{"location":"overview/","text":"Code RealTime lets you create stateful, event-driven realtime applications in C++. It runs as an extension of Visual Studio Code or Eclipse Theia. Follow the installation instructions for installing it. Code RealTime supports the Art language which extends the C++ language with high-level concepts useful when designing stateful, event-driven realtime applications, such as capsules, state machines and protocols. It is a textual language, but also provides a graphical notation that includes class, state and structure diagrams. Code RealTime translates Art files into efficient C++ code which can be compiled on any target system. The generated code makes use of the Target RunTime System which is a C++ library that implements the concepts of the Art language. Watch this video to get an overview of how Code RealTime uses the Art language for implementing stateful, event-driven realtime applications. Art History The Art language as implemented in Code RealTime builds on a foundation with a long history in industry. In the early 1990s the Canadian company ObjecTime Limited developed a language called ROOM to address the challenges of building realtime applications consisting of communicating state machines. ROOM introduced concepts such as capsules, protocols and ports and was first implemented in the tool ObjecTime Developer. This tool got adopted in a wide range of industrial domains for example telecom and embedded systems development. In 2000 ObjectTime was acquired by Rational Software and ObjecTime Developer was merged with Rational Rose, a UML modeling tool. The result was Rational Rose RealTime (Rose RT). At the same time many of the ROOM language concepts made its way into the, by then, new modeling language called UML-RealTime. In 2003 Rational Software was acquired by IBM which at the time was investing heavily in the Eclipse platform. As a result work started to create an Eclipse-based tool as the successor of Rose RT. This new product got the name Rational Software Architect RealTime Edition (RSARTE) and was first released in 2007. In 2016 HCL entered a partnership with IBM, which led to a rebranded version of RSARTE called HCL RTist. A few years later both RSARTE and RTist were renamed to DevOps Model RealTime . Work on Code RealTime began in 2020 with the aim of supporting other IDEs than Eclipse. As part of this effort a textual language syntax, Art, was developed. Hence it's fair to describe the Art language as a new syntax for concepts that have a rather old history and have already been used in the industry for more than 30 years. It should also be mentioned that the Target RunTime System used in Code RealTime is the same as is used in Model RealTime. In fact, the implementation of this C++ library started with ObjectTime Developer and has since then been gradually extended and modernized.","title":"Overview"},{"location":"overview/#art-history","text":"The Art language as implemented in Code RealTime builds on a foundation with a long history in industry. In the early 1990s the Canadian company ObjecTime Limited developed a language called ROOM to address the challenges of building realtime applications consisting of communicating state machines. ROOM introduced concepts such as capsules, protocols and ports and was first implemented in the tool ObjecTime Developer. This tool got adopted in a wide range of industrial domains for example telecom and embedded systems development. In 2000 ObjectTime was acquired by Rational Software and ObjecTime Developer was merged with Rational Rose, a UML modeling tool. The result was Rational Rose RealTime (Rose RT). At the same time many of the ROOM language concepts made its way into the, by then, new modeling language called UML-RealTime. In 2003 Rational Software was acquired by IBM which at the time was investing heavily in the Eclipse platform. As a result work started to create an Eclipse-based tool as the successor of Rose RT. This new product got the name Rational Software Architect RealTime Edition (RSARTE) and was first released in 2007. In 2016 HCL entered a partnership with IBM, which led to a rebranded version of RSARTE called HCL RTist. A few years later both RSARTE and RTist were renamed to DevOps Model RealTime . Work on Code RealTime began in 2020 with the aim of supporting other IDEs than Eclipse. As part of this effort a textual language syntax, Art, was developed. Hence it's fair to describe the Art language as a new syntax for concepts that have a rather old history and have already been used in the industry for more than 30 years. It should also be mentioned that the Target RunTime System used in Code RealTime is the same as is used in Model RealTime. In fact, the implementation of this C++ library started with ObjectTime Developer and has since then been gradually extended and modernized.","title":"Art History"},{"location":"settings/","text":"Code RealTime provides several settings that can be used for configuring many aspects of how it works. To view these settings perform File - Preferences - Settings and then select Extensions - Code RealTime . Below is a table that lists all Code RealTime settings. Each setting is described in a section of its own below the table. Setting Id Purpose Language Server - Jvm code-rt.languageServer.jvm Set the JVM to use for running the Code RealTime language server Language Server - Jvm Args code-rt.languageServer.jvmArgs Set arguments for the JVM that runs the Code RealTime language server Validation - Rule Configuration code-rt.validation.ruleConfiguration Customize which validation rules to run on Art files and their severity Build - Output Folder code-rt.build.outputFolder Set the location where to place generated code Build - Cancel On Error code-rt.build.cancelOnError Cancel a launched build if errors exist in TCs or Art files Diagram - Show Junction Names code-rt.diagram.showJunctionNames Show junction names on state diagrams Diagram - Show Choice Names code-rt.diagram.showChoiceNames Show choice names on state diagrams Diagram - Show Entry Exit Point Names code-rt.diagram.showEntryExitPointNames Show entry/exit point names on state diagrams Diagram - Show Transition Names code-rt.diagram.showTransitionNames Show transition names on state diagrams Diagram - Show Diagnostics code-rt.diagram.showDiagnostics Show error, warning and information icons on diagrams Language Server Settings related to running the Code RealTime language server. Jvm When the Code RealTime extension gets activated it will attempt to launch its language server. If this setting holds a valid location of a Java VM (JDK or JRE) it will be used for running the language server. Otherwise the JAVA_HOME environment variable will be used. If that is also not set, it's required to have java in the path. See Setup Java for more information. Jvm Args By default the JVM is launched with the argument -Xmx4024m . Refer to the documentation of your JVM for a list of available JVM arguments. Validation Settings related to validation of Art files. Rule Configuration This setting can be used for customizing which validation rules that should run when you edit Art files. You can also completely disable those validation rules you don't want to run. For more information see this page . Build Settings related to building Art files, via C++ code, to libraries or executables. Output Folder This setting specifies a folder where all generated code will be placed. More precisely, it's used for resolving relative paths specified in TCs (using the TC property targetFolder ). If you leave this setting unset, relative paths will instead be resolved against the location of the TCs. The Output Folder must be specified as an absolute path that points at a writable folder in the file system. Cancel On Error When a TC is built the Problems view is scanned to see if there are errors reported on the built TC or its prerequisites, as well as all Art files that will be built. If at least one such error is found it's recommended to cancel the build, fix the errors and then redo the build again. The default value for this setting is Prompt which means you will be prompted by a dialog where you can choose if you want to cancel the build, or proceed anyway. In the latter case you may encounter compilation errors when generated code is compiled or run-time problems when the built executable is run. Therefore you should only proceed if you are confident that the errors are safe to ignore. You may set this setting to Always to suppress the dialog and always cancel the build when errors are present. You can also (but this is not recommended) set the setting to Never to always ignore any errors and proceed with the build anyway. Diagram Settings related to graphical diagrams that visualize elements of Art files. Show Junction Names Junctions usually have short and uninteresting names, and are therefore by default not shown on state diagrams. Turn on this setting to make them visible. Note that a certain state diagram may override this setting by means of setting the corresponding diagram property in the diagram's Properties view. See Diagram Filters for more information. Show Choice Names Choices usually have short and uninteresting names, and are therefore by default not shown on state diagrams. Turn on this setting to make them visible. Note that a certain state diagram may override this setting by means of setting the corresponding diagram property in the diagram's Properties view. See Diagram Filters for more information. Show Entry Exit Point Names Entry and exit points usually have short and uninteresting names, and are therefore by default not shown on state diagrams. Turn on this setting to make them visible. Note that a certain state diagram may override this setting by means of setting the corresponding diagram property in the diagram's Properties view. See Diagram Filters for more information. Show Transition Names If you feel that showing the names of transitions makes state diagrams too cluttered you can turn off this setting. By default they are shown. Note that a certain state diagram may override this setting by means of setting the corresponding diagram property in the diagram's Properties view. See Diagram Filters for more information. Show Diagnostics By default diagram elements will be decorated by icons corresponding to diagnostics generated by validation rules . Turn off this setting if you don't want to see these icons on diagrams. There are three kinds of diagnostic icons corresponding to the problem severity levels Error, Warning and Information. See Problem Severity for more information.","title":"Settings"},{"location":"settings/#language-server","text":"Settings related to running the Code RealTime language server.","title":"Language Server"},{"location":"settings/#jvm","text":"When the Code RealTime extension gets activated it will attempt to launch its language server. If this setting holds a valid location of a Java VM (JDK or JRE) it will be used for running the language server. Otherwise the JAVA_HOME environment variable will be used. If that is also not set, it's required to have java in the path. See Setup Java for more information.","title":"Jvm"},{"location":"settings/#jvm-args","text":"By default the JVM is launched with the argument -Xmx4024m . Refer to the documentation of your JVM for a list of available JVM arguments.","title":"Jvm Args"},{"location":"settings/#validation","text":"Settings related to validation of Art files.","title":"Validation"},{"location":"settings/#rule-configuration","text":"This setting can be used for customizing which validation rules that should run when you edit Art files. You can also completely disable those validation rules you don't want to run. For more information see this page .","title":"Rule Configuration"},{"location":"settings/#build","text":"Settings related to building Art files, via C++ code, to libraries or executables.","title":"Build"},{"location":"settings/#output-folder","text":"This setting specifies a folder where all generated code will be placed. More precisely, it's used for resolving relative paths specified in TCs (using the TC property targetFolder ). If you leave this setting unset, relative paths will instead be resolved against the location of the TCs. The Output Folder must be specified as an absolute path that points at a writable folder in the file system.","title":"Output Folder"},{"location":"settings/#cancel-on-error","text":"When a TC is built the Problems view is scanned to see if there are errors reported on the built TC or its prerequisites, as well as all Art files that will be built. If at least one such error is found it's recommended to cancel the build, fix the errors and then redo the build again. The default value for this setting is Prompt which means you will be prompted by a dialog where you can choose if you want to cancel the build, or proceed anyway. In the latter case you may encounter compilation errors when generated code is compiled or run-time problems when the built executable is run. Therefore you should only proceed if you are confident that the errors are safe to ignore. You may set this setting to Always to suppress the dialog and always cancel the build when errors are present. You can also (but this is not recommended) set the setting to Never to always ignore any errors and proceed with the build anyway.","title":"Cancel On Error"},{"location":"settings/#diagram","text":"Settings related to graphical diagrams that visualize elements of Art files.","title":"Diagram"},{"location":"settings/#show-junction-names","text":"Junctions usually have short and uninteresting names, and are therefore by default not shown on state diagrams. Turn on this setting to make them visible. Note that a certain state diagram may override this setting by means of setting the corresponding diagram property in the diagram's Properties view. See Diagram Filters for more information.","title":"Show Junction Names"},{"location":"settings/#show-choice-names","text":"Choices usually have short and uninteresting names, and are therefore by default not shown on state diagrams. Turn on this setting to make them visible. Note that a certain state diagram may override this setting by means of setting the corresponding diagram property in the diagram's Properties view. See Diagram Filters for more information.","title":"Show Choice Names"},{"location":"settings/#show-entry-exit-point-names","text":"Entry and exit points usually have short and uninteresting names, and are therefore by default not shown on state diagrams. Turn on this setting to make them visible. Note that a certain state diagram may override this setting by means of setting the corresponding diagram property in the diagram's Properties view. See Diagram Filters for more information.","title":"Show Entry Exit Point Names"},{"location":"settings/#show-transition-names","text":"If you feel that showing the names of transitions makes state diagrams too cluttered you can turn off this setting. By default they are shown. Note that a certain state diagram may override this setting by means of setting the corresponding diagram property in the diagram's Properties view. See Diagram Filters for more information.","title":"Show Transition Names"},{"location":"settings/#show-diagnostics","text":"By default diagram elements will be decorated by icons corresponding to diagnostics generated by validation rules . Turn off this setting if you don't want to see these icons on diagrams. There are three kinds of diagnostic icons corresponding to the problem severity levels Error, Warning and Information. See Problem Severity for more information.","title":"Show Diagnostics"},{"location":"support/","text":"If you find a bug in Code RealTime please report it with a GitHub Issue . Please include steps to reproduce and any additional files that can help in troubleshooting. For example, it can be good to include all log files. You can find the location of these logs by invoking the command Developer: Open Logs Folder . You can zip the entire logs folder and attach it to the issue. You can also check these logs using the Output view. In particular, the following two output logs are relevant: Art Server Contains messages printed by the Art language server. These are internal errors and other diagnostic messages that you normally would not need to pay attention to, but which can sometimes be useful when troubleshooting a problem. Art Build Contains messages printed when building a TC. It can sometimes contain diagnostic messages from the Art compiler.","title":"Support Procedures"},{"location":"validation/","text":"Code RealTime checks for semantic problems in your application. It does this by running a large number of validation rules each time an Art file or a TC file has been changed. The rules run automatically as soon as you have made a change to the file (even before saving it). This ensures that errors and warnings (i.e. potential problems) are found as early as possible. Problem Severity Each validation rule has a default severity which will be used for the problems that are reported by the rule: Error An error is a problem that is severe enough to prevent building a correct application. Errors must be fixed, and it will not be possible to build the Art files into a C++ application until all errors have been resolved. Warning A warning is a potential problem, which you may or may not choose to fix. It can for example indicate a deviation from common conventions and best practises and it can indicate that the application will not behave as you may expect. Information An information is just a message that you should be aware of. It doesn't really indicate a problem, and you don't need to fix it. You can customize the default severity of any validation rule, and you can also choose to completely disable a certain validation rule that you don't think provides any value. See Configuring Validation for more information. Problem Reporting When a validation rule has found a problem in an Art file, it is marked by underlining one or several Art elements in the file. The underlining is red for errors, yellow for warnings and blue for information messages. For example, in the capsule shown below one warning and two errors have been found. You can hover the cursor over these underlinings to get a tooltip with information about the problem. Every problem has a message that describes it. Often this message gives enough information for understanding how to fix the problem. If this is not the case you can go to the documentation about the validation rule to find more information, examples and suggestions for how the problem can be fixed. To easily find the documentation click the hyperlink that consists of the unique id of the validation rule (it starts with a prefix such as \"ART_\", followed by a 4 digit number and a name). Alternatively you can search for the validation rule id on this page. Often a problem may be associated with more than one Art element. There is a main element on which the problem will be shown, but there often also are other elements that are related to the problem in one way or another. You can navigate to related elements to get a better understanding of why a problem is reported and how to fix it. In the screenshot above the problem has a single related element (the capsule tlSystem ) but in general a problem can have an arbitrary number of related elements. Problems are also reported by means of icons in diagrams. Below are three states with problems of different severity: A problem icon has a tooltip that shows the message of the problem. You can disable problem reporting in diagrams by means of a configuration setting code-rt.diagram.showDiagnostics . For a TC file, all properties it contains will be validated, and problems that are found during this validation are shown by underlining TC properties. You can hover Problems View Too see all problems found in all Art files and all TC files in the workspace, open the Problems view. The total number of problems found are shown in the Problems view heading. By default problems are shown in a tree grouped by the files where they were found. However, you can also view them as a flat table instead (but note that related elements can only be seen when using the tree view). If there are many problems, it can help to filter the Problems View by typing some text in the filter box. For example, you can filter using a regular expression that matches only some of the files in the workspace, to reduce the number of problems shown. Quick Fix Some problems have one or several typical solutions that are possible to apply automatically by means of \"code actions\". If a problem has at least one such code action defined, a yellow light bulb icon will appear and a Quick Fix command will be available in the problem tooltip. Note that most semantic errors cannot be automatically resolved like this, but in some simple cases it's possible. Configuring Validation Validation can be configured to change which rules that should run, and what severity they should report found problems with. By default every validation rule is enabled and uses a predefined severity level. Validation rules can be configured either globally by means of a setting, or locally by means of a property rule_config . In both cases the rule configuration consists of a comma-separated list of 5 letter strings where the first letter specifies if the rule is disabled and it's severity (X,I,W,E) and remaining letters specify the rule id. For example, the rule configuration X0003,I0004,W0009,E0005 means the following: The rule ART_0003_nameShouldStartWithUpperCase is disabled The rule ART_0004_nameShouldStartWithLowerCase has its severity set to Information The rule ART_0009_invalidProperty has its severity set to Warning The rule ART_0005_choiceWithoutElseTransition has its severity set to Error To configure validation rules globally, use the configuration setting code-rt.validation.ruleConfiguration . A global configuration will apply for all Art files in the workspace, and all Art elements within those files, unless a local rule configuration has been set on an element. To configure validation rules locally, set the property rule_config on an Art element. It will affect the validation of that Art element itself, as well as all elements contained within that Art element. Here is an example of how to disable the validation rule ART_0003_nameShouldStartWithUpperCase on a capsule. Note that it also will disable this rule for elements contained within the capsule, such as states. capsule customCapsule // no warning even if capsule name is not capitalized [[rt::properties( rule_config=\"X0003\" )]]{ statemachine { state customState; // no warning here too initial -> customState; }; }; Note Certain validation rules cannot be disabled or have their severity changed. These are known as \"core validation rules\" and they run before semantic validation starts (which is why they cannot be customized). Note Local configuration of validation rules is only supported for Art files. For TC validation you cannot provide a local rule configuration in the TC file. Validation Rules This chapter lists all validation rules which Code RealTime checks your Art application against. These rules find problems in Art files and all problems found have the \"ART_\" prefix. ART_0001_invalidNameCpp Severity Reason Quick Fix Error An Art element has a name that is not a valid C++ name, or a name that will cause a name clash in the generated code. Prepend Underscore Art elements are translated to C++ elements without changing the elements' names. Hence you need to choose names for Art elements that are valid in C++. For example, C++ keywords cannot be used. Furthermore, names of such Art elements must not clash with global names used by the TargetRTS or names within generated C++ files. If you ignore this error you can expect errors when compiling the generated C++ code. A Quick Fix is available that will fix the problem by adding an underscore to the beginning of the name, in order to make it a valid C++ name. protocol InvalidNameProtocol { in virtual(); // ART_0001 (\"virtual\" is a C++ keyword) }; capsule Exception { // ART_0001 (\"Exception\" is a name reserved for use by the TargetRTS) }; ART_0002_duplicateNamesInScope Severity Reason Quick Fix Error Two or more Art elements in the same scope have the same names or signatures. N/A Names of Art elements must be unique within the same scope. The following is checked: Top-level elements in the global scope (either defined in the same Art file, or in different Art files built by the same TC or prerequisite TCs). The corresponding C++ elements will have names in the global namespace and must hence be unique. Events of a protocol. Note that in-events and out-events are checked separately, since an in-event and an out-event will have the same name when you define a symmetric event (see Protocol and Event ). Parts of a capsule. Ports of a capsule. States and pseudo states (collectively referred to as \"vertices\") of a state machine. Transitions of a state machine. Trigger operations of a class . Note that several trigger operations may have the same name as long as their signatures are unique. All elements with clashing names or signatures will be reported as related elements. Use this to find the element(s) that need to be renamed. protocol DupProto { in inEvent1(); // ART_0002 in inEvent1(); // ART_0002 out inEvent1(); // OK (symmetric event) }; class DNIS { trigger op1(`int` p); trigger op1(); // OK (signatures are unique) statemachine { state State; initial -> State; }; }; ART_0003_nameShouldStartWithUpperCase Severity Reason Quick Fix Warning An Art element's name doesn't follow the naming convention to start with uppercase. Capitalize Name Just like in most languages Art has certain conventions on how elements should be named. The following elements should have names that start with an uppercase letter: Capsule Class Protocol State A Quick Fix is available that will fix the problem by capitalizing the name. Note, however, that it will only update the element's name, and not all references. If you have references to the element you may instead want to fix the problem by performing a rename refactoring (context menu command Rename Symbol ). capsule myCapsule { // ART_0003 statemachine { state sstate; // ART_0003 initial -> sstate; }; }; In this context an underscore ( _ ) is considered a valid upper case character, so all names that start with underscore are accepted by this validation rule. ART_0004_nameShouldStartWithLowerCase Severity Reason Quick Fix Warning An Art element's name doesn't follow the naming convention to start with lowercase. Decapitalize Name Just like in most languages Art has certain conventions on how elements should be named. The following elements should have names that start with a lowercase letter: Event Port Part Trigger operation Choice and junction points Entry and exit points Transition A Quick Fix is available that will fix the problem by decapitalizing the name. Note, however, that it will only update the element's name, and not all references. If you have references to the element you may instead want to fix the problem by performing a rename refactoring (context menu command Rename Symbol ). protocol LowerCaseTestProtocol { out MyEvent(); // ART_0004 }; In this context an underscore ( _ ) is considered a valid lower case character, so all names that start with underscore are accepted by this validation rule. ART_0005_choiceWithoutElseTransition Severity Reason Quick Fix Warning A choice lacks an outgoing else-transition. N/A If no outgoing transition of a choice is enabled at runtime (because no outgoing transition has a guard condition that is fulfilled) then the state machine will get stuck in the choice for ever. To avoid this you should ensure that at least one outgoing transition is enabled. A good way to do this is to use 'else' as the guard condition for one of the outgoing transitions. Such an else-transition will then execute if no other outgoing transition of the choice is enabled. capsule ChoiceSample { statemachine { state State; initial -> State; choice x; // ART_0005 State -> x; x -> State when `return getVal() == 5;`; }; }; Note that a transition without any guard condition is equivalent to a transition with a guard condition that is always fulfilled (i.e. a guard condition that returns true). An outgoing transition from a choice or junction without any guard is therefore also an else-transition. ART_0006_choiceWithoutOutgoingTransitions Severity Reason Quick Fix Error A choice has no outgoing transitions. N/A A choice should typically have at least two outgoing transitions to be meaningful. Having only one outgoing transition is possible if it is an else-transition (i.e. a transition with an 'else' guard, or without any guard at all). However, a choice without any outgoing transition is not allowed since the state machine always will get stuck when reaching such a choice. capsule ChoiceSample { statemachine { state State; initial -> State; choice x; // ART_0006 State -> x; }; }; ART_0007_choiceWithTooManyElseTransitions Severity Reason Quick Fix Error A choice has more than one outgoing else-transition. N/A It's good practise to have an outgoing else-transition (i.e. a transition with an 'else' guard, or without any guard at all) for a choice since it will prevent the state machine from getting stuck in the choice at runtime. However, there should not be more than one such else-transition defined, since otherwise it's ambiguous which one of them to trigger in the case none of the other outgoing transitions from the choice are enabled. capsule ChoiceSample { statemachine { state State, State2; initial -> State; choice x; // ART_0007 State -> x; x -> State; x -> State2 when `else`; }; }; ART_0008_initialTransitionCount Severity Reason Quick Fix Error A state machine has too many initial transitions, or no initial transition at all. N/A A state machine of a capsule or class must have exactly one initial transition. A common reason for this error is that you have introduced inheritance between two capsules which both have state machines with an initial transition. Because of that the derived capsule will have two initial transitions (the one it defines itself locally plus the one it inherits from the base capsule). In this case the error can be fixed by either deleting or excluding the initial transition from the derived capsule, or to let it redefine the initial transition from the base capsule. capsule InitTransCap2 { statemachine { state State; initial -> State; }; }; capsule InitTransCap3 : InitTransCap2 { statemachine { // ART_0008 (1 local initial transition and 1 inherited) state State2; initial -> State2; }; }; capsule NoInitTrans { statemachine { // ART_0008 (no initial transition) state State; }; }; Note that if the initial transition in the base capsule has no name, the derived capsule cannot exclude or redefine it. It's therefore good practise to name the initial transition if you expect your capsule to be inherited from. The validation rule also checks nested state machines. Such a state machine doesn't need any initial transition, since the composite state can be entered via an entrypoint which takes the nested state machine to its first state. However, if the nested state machine has an initial transition there cannot be more than one. capsule InitTransCap2 { statemachine { initial -> Composite; state Composite { state NS; initial -> NS; }; }; }; capsule InitTransCap3 : InitTransCap2 { statemachine { state redefine Composite { // ART_0008 (3 local initial transitions and 1 inherited) state S1, S2, S3; initial -> S1; initial -> S2; _ini: initial -> S3; }; }; }; ART_0009_invalidProperty Severity Reason Quick Fix Error A non-existing property is set for an element. Remove Property Most Art elements have properties that can be set to change their default values. Different elements have different properties and if you get this error it means you have referenced a non-existing property for an Art element. A Quick Fix is available for removing the setting of the invalid property. Use Content Assist ( Ctrl + Space ) to get a list of valid properties for an Art element. protocol IP_PROTO [[rt::properties( no_property = 4 // ART_0009 (a protocol has no property called \"no_property\") )]] { }; capsule CN [[rt::properties( colour=\"#ff0000\" // ART_0009 (misspelled property \"color\") )]] { statemachine { state State; initial -> State; }; }; ART_0010_invalidPropertyValue Severity Reason Quick Fix Error A property is set to a value of incorrect type. N/A Most Art elements have properties and every property has a type that is either boolean, integer, string or an enumeration. The type of the value assigned to a property must match the property's type. For example, you cannot assign an integer value to a boolean property. capsule IPV_Cap [[rt::properties( generate_file_header=4 // ART_0010 (\"generate_file_header\" is a boolean property) )]]{ statemachine { state State; initial -> State; }; }; ART_0011_propertySetToDefaultValue Severity Reason Quick Fix Warning A property is set to its default value. Remove Property Most Art elements have properties and every property has a default value. It's unnecessary to explicitly set a property to its default value. A Quick Fix is available for removing the setting of the property. class C_PropDefaultValue [[rt::properties( const_target_param_for_decode=false // ART_0011 )]] { statemachine { state State; initial -> State; }; }; ART_0012_invalidCodeSnippet Severity Reason Quick Fix Error A code snippet is invalid in one way or the other. Remove Code Snippet A code snippet 's kind is specified after the prefix rt:: . Different Art elements may have different kinds of code snippets. Also, some Art elements may have multiple code snippets of a certain kind, while others only may have one code snippet of each kind. A Quick Fix is available for removing the invalid code snippet. [[rt::header_preface]] // ART_0012 (code snippet for capsule/class placed at file level) ` // YourCodeHere ` capsule Name { [[rt::unknown]] // ART_0012 (non-existing kind of code snippet) ` // YourCodeHere ` part x : OtherCap [[rt::create]] ` return new DemoCap_Actor(rtg_rts, rtg_ref); ` [[rt::create]] // ART_0012 (duplicated code snippet) ` return new DemoCap_Actor(rtg_rts, rtg_ref); `; statemachine { state State; initial -> State; }; }; ART_0013_partMultiplicityError Severity Reason Quick Fix Error The part's lower multiplicity must be less than its upper multiplicity. N/A If a part has a multiplicity that specifies a range (i.e. both a lower and upper multiplicity), then the lower multiplicity must be less than the upper multiplicity. capsule PME_Cap { part myPart : OtherCap [2..2]; // ART_0013 statemachine { state State; initial -> State; }; }; ART_0014_partKindMultiplicityInconsistency Severity Reason Quick Fix Warning The part's kind is inconsistent with its multiplicity. N/A The multiplicity of a capsule part must match the part's kind. The following is checked: A fixed part must have a multiplicity greater than zero. This is because when the container capsule is incarnated at least one capsule instance must be incarnated into the fixed part. An optional part must have a lower multiplicity of zero. This means that when the container capsule is incarnated no capsule instances will be incarnated into the optional part. Hence, this is what makes the part optional. In case any of these inconsistencies is detected, the faulty multiplicity will be ignored and a default multiplicity (see Part ) will be used instead. capsule PKMI_Cap { fixed part myPart : OtherCap [0..2]; // ART_0014 (Fixed part should not have lower multiplicity 0) optional part myPart2 : OtherCap [1..5]; // ART_0014 (Optional part should not have lower multiplicity > 0) statemachine { state State; initial -> State; }; }; ART_0015_internalTransitionOutsideState Severity Reason Quick Fix Error An internal transition is defined outside a state, in the top state machine. N/A An internal transition specifies events that can be handled while a state machine is in a certain state without leaving that state. Hence it's only possible to define an internal transition inside a state. It does not make sense to define an internal transition directly in the top state machine. capsule IntTransOutsideState { behavior port timer : Timing; statemachine { state State { t1 : on timer.timeout ` `; }; initial -> State; terror : on timer.timeout ` `; // ART_0015 }; }; ART_0016_circularInheritance Severity Reason Quick Fix Error A capsule, class or protocol inherits from itself directly or indirectly. N/A When you use inheritance for capsules, classes and protocols you need to ensure there are no inheritance cycles. Cyclic inheritance means that an element would inherit from itself, directly or indirectly, which is not allowed. Note Both capsules and classes, but not protocols, may have C++ base classes specified by means of C++ code snippets. Such inheritance relationships are not checked by this validation rule, but by the C++ compiler. The elements that form the inheritance cycle will be reported as related elements. Use this to decide how to break the inheritance cycle. protocol PR1 : PR2 { // ART_0016 }; protocol PR2 : PR1 { // ART_0016 }; class C1 { statemachine { state State; initial -> State; }; }; class C2 : C1 { statemachine { state State; initial -> State; }; }; class C3 : C2, C4 { // ART_0016 statemachine { state State; initial -> State; }; }; class C4 : C3 { // ART_0016 statemachine { state State; initial -> State; }; }; ART_0017_circularComposition Severity Reason Quick Fix Error A capsule contains itself through a cycle in the composition hierarchy. N/A Parts of a capsule must form a strict composition hierarchy. At run-time the root of this hierarchy is the top capsule instance, and all other capsule instances in the application must be directly or indirectly owned by that capsule instance. For a fixed part the creation of contained capsule instances happen automatically when the container capsule is incarnated. It's therefore possible to statically analyze the fixed parts and check for cycles in the composition hierarchy. Note Only the static type of fixed capsule parts are used when looking for composition cycles. If a part has a capsule factory that specifies a create function using C++ code, then a different dynamic type may be specified for the created capsule instances for that part. This opens up for more possibilities of introducing cycles in the composition hierarchy that will not be detected by this validation rule. The fixed parts that form the composition cycle will be reported as related elements. Use this to decide how to break the composition cycle. capsule CComp2 { fixed part p2 : CComp3; // ART_0017 statemachine { state State; initial -> State; }; }; capsule CComp3 { part p3 : CComp2; // ART_0017 statemachine { state State; initial -> State; }; }; ART_0018_circularTransitions Severity Reason Quick Fix Error A state machine has a cycle in the transitions that execute when leaving a junction. N/A A junction can split an incoming transition flow into multiple outgoing transition flows based on evaluating guard conditions for the outgoing transitions. If care is not taken it's possible to introduce cycles in the outgoing transition flows. Such cycles could lead to infinite recursion when the state machine executes, depending on what guard conditions will be fulfilled at runtime. You should therefore ensure there are no such transition cycles. The transitions that form the cycle will be reported as related elements. Use this to decide how to break the transition cycle. capsule CT_cap { statemachine { // ART_0018 state S1; initial -> S1; junction j1, j2; t1: S1 -> j1; t2: j1 -> j2; t3: j2 -> j1; }; }; Note Entry and exit points can also split an incoming transition flow and a transition cycle can involve transitions of a nested state machines. Such cycles cannot be detected by this validation rule. ART_0019_unwiredPortBothPublisherAndSubscriber Severity Reason Quick Fix Error An unwired port is declared as being both a subscriber and publisher at the same time. Make Publisher, Make Subscriber An unwired port can at runtime be connected to another unwired port. One of the connected ports will be a publisher port (a.k.a SPP port) while the other will be a subscriber port (a.k.a SAP port). An unwired port can either be statically declared as being a publisher or subscriber port, or it can be dynamically decided at port registration time if the port should be a publisher or subscriber. The same port can not be both a subscriber and a publisher port at the same time. Two Quick Fixes are available for making the port a publisher or a subscriber port by removing either the subscribe or publish keyword. capsule UnwiredCapsule { subscribe publish behavior port p1 : UnwiredProtocol; // ART_0019 statemachine { state State; initial -> State; }; }; ART_0020_wiredPortWithUnwiredProperties Severity Reason Quick Fix Warning A property that only is applicable for an unwired port is specified for a wired port. N/A An unwired port may have properties that control how it will be registered at runtime (see registration and registration_name ). These properties have no meaning and will be ignored for wired ports. capsule UnwiredCapsule2 { behavior port p1 [[rt::properties( registration_name=\"hi\" )]]: UnwiredProtocol; // ART_0020 statemachine { state State; initial -> State; }; }; ART_0021_unwiredPortRegNameSameAsPortName Severity Reason Quick Fix Warning An unwired port is set to use a registration name that equals the name of the port. N/A When an unwired port is registered a name is used that by default is the name of the port. The property registration_name can be used for specifying another name. It's hence unnecessary to use that property for specifying the name of the port, since it is the default name that anyway would be used. capsule UnwiredCapsule3 { unwired publish behavior port p1~ [[rt::properties( registration_name = \"p1\" )]] : UnwiredProtocol; // ART_0021 statemachine { state State; initial -> State; }; }; ART_0022_ruleConfigProblem Severity Reason Quick Fix Warning The rule_config property has a malformed value. N/A The rule_config property can be set on Art elements to configure which validation rules to run for that element (and for all elements it contains). It can also be used for setting a custom severity for those rules. The value of the rule_config property should be a comma-separated list of 5 letter strings where the first letter specifies if the rule is disabled and it's severity (X,I,W,E) and remaining letters specify the rule id. See Configuring Validation for more information and examples. capsule RCP [[rt::properties( rule_config=\"X0000\" // ART_0022 (a validation rule with id 0000 does not exist) )]]{ statemachine { state State; initial -> State; }; }; ART_0023_entryExitCodeCount Severity Reason Quick Fix Error A state has too many entry and/or exit actions. N/A A state can at most have one entry and one exit action. Solve this problem by merging all entry and exit actions of the state to a single entry and exit action that performs everything that should be done when the state is entered and exited. capsule CX { statemachine { state Composite { entry // ART_0023 ` entry1(); `; entry // ART_0023 ` entry2(); `; }; initial -> Composite; }; }; ART_0024_unwiredPortNotBehavior Severity Reason Quick Fix Error An unwired port is not defined as a behavior port. Make Behavior Port, Make Wired Port An unwired port cannot be connected to another port by means of a connector . Hence, it's required that an unwired port is defined to be a behavior port. Otherwise it would not be possible for the owner capsule to send and receive events on an unwired port. capsule Pinger { service publish unwired port p1 : PROTO; // ART_0024 statemachine { state State1; initial -> State1; }; }; Two Quick Fixes are available for fixing this problem. Either the port can be turned into a behavior port, or it can be turned into a wired port. ART_0025_portConnectionError Severity Reason Quick Fix Error A wired port is not properly connected, or an unwired port is connected. N/A An unwired port must not be connected to another port by means of a connector . Instead you should register such a port dynamically so that it can be connected at runtime with another matching port. A wired port, however, must be connected. A service port that is not a behavior port must be connected both on the \"inside\" and on the \"outside\" by two connectors. That is because the purpose of such a relay port is to simply relay communication from one port to another. By \"inside\" we mean the composite structure of the capsule that owns the port, and by \"outside\" we mean the composite structure to which the part that is typed by the capsule belongs. If the service port is instead a behavior port, it should only be connected on the \"outside\". capsule Top { part ping : Pinger, // ART_0025 (not connected in capsule Top) pong : Ponger; // ART_0025 (not connected in capsule Top) statemachine { state T21; initial -> T21; }; }; capsule Inner { service behavior port p : PROTO; statemachine { state State; initial -> State; }; }; capsule Pinger { service port p1 : PROTO; part inner : Inner; connect p1 with inner.p; statemachine { state State1; initial -> State1; }; }; capsule Ponger { service behavior port p2~ : PROTO; statemachine { state State1; initial -> State1; }; }; In the above picture we can more easily understand the two errors reported for the Top capsule's two parts ping and pong . Port Ponger::p2 is a behavior port so one connection is expected for that port (but none is present), while port Pinger::p1 is a non-behavior port so two connections are expected for that port (but only one is present, on its \"inside\"). Both problems can be solved by adding a connector in Top which connects these ports on their \"outside\". ART_0026_connectedPortsWithIncompatibleConjugations Severity Reason Quick Fix Error A connector connects two ports with incompatible conjugations. N/A Ports connected by a connector must have compatible conjugations. If the ports are at the same level in the capsule's structure (e.g. both ports belong to capsules typing capsule parts owned by the same capsule), then the connected ports must have opposite conjugations. This is because events that are sent out from one of the ports must be able to be received by the other port. However, if the ports are at different levels in the capsule's structure (e.g. one of them belongs to a capsule typing a capsule part owned by the capsule and the other belongs to the capsule itself), then the ports must have the same conjugation. This is because in this case events are simply delegated from one capsule to another. capsule Top { part ping : Pinger, pong : Ponger; connect ping.p1 with pong.p2; // ART_0026 (same port conjugations but should be different) statemachine { state T21; initial -> T21; }; }; capsule Inner { service behavior port p : PROTO; statemachine { state State; initial -> State; }; }; capsule Pinger { service port p1~ : PROTO; part inner : Inner; connect p1 with inner.p; // ART_0026 (different port conjugations but should be same) statemachine { state State1; initial -> State1; }; }; capsule Ponger { service behavior port p2~ : PROTO; statemachine { state State1; initial -> State1; }; }; Here we see that both connectors are invalid. Port p2 and port p1 are at the same level in Top 's structure so their conjugations should be different, while port p1 and port p are at different levels in Top 's structure so their conjugations should be the same. ART_0027_incompatibleProtocolsForConnectedPorts Severity Reason Quick Fix Error A connector connects two ports with incompatible protocols. N/A Ports connected by a connector must have compatible protocols. For Code RealTime this means that the protocols must be the same. Note Model RealTime uses a different criteria for protocol compatibility. There two protocols are compatible if all events that can be sent by a port typed by the source protocol can be received by the other port typed by the target protocol. Also in Model RealTime the most common case is that the source and target protocols are the same, but they can also be different as long as all their events (both in-events and out-events) match both by name and parameter data type. This is a legacy behavior which is not recommended to use, and hence not supported by Code RealTime. protocol PROTO1 { in pong(); out ping(); }; protocol PROTO2 { in pong(); out ping(); }; protocol PROTO3 { in pong(); out ping3(); }; capsule Top { service port p1 : PROTO1; service port p2~ : PROTO2; service port p3~ : PROTO3; connect p1 with p2; // ART_0027 (but OK in Model RealTime) connect p1 with p3; // ART_0027 (also not OK in Model RealTime due to event ping3) statemachine { state T21; initial -> T21; }; }; ART_0028_unwiredPortWithAutoRegNeitherPublisherNorSubscriber Severity Reason Quick Fix Error An unwired port is registered automatically but is neither specified as a publisher or subscriber. Make Publisher, Make Subscriber An unwired port is either a publisher (SPP) or subscriber (SAP) at run-time. Unless the port has the registration property set to application it will be registered automatically when the container capsule instance gets created. Hence it's necessary in this case to declare the port either as a publisher or subscriber. capsule CCXX { unwired behavior port pu // ART_0028 [[rt::properties( registration=automatic_locked )]] : PPX; unwired service behavior port pu2 : PPX; // ART_0028 (default registration is \"automatic\") statemachine { state State; initial -> State; }; }; Two Quick Fixes are available for fixing this problem. Either the port can be declared as a publisher (keyword publish ) or as a subscriber (keyword subscribe ). ART_0029_transitionToCompositeStateNoEntry Severity Reason Quick Fix Warning A composite state is entered without using an entry point. N/A If a composite state is entered without using an entry point, the behavior may be different the first time the state is entered compared to subsequent times it's entered. The first time the initial transition of the composite state will execute, while after that it will be entered using deep history (i.e. directly activate the substate that was previously active in the composite state). This difference in behavior is not evident just by looking at the state diagram, and can therefore be surprising and cause bugs. It's therefore recommended to always enter a composite state using an entry point. See Hierarchical Statemachines for more information. capsule Cap { statemachine { state BS { entrypoint ep1; initial -> Nested; state Nested; }; _Initial: initial -> BS; // ART_0029 }; }; ART_0030_transitionToCompositeStateNoEntryNoInitialTrans Severity Reason Quick Fix Error A composite state is entered without using an entry point, and its state machine has no initial transition. N/A This validation rule is related to ART_0029_transitionToCompositeStateNoEntry . If a composite state is entered without using an entry point, and the nested state machine of the composite state has no initial transition, then it is undefined what to do when entering the state. This is therefore not allowed. capsule Cap { statemachine { state BS { entrypoint ep1; state Nested; }; _Initial: initial -> BS; // ART_0030 }; }; ART_0031_portBothNonServiceAndNonBehavior Severity Reason Quick Fix Error A port is both a non-service and a non-behavior port at the same time. Make Behavior Port, Make Service Port A port that is not a service port is internal to a capsule. For such a port to be useful it must be a behavior port; otherwise the capsule cannot send and receive events on the port. Hence, a non-service port cannot at the same time be a non-behavior port. Quick Fixes are available for either declaring the port as a behavior or service port. capsule C31 { port fp : Proto; // ART_0031 statemachine { state State; initial -> State; }; }; ART_0032_unrecognizedColor Severity Reason Quick Fix Warning A color is specified for an element but the color was not recognized. N/A A color can be assigned to most elements and will be used when showing the element on a diagram. Colors should be specified as RGB values using 6 hexadecimal digits. In case the color value is on another format it will not be recognized and will be ignored when rendering the diagram. capsule C32 { behavior port frame [[rt::properties(color=\"#gd1d1d\")]]: Frame; // ART_0032 (invalid hex digit 'g') behavior port p [[rt::properties(color=\"#cc\")]] : Proto; // ART_0032 (too few digits) statemachine { state State [[rt::properties(color=\"#5d04040\")]]; // ART_0032 (too many digits) initial -> State; }; }; ART_0033_connectedNonServicePortOnPart Severity Reason Quick Fix Error A connector connects a port on a part but the port is not a service port. N/A A port is only visible from the outside of a capsule if it is a service port. Hence, a connector cannot connect a port on a part unless the port is a service port. capsule C33 { optional part thePart : Other; behavior port bp~ : Proto; connect bp with thePart.bp2; // ART_0033 statemachine { state State; initial -> State; }; }; capsule Other { behavior port bp2 : Proto; statemachine { state State; initial -> State; }; } In a structure diagram this error means that a connector \"crosses a capsule boundary\" by connecting two ports at different levels in the composite structure. The solution here is to either make bp2 a service port, or to create another service port in the Other capsule and then connect that port both to bp on the \"outside\" and to bp2 on the \"inside\". ART_0034_servicePortWithoutEvents Severity Reason Quick Fix Warning A service port is typed by a protocol that doesn't have any events. N/A A service port is part of the externally visible communication interface for a capsule. Hence the protocol that types a service port should have at least one event, otherwise the service port doesn't add any value. The only exception is a notification port which receives the rtBound and rtUnbound events when the port gets connected or disconnected to another port at runtime. This means that a notification port can be useful even if its protocol doesn't contain any events. protocol EmptyProtocol { }; capsule C34 { service port myPort : EmptyProtocol; // ART_0034 statemachine { state State; initial -> State; }; }; ART_0035_timerServicePort Severity Reason Quick Fix Warning A timer port is a declared to be a service port. Make Non-Service Behavior Port A timer port is typed by the predefined Timing protocol. It has one event timeout which is sent to the port after a certain timeout period (either once or periodically). Other capsules cannot send the timeout event to the capsule that owns the timer port. Hence a timer port should always be a non-service behavior port. A Quick Fix is available that will remove the service keyword for the port and if necessary also add the behavior keyword. capsule C35 { service port t : Timing; // ART_0035 statemachine { state State; initial -> State; }; }; Code Generation Validation Rules Some problems in an Art file cannot be detected until it's translated to C++ code. The code generator implements validation rules for detecting and reporting such problems. Note When an Art file is edited in the UI code generation validation rules run just after the Art validation rules . However, they will only run if there is an active TC, since otherwise code generation will not happen. When you run the Art Compiler and the Art validation rules found at least one problem with Error severity, then code generation will not happen and hence these validation rules will not run. Validation rules that are related to code generation can be enabled and disabled, and have their severity customized, in the same way as the Art validation rules. Code generation validation rules have the prefix \"CPP\" and ids in the range starting from 4000 and above. They are listed below. CPP_4000_eventTypeWithoutTypeDescriptor Severity Reason Quick Fix Warning An event type has a type for which no type descriptor could be found. N/A If an event has a data parameter the type of this parameter must have a type descriptor . Otherwise the TargetRTS doesn't know how to copy or move the data at run-time when the event is sent. The TargetRTS provides type descriptors for most predefined C++ types. For user-defined types the code generator assumes a type descriptor will be available for it (either automatically generated by means of the rt::auto_descriptor attribute, or manually implemented ). It's necessary that such a user-defined type is defined so that it can be referenced from the event with a simple name without use of qualifiers, type modifiers or template arguments. Use a typedef or type alias to give a simple name to an existing type that for example is defined in a different namespace. If the code generator doesn't find a type descriptor for the event parameter type, CPP_4000 will be reported, and the C++ function that is generated for the event will have void type (i.e. the same as if the event doesn't have a data parameter). protocol PROT { out e1(`MyClass*`); // ART_4000 (type modifier present) out e2(`std::string`); // ART_4000 (qualified name) out e3(`TplClass<int>`); // ART_4000 (template parameter present) }; CPP_4001_unreachableTransition Severity Reason Quick Fix Warning One or many transitions are unreachable due to ambiguous triggers. N/A If there are multiple outgoing transitions from a state with identical triggers (i.e. having the same port and the same event, and no guard condition), then it's ambiguous which one of them that will be triggered. In this situation the code generator will pick one of them to execute, and report the other ones as unreachable. The unreachable transitions will be reported as related elements so you can navigate to them and decide how to resolve the ambiguity. Common solutions for this problem is to add a guard condition, either on the trigger or the transition. With a guard condition the ambiguity is resolved, but it's of course then important to ensure that guard conditions are mutually exclusive so that only one of the transitions can execute. The code generator cannot ensure this, since guard conditions are evaluated at run-time. capsule XCap { behavior port t : Timing; statemachine { state State1, State2; initial -> State1 ` t.informIn(RTTimespec(1,0)); `; t1: State1 -> State2 on t.timeout; t2: State1 -> State2 on t.timeout; // CPP_4002 }; }; Code for calling unreachable transitions will still be generated, but preceeded with a comment. Here is an example: case Timing::Base::rti_timeout: chain2_t1( ); return ; // WARNING: unreachable code; chain3_t2( ); return ; CPP_4002_guardedInitialTransition Severity Reason Quick Fix Error The initial transition leads to a junction where all outgoing transitions have guard conditions. N/A The initial transition is the first transition that executes in a state machine. It must always lead to the activation of a state where the state machine will stay until it receives its first event. It is allowed to use junctions in the initial transition to let guard conditions decide which state that should be activated. However, in this case it's required that there is at least one junction transition without a guard condition (or with an else guard). If all transition paths are guarded there is a risk that none of the guard conditions will be fulfilled, which would mean that no state will be activated. That would effectively break the functioning of the state machine. capsule N { statemachine { state State; junction j; initial -> j; j -> State when `x == 5`; // CPP_4002 }; }; TC Validation Rules TC files are validated to detect problems related to TC properties. The rules that perform this validation can be enabled and disabled, and have their severity customized, in the same way as the Art validation rules . They use the prefix \"TC\" and ids in the range starting from 7000 and above. These rules are listed below. TC_7000_wrongValueType Severity Reason Quick Fix Error A TC property has the wrong type of value. N/A Each TC property has a type as shown in this table . The value provided for a TC property must have the expected type. Here are some examples where TC property values have types that don't match the types of these TC properties: tc.copyrightText = true; // TC_7000 (expects a string, and not a boolean) tc.cppCodeStandard = 98; // TC_7000 (expects an enum string such as \"C++ 98\", and not a number) tc.sources = ''; // TC_7000 (expects a list of strings, and not a single string) TC_7001_tcPropertyNotYetSupported Severity Reason Quick Fix Warning A TC property is assigned a value, but Code RealTime does not yet support this property. N/A TC files are not only used by Code RealTime but also by Model RealTime. Even if the format of TC files is the same in these products, there are certain TC properties which are supported by Model RealTime, but not yet supported by Code RealTime. You can still assign values to such properties but they will be ignored. tc.compilationMakeInsert = ''; // TC_7001 TC_7002_propertyNotApplicableForLibraryTC Severity Reason Quick Fix Warning A TC property that is only applicable for an executable TC is used in a library TC. N/A Certain TC properties are only meaningful if used in a TC that builds a library. For example, setting linkCommand does not make sense on a library TC since a library is not linked. let tc = TCF.define(TCF.CPP_TRANSFORM); // The \"topCapsule\" property is not set, which means this is a library TC tc.linkCommand = 'ld'; // TC_7002 TC_7003_prerequisitePathError Severity Reason Quick Fix Error A prerequisite TC cannot be resolved. N/A TCs that are specified as prerequisites must exist. If the path cannot be resolved to a valid TC file then it must either be corrected or deleted. A relative path is resolved against the location of the TC where the prerequisites property is set. tc.prerequisites = [\"../../TestUtils/testlibX.tcjs\"]; // TC_7003 (referenced TC file does not exist) TC_7004_invalidTopCapsule Severity Reason Quick Fix Error The specified top capsule cannot be found. N/A The topCapsule property is mandatory for executable TCs. In fact, it's the presence of this property that makes it an executable TC. A capsule with the specified name must exist in one of the Art files that is built by the TC (directly or indirectly). If you specify a top capsule that cannot be found, make sure you have spelled it correctly (use Content Assist in the TC editor so you can avoid typos). Also make sure that the Art file where the top capsule is defined is not excluded from the build by use of the sources property. tc.topCapsule = 'NonExistentCapsule'; // TC_7004 (referenced top capsule does not exist) TC_7005_invalidUnitName Severity Reason Quick Fix Error The unitName property contains characters that are illegal in a file name. N/A The unitName property specifies the name of the generated unit files (by default called UnitName.h and UnitName.cpp ). Hence, it cannot contain characters that are not allowed in a file name. Different operating systems have different rules that a valid file name must adhere to. tc.unitName = 'UnitName:1'; // TC_7005 (colon is not a valid file name character on Windows) TC_7006_invalidTargetRTSLocation Severity Reason Quick Fix Error The specified path to the TargetRTS does not exist or is invalid. N/A The targetRTSLocation property must specify a folder that exists and contains a TargetRTS to compile generated code against. tc.targetRTSLocation = \"C:\\\\MyTargets\\\\\"; // TC_7006 (if that folder does not exist) TC_7007_invalidTargetConfig Severity Reason Quick Fix Error The specified target configuration does not exist. N/A The targetConfiguration property must specify the name of a target configuration that exists in the folder specified by the targetRTSLocation property. If you specify a target configuration that cannot be found, make sure you have spelled it correctly (use Content Assist in the TC editor so you can avoid typos). tc.targetConfiguration = \"WinT.x64-MinGW-12.2.0\"; // TC_7007 (misspelled \"MinGw\") TC_7008_invalidCodeStandard Severity Reason Quick Fix Error The specified C++ code standard does not exist. N/A The cppCodeStandard property must specify a valid C++ code standard. If you specify a code standard that cannot be found, make sure you have spelled it correctly (use Content Assist in the TC editor so you can avoid typos). tc.cppCodeStandard = \"C++ 18\"; // TC_7008 (there is no C++ language standard C++ 18) TC_7009_invalidTargetFolder Severity Reason Quick Fix Error The specified target folder is invalid. N/A The targetFolder property specifies the folder where to place generated files. The folder doesn't have to exist, since it will be created automatically by the code generator if needed. However, it's required that the folder has a name that is valid. Different operating systems have different rules that a valid folder name must adhere to. tc.targetFolder = 'capsule_cpp_inheritance_target:'; // TC_7009 (invalid character ':' in target folder) TC_7010_physicalThreadWithoutLogicalThread Severity Reason Quick Fix Warning A physical thread has no logical thread mapped to it. N/A A physical thread is referenced through a logical thread that is mapped to it in the TC. Multiple logical threads can be mapped to the same physical thread, but if a physical thread has no logical threads mapped to it, it's useless since it then cannot be referenced by the application. Note that this rule does not apply for the default MainThread and TimerThread. Solve this problem either by deleting the Thread object that represents the physical thread from the TC, or map a logical thread to it using the logical property. See the threads property for more information. tc.threads = [ { name: 'MyThread', logical: [ ] // TC_7010 } ]; TC_7011_duplicatePhysicalThreadName Severity Reason Quick Fix Error There are multiple physical threads with the same name. N/A The names of physical threads in an application must be unique. See the threads property for more information. tc.threads = [ { name: 'MyThread', logical: [ 'L1' ] }, { name: 'MyThread', // TC_7011 (MyThread already defined) logical: [ 'L2' ] } ]; TC_7012_duplicateLogicalThreadName Severity Reason Quick Fix Error There are multiple logical threads with the same name. N/A The names of logical threads in an application must be unique. In a library TC the logical threads are specified as a list of strings in the threads property and this list should not contain duplicates. In an executable TC the logical threads are instead defined implicitly when mapping them to physical threads using the logical property on the Thread object. Also in this case, the same logical thread name should not be used more than once. tc.threads = [ { name: 'MyThread', logical: [ 'L1', 'L1', 'L2' ] // TC_7012 (L1 defined (and mapped to MyThread) twice) }, { name: 'MyThread2', logical: [ 'L2' ] // TC_7012 (L2 already mapped to MyThread above) } ]; A special situation is when an executable TC has several library TCs as prerequisites (direcly or indirectly). These library TCs may define logical threads with clashing names. You must make sure that names of logical threads in all prerequisite libraries are unique. One way to accomplish this could be to prefix a logical thread in a library with the name of the library. TC_7013_physicalThreadsInLibrary Severity Reason Quick Fix Warning Physical threads are defined in a library TC. N/A In a library TC you should only define logical threads. These must be mapped to physical threads in the executable TC which has the library TC as a prerequisite. If you anyway define physical threads in a library TC, they will be ignored. See the threads property for more information. // tc.topCapsule not defined, i.e. this is a library TC tc.threads = [ // TC_7013 { name: 'MyThread', logical: [ 'L1' ] } ]; TC_7014_incorrectThreadProperty Severity Reason Quick Fix Error A thread property is incorrectly specified. N/A This problem is reported if the threads property contains a value of unexpected type. For an executable TC this property should be set to a list of Thread objects representing physical threads, while for a library TC it should be set to a list of strings which are the names of the logical threads defined in the library. The problem is also reported if a Thread object for a physical thread has a property of unexpected type. All properties of such a Thread object should be of string type, except logical which should be a list of strings. tc.threads = [ { name: 'MyThread', priority: 20000, // TC_7014 (the priority should be specified as a string and not a number) logical: [ 'L1' ] } ]; TC_7015_libraryThreadNotMappedToPhysicalThread Severity Reason Quick Fix Error A logical thread in a library TC is not mapped to a physical thread. N/A A library TC uses the threads property for specifying logical threads. When an executable TC uses a library TC as its prerequisite, all logical threads of the library must be mapped to physical threads. Read more about library threads here . // In a library TC lic.tcjs: tc.threads = [ 'LibThread1', 'LibThread2' ]; // In an executable TC exe.tcjs: tc.prerequisites = [\"lib.tcjs\"]; tc.threads = [ { name: 'MyThread', logical: [ 'LibThread1' ] // TC_7015 (library logical thread 'LibThread2' not mapped) } ]; Core Validation Rules There are certain core rules that run before the semantic validation rules mentioned above. They are responsible for making sure that the Art file is syntactically correct and that all references it contains can be successfully bound to valid Art elements. Since these rules run before semantic validation rules they cannot be disabled or have their severity changed. Core validation rules have ids in the range starting from 9000 and above and are listed below. ART_9000_syntaxError Severity Reason Quick Fix Error Parsing of the Art file failed due to a syntax error. Remove Extraneous Input If an Art file contains a syntax error, it cannot be parsed into valid Art elements and the parser will then report this error. There are many ways to introduce syntax errors in an Art file and the error message from the parser will usually help you understand what is wrong by telling you both what incorrect thing was encountered and what is instead expected at that position. If the syntax error is caused by extra characters at a place where no extra characters are expected a Quick Fix can be used for removing the \"extraneous input\". capsule A { state machine // ART_9000 (mismatched input 'state' expecting 'statemachine') }; capsule B { statemachine { state State; initial -> State; }; prt // ART_9000 (extraneous input 'prt' expecting '}') }; ART_9001_unresolvedReference Severity Reason Quick Fix Error A referenced Art element cannot be found. N/A For an Art file to be well-formed, all references it contains must be possible to resolve to valid Art elements (located either in the same Art file, or in another Art file in the workspace). Aside from simple spelling mistakes, the most common reason for this error is that you forgot to add the folder that contains the Art file with the target Art element into the workspace. Also note that if the referenced Art element is in a different workspace folder you must have an active TC which specifies a TC in that workspace folder as a prerequisite. capsule C { port p : Unknown; // ART_9001 (Couldn't resolve reference to Protocol 'Unknown'.) statemachine { state State; initial -> State; }; }; Internal Errors A special validation rule is used for detecting and reporting so called internal errors. These are errors that should never occur, but if they still do they are caused by a defect in Code RealTime. If you encounter an internal error please report it as described here . ART_9999_internalError Severity Reason Quick Fix Error An internal error has occurred. N/A Internal errors may arise from bugs and often result from unexpected situations. While it may be possible to workaround an internal error, the problem can only be fully solved by updating Code RealTime. Therefore, the first thing you should do if you get an internal error is to make sure you are running the latest version of Code RealTime (see Releases ). If you don't, then please uplift to the latest version as there is a chance the problem has been fixed in that version. If that doesn't help, please report the internal error as described here .","title":"Validation"},{"location":"validation/#problem-severity","text":"Each validation rule has a default severity which will be used for the problems that are reported by the rule: Error An error is a problem that is severe enough to prevent building a correct application. Errors must be fixed, and it will not be possible to build the Art files into a C++ application until all errors have been resolved. Warning A warning is a potential problem, which you may or may not choose to fix. It can for example indicate a deviation from common conventions and best practises and it can indicate that the application will not behave as you may expect. Information An information is just a message that you should be aware of. It doesn't really indicate a problem, and you don't need to fix it. You can customize the default severity of any validation rule, and you can also choose to completely disable a certain validation rule that you don't think provides any value. See Configuring Validation for more information.","title":"Problem Severity"},{"location":"validation/#problem-reporting","text":"When a validation rule has found a problem in an Art file, it is marked by underlining one or several Art elements in the file. The underlining is red for errors, yellow for warnings and blue for information messages. For example, in the capsule shown below one warning and two errors have been found. You can hover the cursor over these underlinings to get a tooltip with information about the problem. Every problem has a message that describes it. Often this message gives enough information for understanding how to fix the problem. If this is not the case you can go to the documentation about the validation rule to find more information, examples and suggestions for how the problem can be fixed. To easily find the documentation click the hyperlink that consists of the unique id of the validation rule (it starts with a prefix such as \"ART_\", followed by a 4 digit number and a name). Alternatively you can search for the validation rule id on this page. Often a problem may be associated with more than one Art element. There is a main element on which the problem will be shown, but there often also are other elements that are related to the problem in one way or another. You can navigate to related elements to get a better understanding of why a problem is reported and how to fix it. In the screenshot above the problem has a single related element (the capsule tlSystem ) but in general a problem can have an arbitrary number of related elements. Problems are also reported by means of icons in diagrams. Below are three states with problems of different severity: A problem icon has a tooltip that shows the message of the problem. You can disable problem reporting in diagrams by means of a configuration setting code-rt.diagram.showDiagnostics . For a TC file, all properties it contains will be validated, and problems that are found during this validation are shown by underlining TC properties. You can hover","title":"Problem Reporting"},{"location":"validation/#problems-view","text":"Too see all problems found in all Art files and all TC files in the workspace, open the Problems view. The total number of problems found are shown in the Problems view heading. By default problems are shown in a tree grouped by the files where they were found. However, you can also view them as a flat table instead (but note that related elements can only be seen when using the tree view). If there are many problems, it can help to filter the Problems View by typing some text in the filter box. For example, you can filter using a regular expression that matches only some of the files in the workspace, to reduce the number of problems shown.","title":"Problems View"},{"location":"validation/#quick-fix","text":"Some problems have one or several typical solutions that are possible to apply automatically by means of \"code actions\". If a problem has at least one such code action defined, a yellow light bulb icon will appear and a Quick Fix command will be available in the problem tooltip. Note that most semantic errors cannot be automatically resolved like this, but in some simple cases it's possible.","title":"Quick Fix"},{"location":"validation/#configuring-validation","text":"Validation can be configured to change which rules that should run, and what severity they should report found problems with. By default every validation rule is enabled and uses a predefined severity level. Validation rules can be configured either globally by means of a setting, or locally by means of a property rule_config . In both cases the rule configuration consists of a comma-separated list of 5 letter strings where the first letter specifies if the rule is disabled and it's severity (X,I,W,E) and remaining letters specify the rule id. For example, the rule configuration X0003,I0004,W0009,E0005 means the following: The rule ART_0003_nameShouldStartWithUpperCase is disabled The rule ART_0004_nameShouldStartWithLowerCase has its severity set to Information The rule ART_0009_invalidProperty has its severity set to Warning The rule ART_0005_choiceWithoutElseTransition has its severity set to Error To configure validation rules globally, use the configuration setting code-rt.validation.ruleConfiguration . A global configuration will apply for all Art files in the workspace, and all Art elements within those files, unless a local rule configuration has been set on an element. To configure validation rules locally, set the property rule_config on an Art element. It will affect the validation of that Art element itself, as well as all elements contained within that Art element. Here is an example of how to disable the validation rule ART_0003_nameShouldStartWithUpperCase on a capsule. Note that it also will disable this rule for elements contained within the capsule, such as states. capsule customCapsule // no warning even if capsule name is not capitalized [[rt::properties( rule_config=\"X0003\" )]]{ statemachine { state customState; // no warning here too initial -> customState; }; }; Note Certain validation rules cannot be disabled or have their severity changed. These are known as \"core validation rules\" and they run before semantic validation starts (which is why they cannot be customized). Note Local configuration of validation rules is only supported for Art files. For TC validation you cannot provide a local rule configuration in the TC file.","title":"Configuring Validation"},{"location":"validation/#validation-rules","text":"This chapter lists all validation rules which Code RealTime checks your Art application against. These rules find problems in Art files and all problems found have the \"ART_\" prefix.","title":"Validation Rules"},{"location":"validation/#art_0001_invalidnamecpp","text":"Severity Reason Quick Fix Error An Art element has a name that is not a valid C++ name, or a name that will cause a name clash in the generated code. Prepend Underscore Art elements are translated to C++ elements without changing the elements' names. Hence you need to choose names for Art elements that are valid in C++. For example, C++ keywords cannot be used. Furthermore, names of such Art elements must not clash with global names used by the TargetRTS or names within generated C++ files. If you ignore this error you can expect errors when compiling the generated C++ code. A Quick Fix is available that will fix the problem by adding an underscore to the beginning of the name, in order to make it a valid C++ name. protocol InvalidNameProtocol { in virtual(); // ART_0001 (\"virtual\" is a C++ keyword) }; capsule Exception { // ART_0001 (\"Exception\" is a name reserved for use by the TargetRTS) };","title":"ART_0001_invalidNameCpp"},{"location":"validation/#art_0002_duplicatenamesinscope","text":"Severity Reason Quick Fix Error Two or more Art elements in the same scope have the same names or signatures. N/A Names of Art elements must be unique within the same scope. The following is checked: Top-level elements in the global scope (either defined in the same Art file, or in different Art files built by the same TC or prerequisite TCs). The corresponding C++ elements will have names in the global namespace and must hence be unique. Events of a protocol. Note that in-events and out-events are checked separately, since an in-event and an out-event will have the same name when you define a symmetric event (see Protocol and Event ). Parts of a capsule. Ports of a capsule. States and pseudo states (collectively referred to as \"vertices\") of a state machine. Transitions of a state machine. Trigger operations of a class . Note that several trigger operations may have the same name as long as their signatures are unique. All elements with clashing names or signatures will be reported as related elements. Use this to find the element(s) that need to be renamed. protocol DupProto { in inEvent1(); // ART_0002 in inEvent1(); // ART_0002 out inEvent1(); // OK (symmetric event) }; class DNIS { trigger op1(`int` p); trigger op1(); // OK (signatures are unique) statemachine { state State; initial -> State; }; };","title":"ART_0002_duplicateNamesInScope"},{"location":"validation/#art_0003_nameshouldstartwithuppercase","text":"Severity Reason Quick Fix Warning An Art element's name doesn't follow the naming convention to start with uppercase. Capitalize Name Just like in most languages Art has certain conventions on how elements should be named. The following elements should have names that start with an uppercase letter: Capsule Class Protocol State A Quick Fix is available that will fix the problem by capitalizing the name. Note, however, that it will only update the element's name, and not all references. If you have references to the element you may instead want to fix the problem by performing a rename refactoring (context menu command Rename Symbol ). capsule myCapsule { // ART_0003 statemachine { state sstate; // ART_0003 initial -> sstate; }; }; In this context an underscore ( _ ) is considered a valid upper case character, so all names that start with underscore are accepted by this validation rule.","title":"ART_0003_nameShouldStartWithUpperCase"},{"location":"validation/#art_0004_nameshouldstartwithlowercase","text":"Severity Reason Quick Fix Warning An Art element's name doesn't follow the naming convention to start with lowercase. Decapitalize Name Just like in most languages Art has certain conventions on how elements should be named. The following elements should have names that start with a lowercase letter: Event Port Part Trigger operation Choice and junction points Entry and exit points Transition A Quick Fix is available that will fix the problem by decapitalizing the name. Note, however, that it will only update the element's name, and not all references. If you have references to the element you may instead want to fix the problem by performing a rename refactoring (context menu command Rename Symbol ). protocol LowerCaseTestProtocol { out MyEvent(); // ART_0004 }; In this context an underscore ( _ ) is considered a valid lower case character, so all names that start with underscore are accepted by this validation rule.","title":"ART_0004_nameShouldStartWithLowerCase"},{"location":"validation/#art_0005_choicewithoutelsetransition","text":"Severity Reason Quick Fix Warning A choice lacks an outgoing else-transition. N/A If no outgoing transition of a choice is enabled at runtime (because no outgoing transition has a guard condition that is fulfilled) then the state machine will get stuck in the choice for ever. To avoid this you should ensure that at least one outgoing transition is enabled. A good way to do this is to use 'else' as the guard condition for one of the outgoing transitions. Such an else-transition will then execute if no other outgoing transition of the choice is enabled. capsule ChoiceSample { statemachine { state State; initial -> State; choice x; // ART_0005 State -> x; x -> State when `return getVal() == 5;`; }; }; Note that a transition without any guard condition is equivalent to a transition with a guard condition that is always fulfilled (i.e. a guard condition that returns true). An outgoing transition from a choice or junction without any guard is therefore also an else-transition.","title":"ART_0005_choiceWithoutElseTransition"},{"location":"validation/#art_0006_choicewithoutoutgoingtransitions","text":"Severity Reason Quick Fix Error A choice has no outgoing transitions. N/A A choice should typically have at least two outgoing transitions to be meaningful. Having only one outgoing transition is possible if it is an else-transition (i.e. a transition with an 'else' guard, or without any guard at all). However, a choice without any outgoing transition is not allowed since the state machine always will get stuck when reaching such a choice. capsule ChoiceSample { statemachine { state State; initial -> State; choice x; // ART_0006 State -> x; }; };","title":"ART_0006_choiceWithoutOutgoingTransitions"},{"location":"validation/#art_0007_choicewithtoomanyelsetransitions","text":"Severity Reason Quick Fix Error A choice has more than one outgoing else-transition. N/A It's good practise to have an outgoing else-transition (i.e. a transition with an 'else' guard, or without any guard at all) for a choice since it will prevent the state machine from getting stuck in the choice at runtime. However, there should not be more than one such else-transition defined, since otherwise it's ambiguous which one of them to trigger in the case none of the other outgoing transitions from the choice are enabled. capsule ChoiceSample { statemachine { state State, State2; initial -> State; choice x; // ART_0007 State -> x; x -> State; x -> State2 when `else`; }; };","title":"ART_0007_choiceWithTooManyElseTransitions"},{"location":"validation/#art_0008_initialtransitioncount","text":"Severity Reason Quick Fix Error A state machine has too many initial transitions, or no initial transition at all. N/A A state machine of a capsule or class must have exactly one initial transition. A common reason for this error is that you have introduced inheritance between two capsules which both have state machines with an initial transition. Because of that the derived capsule will have two initial transitions (the one it defines itself locally plus the one it inherits from the base capsule). In this case the error can be fixed by either deleting or excluding the initial transition from the derived capsule, or to let it redefine the initial transition from the base capsule. capsule InitTransCap2 { statemachine { state State; initial -> State; }; }; capsule InitTransCap3 : InitTransCap2 { statemachine { // ART_0008 (1 local initial transition and 1 inherited) state State2; initial -> State2; }; }; capsule NoInitTrans { statemachine { // ART_0008 (no initial transition) state State; }; }; Note that if the initial transition in the base capsule has no name, the derived capsule cannot exclude or redefine it. It's therefore good practise to name the initial transition if you expect your capsule to be inherited from. The validation rule also checks nested state machines. Such a state machine doesn't need any initial transition, since the composite state can be entered via an entrypoint which takes the nested state machine to its first state. However, if the nested state machine has an initial transition there cannot be more than one. capsule InitTransCap2 { statemachine { initial -> Composite; state Composite { state NS; initial -> NS; }; }; }; capsule InitTransCap3 : InitTransCap2 { statemachine { state redefine Composite { // ART_0008 (3 local initial transitions and 1 inherited) state S1, S2, S3; initial -> S1; initial -> S2; _ini: initial -> S3; }; }; };","title":"ART_0008_initialTransitionCount"},{"location":"validation/#art_0009_invalidproperty","text":"Severity Reason Quick Fix Error A non-existing property is set for an element. Remove Property Most Art elements have properties that can be set to change their default values. Different elements have different properties and if you get this error it means you have referenced a non-existing property for an Art element. A Quick Fix is available for removing the setting of the invalid property. Use Content Assist ( Ctrl + Space ) to get a list of valid properties for an Art element. protocol IP_PROTO [[rt::properties( no_property = 4 // ART_0009 (a protocol has no property called \"no_property\") )]] { }; capsule CN [[rt::properties( colour=\"#ff0000\" // ART_0009 (misspelled property \"color\") )]] { statemachine { state State; initial -> State; }; };","title":"ART_0009_invalidProperty"},{"location":"validation/#art_0010_invalidpropertyvalue","text":"Severity Reason Quick Fix Error A property is set to a value of incorrect type. N/A Most Art elements have properties and every property has a type that is either boolean, integer, string or an enumeration. The type of the value assigned to a property must match the property's type. For example, you cannot assign an integer value to a boolean property. capsule IPV_Cap [[rt::properties( generate_file_header=4 // ART_0010 (\"generate_file_header\" is a boolean property) )]]{ statemachine { state State; initial -> State; }; };","title":"ART_0010_invalidPropertyValue"},{"location":"validation/#art_0011_propertysettodefaultvalue","text":"Severity Reason Quick Fix Warning A property is set to its default value. Remove Property Most Art elements have properties and every property has a default value. It's unnecessary to explicitly set a property to its default value. A Quick Fix is available for removing the setting of the property. class C_PropDefaultValue [[rt::properties( const_target_param_for_decode=false // ART_0011 )]] { statemachine { state State; initial -> State; }; };","title":"ART_0011_propertySetToDefaultValue"},{"location":"validation/#art_0012_invalidcodesnippet","text":"Severity Reason Quick Fix Error A code snippet is invalid in one way or the other. Remove Code Snippet A code snippet 's kind is specified after the prefix rt:: . Different Art elements may have different kinds of code snippets. Also, some Art elements may have multiple code snippets of a certain kind, while others only may have one code snippet of each kind. A Quick Fix is available for removing the invalid code snippet. [[rt::header_preface]] // ART_0012 (code snippet for capsule/class placed at file level) ` // YourCodeHere ` capsule Name { [[rt::unknown]] // ART_0012 (non-existing kind of code snippet) ` // YourCodeHere ` part x : OtherCap [[rt::create]] ` return new DemoCap_Actor(rtg_rts, rtg_ref); ` [[rt::create]] // ART_0012 (duplicated code snippet) ` return new DemoCap_Actor(rtg_rts, rtg_ref); `; statemachine { state State; initial -> State; }; };","title":"ART_0012_invalidCodeSnippet"},{"location":"validation/#art_0013_partmultiplicityerror","text":"Severity Reason Quick Fix Error The part's lower multiplicity must be less than its upper multiplicity. N/A If a part has a multiplicity that specifies a range (i.e. both a lower and upper multiplicity), then the lower multiplicity must be less than the upper multiplicity. capsule PME_Cap { part myPart : OtherCap [2..2]; // ART_0013 statemachine { state State; initial -> State; }; };","title":"ART_0013_partMultiplicityError"},{"location":"validation/#art_0014_partkindmultiplicityinconsistency","text":"Severity Reason Quick Fix Warning The part's kind is inconsistent with its multiplicity. N/A The multiplicity of a capsule part must match the part's kind. The following is checked: A fixed part must have a multiplicity greater than zero. This is because when the container capsule is incarnated at least one capsule instance must be incarnated into the fixed part. An optional part must have a lower multiplicity of zero. This means that when the container capsule is incarnated no capsule instances will be incarnated into the optional part. Hence, this is what makes the part optional. In case any of these inconsistencies is detected, the faulty multiplicity will be ignored and a default multiplicity (see Part ) will be used instead. capsule PKMI_Cap { fixed part myPart : OtherCap [0..2]; // ART_0014 (Fixed part should not have lower multiplicity 0) optional part myPart2 : OtherCap [1..5]; // ART_0014 (Optional part should not have lower multiplicity > 0) statemachine { state State; initial -> State; }; };","title":"ART_0014_partKindMultiplicityInconsistency"},{"location":"validation/#art_0015_internaltransitionoutsidestate","text":"Severity Reason Quick Fix Error An internal transition is defined outside a state, in the top state machine. N/A An internal transition specifies events that can be handled while a state machine is in a certain state without leaving that state. Hence it's only possible to define an internal transition inside a state. It does not make sense to define an internal transition directly in the top state machine. capsule IntTransOutsideState { behavior port timer : Timing; statemachine { state State { t1 : on timer.timeout ` `; }; initial -> State; terror : on timer.timeout ` `; // ART_0015 }; };","title":"ART_0015_internalTransitionOutsideState"},{"location":"validation/#art_0016_circularinheritance","text":"Severity Reason Quick Fix Error A capsule, class or protocol inherits from itself directly or indirectly. N/A When you use inheritance for capsules, classes and protocols you need to ensure there are no inheritance cycles. Cyclic inheritance means that an element would inherit from itself, directly or indirectly, which is not allowed. Note Both capsules and classes, but not protocols, may have C++ base classes specified by means of C++ code snippets. Such inheritance relationships are not checked by this validation rule, but by the C++ compiler. The elements that form the inheritance cycle will be reported as related elements. Use this to decide how to break the inheritance cycle. protocol PR1 : PR2 { // ART_0016 }; protocol PR2 : PR1 { // ART_0016 }; class C1 { statemachine { state State; initial -> State; }; }; class C2 : C1 { statemachine { state State; initial -> State; }; }; class C3 : C2, C4 { // ART_0016 statemachine { state State; initial -> State; }; }; class C4 : C3 { // ART_0016 statemachine { state State; initial -> State; }; };","title":"ART_0016_circularInheritance"},{"location":"validation/#art_0017_circularcomposition","text":"Severity Reason Quick Fix Error A capsule contains itself through a cycle in the composition hierarchy. N/A Parts of a capsule must form a strict composition hierarchy. At run-time the root of this hierarchy is the top capsule instance, and all other capsule instances in the application must be directly or indirectly owned by that capsule instance. For a fixed part the creation of contained capsule instances happen automatically when the container capsule is incarnated. It's therefore possible to statically analyze the fixed parts and check for cycles in the composition hierarchy. Note Only the static type of fixed capsule parts are used when looking for composition cycles. If a part has a capsule factory that specifies a create function using C++ code, then a different dynamic type may be specified for the created capsule instances for that part. This opens up for more possibilities of introducing cycles in the composition hierarchy that will not be detected by this validation rule. The fixed parts that form the composition cycle will be reported as related elements. Use this to decide how to break the composition cycle. capsule CComp2 { fixed part p2 : CComp3; // ART_0017 statemachine { state State; initial -> State; }; }; capsule CComp3 { part p3 : CComp2; // ART_0017 statemachine { state State; initial -> State; }; };","title":"ART_0017_circularComposition"},{"location":"validation/#art_0018_circulartransitions","text":"Severity Reason Quick Fix Error A state machine has a cycle in the transitions that execute when leaving a junction. N/A A junction can split an incoming transition flow into multiple outgoing transition flows based on evaluating guard conditions for the outgoing transitions. If care is not taken it's possible to introduce cycles in the outgoing transition flows. Such cycles could lead to infinite recursion when the state machine executes, depending on what guard conditions will be fulfilled at runtime. You should therefore ensure there are no such transition cycles. The transitions that form the cycle will be reported as related elements. Use this to decide how to break the transition cycle. capsule CT_cap { statemachine { // ART_0018 state S1; initial -> S1; junction j1, j2; t1: S1 -> j1; t2: j1 -> j2; t3: j2 -> j1; }; }; Note Entry and exit points can also split an incoming transition flow and a transition cycle can involve transitions of a nested state machines. Such cycles cannot be detected by this validation rule.","title":"ART_0018_circularTransitions"},{"location":"validation/#art_0019_unwiredportbothpublisherandsubscriber","text":"Severity Reason Quick Fix Error An unwired port is declared as being both a subscriber and publisher at the same time. Make Publisher, Make Subscriber An unwired port can at runtime be connected to another unwired port. One of the connected ports will be a publisher port (a.k.a SPP port) while the other will be a subscriber port (a.k.a SAP port). An unwired port can either be statically declared as being a publisher or subscriber port, or it can be dynamically decided at port registration time if the port should be a publisher or subscriber. The same port can not be both a subscriber and a publisher port at the same time. Two Quick Fixes are available for making the port a publisher or a subscriber port by removing either the subscribe or publish keyword. capsule UnwiredCapsule { subscribe publish behavior port p1 : UnwiredProtocol; // ART_0019 statemachine { state State; initial -> State; }; };","title":"ART_0019_unwiredPortBothPublisherAndSubscriber"},{"location":"validation/#art_0020_wiredportwithunwiredproperties","text":"Severity Reason Quick Fix Warning A property that only is applicable for an unwired port is specified for a wired port. N/A An unwired port may have properties that control how it will be registered at runtime (see registration and registration_name ). These properties have no meaning and will be ignored for wired ports. capsule UnwiredCapsule2 { behavior port p1 [[rt::properties( registration_name=\"hi\" )]]: UnwiredProtocol; // ART_0020 statemachine { state State; initial -> State; }; };","title":"ART_0020_wiredPortWithUnwiredProperties"},{"location":"validation/#art_0021_unwiredportregnamesameasportname","text":"Severity Reason Quick Fix Warning An unwired port is set to use a registration name that equals the name of the port. N/A When an unwired port is registered a name is used that by default is the name of the port. The property registration_name can be used for specifying another name. It's hence unnecessary to use that property for specifying the name of the port, since it is the default name that anyway would be used. capsule UnwiredCapsule3 { unwired publish behavior port p1~ [[rt::properties( registration_name = \"p1\" )]] : UnwiredProtocol; // ART_0021 statemachine { state State; initial -> State; }; };","title":"ART_0021_unwiredPortRegNameSameAsPortName"},{"location":"validation/#art_0022_ruleconfigproblem","text":"Severity Reason Quick Fix Warning The rule_config property has a malformed value. N/A The rule_config property can be set on Art elements to configure which validation rules to run for that element (and for all elements it contains). It can also be used for setting a custom severity for those rules. The value of the rule_config property should be a comma-separated list of 5 letter strings where the first letter specifies if the rule is disabled and it's severity (X,I,W,E) and remaining letters specify the rule id. See Configuring Validation for more information and examples. capsule RCP [[rt::properties( rule_config=\"X0000\" // ART_0022 (a validation rule with id 0000 does not exist) )]]{ statemachine { state State; initial -> State; }; };","title":"ART_0022_ruleConfigProblem"},{"location":"validation/#art_0023_entryexitcodecount","text":"Severity Reason Quick Fix Error A state has too many entry and/or exit actions. N/A A state can at most have one entry and one exit action. Solve this problem by merging all entry and exit actions of the state to a single entry and exit action that performs everything that should be done when the state is entered and exited. capsule CX { statemachine { state Composite { entry // ART_0023 ` entry1(); `; entry // ART_0023 ` entry2(); `; }; initial -> Composite; }; };","title":"ART_0023_entryExitCodeCount"},{"location":"validation/#art_0024_unwiredportnotbehavior","text":"Severity Reason Quick Fix Error An unwired port is not defined as a behavior port. Make Behavior Port, Make Wired Port An unwired port cannot be connected to another port by means of a connector . Hence, it's required that an unwired port is defined to be a behavior port. Otherwise it would not be possible for the owner capsule to send and receive events on an unwired port. capsule Pinger { service publish unwired port p1 : PROTO; // ART_0024 statemachine { state State1; initial -> State1; }; }; Two Quick Fixes are available for fixing this problem. Either the port can be turned into a behavior port, or it can be turned into a wired port.","title":"ART_0024_unwiredPortNotBehavior"},{"location":"validation/#art_0025_portconnectionerror","text":"Severity Reason Quick Fix Error A wired port is not properly connected, or an unwired port is connected. N/A An unwired port must not be connected to another port by means of a connector . Instead you should register such a port dynamically so that it can be connected at runtime with another matching port. A wired port, however, must be connected. A service port that is not a behavior port must be connected both on the \"inside\" and on the \"outside\" by two connectors. That is because the purpose of such a relay port is to simply relay communication from one port to another. By \"inside\" we mean the composite structure of the capsule that owns the port, and by \"outside\" we mean the composite structure to which the part that is typed by the capsule belongs. If the service port is instead a behavior port, it should only be connected on the \"outside\". capsule Top { part ping : Pinger, // ART_0025 (not connected in capsule Top) pong : Ponger; // ART_0025 (not connected in capsule Top) statemachine { state T21; initial -> T21; }; }; capsule Inner { service behavior port p : PROTO; statemachine { state State; initial -> State; }; }; capsule Pinger { service port p1 : PROTO; part inner : Inner; connect p1 with inner.p; statemachine { state State1; initial -> State1; }; }; capsule Ponger { service behavior port p2~ : PROTO; statemachine { state State1; initial -> State1; }; }; In the above picture we can more easily understand the two errors reported for the Top capsule's two parts ping and pong . Port Ponger::p2 is a behavior port so one connection is expected for that port (but none is present), while port Pinger::p1 is a non-behavior port so two connections are expected for that port (but only one is present, on its \"inside\"). Both problems can be solved by adding a connector in Top which connects these ports on their \"outside\".","title":"ART_0025_portConnectionError"},{"location":"validation/#art_0026_connectedportswithincompatibleconjugations","text":"Severity Reason Quick Fix Error A connector connects two ports with incompatible conjugations. N/A Ports connected by a connector must have compatible conjugations. If the ports are at the same level in the capsule's structure (e.g. both ports belong to capsules typing capsule parts owned by the same capsule), then the connected ports must have opposite conjugations. This is because events that are sent out from one of the ports must be able to be received by the other port. However, if the ports are at different levels in the capsule's structure (e.g. one of them belongs to a capsule typing a capsule part owned by the capsule and the other belongs to the capsule itself), then the ports must have the same conjugation. This is because in this case events are simply delegated from one capsule to another. capsule Top { part ping : Pinger, pong : Ponger; connect ping.p1 with pong.p2; // ART_0026 (same port conjugations but should be different) statemachine { state T21; initial -> T21; }; }; capsule Inner { service behavior port p : PROTO; statemachine { state State; initial -> State; }; }; capsule Pinger { service port p1~ : PROTO; part inner : Inner; connect p1 with inner.p; // ART_0026 (different port conjugations but should be same) statemachine { state State1; initial -> State1; }; }; capsule Ponger { service behavior port p2~ : PROTO; statemachine { state State1; initial -> State1; }; }; Here we see that both connectors are invalid. Port p2 and port p1 are at the same level in Top 's structure so their conjugations should be different, while port p1 and port p are at different levels in Top 's structure so their conjugations should be the same.","title":"ART_0026_connectedPortsWithIncompatibleConjugations"},{"location":"validation/#art_0027_incompatibleprotocolsforconnectedports","text":"Severity Reason Quick Fix Error A connector connects two ports with incompatible protocols. N/A Ports connected by a connector must have compatible protocols. For Code RealTime this means that the protocols must be the same. Note Model RealTime uses a different criteria for protocol compatibility. There two protocols are compatible if all events that can be sent by a port typed by the source protocol can be received by the other port typed by the target protocol. Also in Model RealTime the most common case is that the source and target protocols are the same, but they can also be different as long as all their events (both in-events and out-events) match both by name and parameter data type. This is a legacy behavior which is not recommended to use, and hence not supported by Code RealTime. protocol PROTO1 { in pong(); out ping(); }; protocol PROTO2 { in pong(); out ping(); }; protocol PROTO3 { in pong(); out ping3(); }; capsule Top { service port p1 : PROTO1; service port p2~ : PROTO2; service port p3~ : PROTO3; connect p1 with p2; // ART_0027 (but OK in Model RealTime) connect p1 with p3; // ART_0027 (also not OK in Model RealTime due to event ping3) statemachine { state T21; initial -> T21; }; };","title":"ART_0027_incompatibleProtocolsForConnectedPorts"},{"location":"validation/#art_0028_unwiredportwithautoregneitherpublishernorsubscriber","text":"Severity Reason Quick Fix Error An unwired port is registered automatically but is neither specified as a publisher or subscriber. Make Publisher, Make Subscriber An unwired port is either a publisher (SPP) or subscriber (SAP) at run-time. Unless the port has the registration property set to application it will be registered automatically when the container capsule instance gets created. Hence it's necessary in this case to declare the port either as a publisher or subscriber. capsule CCXX { unwired behavior port pu // ART_0028 [[rt::properties( registration=automatic_locked )]] : PPX; unwired service behavior port pu2 : PPX; // ART_0028 (default registration is \"automatic\") statemachine { state State; initial -> State; }; }; Two Quick Fixes are available for fixing this problem. Either the port can be declared as a publisher (keyword publish ) or as a subscriber (keyword subscribe ).","title":"ART_0028_unwiredPortWithAutoRegNeitherPublisherNorSubscriber"},{"location":"validation/#art_0029_transitiontocompositestatenoentry","text":"Severity Reason Quick Fix Warning A composite state is entered without using an entry point. N/A If a composite state is entered without using an entry point, the behavior may be different the first time the state is entered compared to subsequent times it's entered. The first time the initial transition of the composite state will execute, while after that it will be entered using deep history (i.e. directly activate the substate that was previously active in the composite state). This difference in behavior is not evident just by looking at the state diagram, and can therefore be surprising and cause bugs. It's therefore recommended to always enter a composite state using an entry point. See Hierarchical Statemachines for more information. capsule Cap { statemachine { state BS { entrypoint ep1; initial -> Nested; state Nested; }; _Initial: initial -> BS; // ART_0029 }; };","title":"ART_0029_transitionToCompositeStateNoEntry"},{"location":"validation/#art_0030_transitiontocompositestatenoentrynoinitialtrans","text":"Severity Reason Quick Fix Error A composite state is entered without using an entry point, and its state machine has no initial transition. N/A This validation rule is related to ART_0029_transitionToCompositeStateNoEntry . If a composite state is entered without using an entry point, and the nested state machine of the composite state has no initial transition, then it is undefined what to do when entering the state. This is therefore not allowed. capsule Cap { statemachine { state BS { entrypoint ep1; state Nested; }; _Initial: initial -> BS; // ART_0030 }; };","title":"ART_0030_transitionToCompositeStateNoEntryNoInitialTrans"},{"location":"validation/#art_0031_portbothnonserviceandnonbehavior","text":"Severity Reason Quick Fix Error A port is both a non-service and a non-behavior port at the same time. Make Behavior Port, Make Service Port A port that is not a service port is internal to a capsule. For such a port to be useful it must be a behavior port; otherwise the capsule cannot send and receive events on the port. Hence, a non-service port cannot at the same time be a non-behavior port. Quick Fixes are available for either declaring the port as a behavior or service port. capsule C31 { port fp : Proto; // ART_0031 statemachine { state State; initial -> State; }; };","title":"ART_0031_portBothNonServiceAndNonBehavior"},{"location":"validation/#art_0032_unrecognizedcolor","text":"Severity Reason Quick Fix Warning A color is specified for an element but the color was not recognized. N/A A color can be assigned to most elements and will be used when showing the element on a diagram. Colors should be specified as RGB values using 6 hexadecimal digits. In case the color value is on another format it will not be recognized and will be ignored when rendering the diagram. capsule C32 { behavior port frame [[rt::properties(color=\"#gd1d1d\")]]: Frame; // ART_0032 (invalid hex digit 'g') behavior port p [[rt::properties(color=\"#cc\")]] : Proto; // ART_0032 (too few digits) statemachine { state State [[rt::properties(color=\"#5d04040\")]]; // ART_0032 (too many digits) initial -> State; }; };","title":"ART_0032_unrecognizedColor"},{"location":"validation/#art_0033_connectednonserviceportonpart","text":"Severity Reason Quick Fix Error A connector connects a port on a part but the port is not a service port. N/A A port is only visible from the outside of a capsule if it is a service port. Hence, a connector cannot connect a port on a part unless the port is a service port. capsule C33 { optional part thePart : Other; behavior port bp~ : Proto; connect bp with thePart.bp2; // ART_0033 statemachine { state State; initial -> State; }; }; capsule Other { behavior port bp2 : Proto; statemachine { state State; initial -> State; }; } In a structure diagram this error means that a connector \"crosses a capsule boundary\" by connecting two ports at different levels in the composite structure. The solution here is to either make bp2 a service port, or to create another service port in the Other capsule and then connect that port both to bp on the \"outside\" and to bp2 on the \"inside\".","title":"ART_0033_connectedNonServicePortOnPart"},{"location":"validation/#art_0034_serviceportwithoutevents","text":"Severity Reason Quick Fix Warning A service port is typed by a protocol that doesn't have any events. N/A A service port is part of the externally visible communication interface for a capsule. Hence the protocol that types a service port should have at least one event, otherwise the service port doesn't add any value. The only exception is a notification port which receives the rtBound and rtUnbound events when the port gets connected or disconnected to another port at runtime. This means that a notification port can be useful even if its protocol doesn't contain any events. protocol EmptyProtocol { }; capsule C34 { service port myPort : EmptyProtocol; // ART_0034 statemachine { state State; initial -> State; }; };","title":"ART_0034_servicePortWithoutEvents"},{"location":"validation/#art_0035_timerserviceport","text":"Severity Reason Quick Fix Warning A timer port is a declared to be a service port. Make Non-Service Behavior Port A timer port is typed by the predefined Timing protocol. It has one event timeout which is sent to the port after a certain timeout period (either once or periodically). Other capsules cannot send the timeout event to the capsule that owns the timer port. Hence a timer port should always be a non-service behavior port. A Quick Fix is available that will remove the service keyword for the port and if necessary also add the behavior keyword. capsule C35 { service port t : Timing; // ART_0035 statemachine { state State; initial -> State; }; };","title":"ART_0035_timerServicePort"},{"location":"validation/#code-generation-validation-rules","text":"Some problems in an Art file cannot be detected until it's translated to C++ code. The code generator implements validation rules for detecting and reporting such problems. Note When an Art file is edited in the UI code generation validation rules run just after the Art validation rules . However, they will only run if there is an active TC, since otherwise code generation will not happen. When you run the Art Compiler and the Art validation rules found at least one problem with Error severity, then code generation will not happen and hence these validation rules will not run. Validation rules that are related to code generation can be enabled and disabled, and have their severity customized, in the same way as the Art validation rules. Code generation validation rules have the prefix \"CPP\" and ids in the range starting from 4000 and above. They are listed below.","title":"Code Generation Validation Rules"},{"location":"validation/#cpp_4000_eventtypewithouttypedescriptor","text":"Severity Reason Quick Fix Warning An event type has a type for which no type descriptor could be found. N/A If an event has a data parameter the type of this parameter must have a type descriptor . Otherwise the TargetRTS doesn't know how to copy or move the data at run-time when the event is sent. The TargetRTS provides type descriptors for most predefined C++ types. For user-defined types the code generator assumes a type descriptor will be available for it (either automatically generated by means of the rt::auto_descriptor attribute, or manually implemented ). It's necessary that such a user-defined type is defined so that it can be referenced from the event with a simple name without use of qualifiers, type modifiers or template arguments. Use a typedef or type alias to give a simple name to an existing type that for example is defined in a different namespace. If the code generator doesn't find a type descriptor for the event parameter type, CPP_4000 will be reported, and the C++ function that is generated for the event will have void type (i.e. the same as if the event doesn't have a data parameter). protocol PROT { out e1(`MyClass*`); // ART_4000 (type modifier present) out e2(`std::string`); // ART_4000 (qualified name) out e3(`TplClass<int>`); // ART_4000 (template parameter present) };","title":"CPP_4000_eventTypeWithoutTypeDescriptor"},{"location":"validation/#cpp_4001_unreachabletransition","text":"Severity Reason Quick Fix Warning One or many transitions are unreachable due to ambiguous triggers. N/A If there are multiple outgoing transitions from a state with identical triggers (i.e. having the same port and the same event, and no guard condition), then it's ambiguous which one of them that will be triggered. In this situation the code generator will pick one of them to execute, and report the other ones as unreachable. The unreachable transitions will be reported as related elements so you can navigate to them and decide how to resolve the ambiguity. Common solutions for this problem is to add a guard condition, either on the trigger or the transition. With a guard condition the ambiguity is resolved, but it's of course then important to ensure that guard conditions are mutually exclusive so that only one of the transitions can execute. The code generator cannot ensure this, since guard conditions are evaluated at run-time. capsule XCap { behavior port t : Timing; statemachine { state State1, State2; initial -> State1 ` t.informIn(RTTimespec(1,0)); `; t1: State1 -> State2 on t.timeout; t2: State1 -> State2 on t.timeout; // CPP_4002 }; }; Code for calling unreachable transitions will still be generated, but preceeded with a comment. Here is an example: case Timing::Base::rti_timeout: chain2_t1( ); return ; // WARNING: unreachable code; chain3_t2( ); return ;","title":"CPP_4001_unreachableTransition"},{"location":"validation/#cpp_4002_guardedinitialtransition","text":"Severity Reason Quick Fix Error The initial transition leads to a junction where all outgoing transitions have guard conditions. N/A The initial transition is the first transition that executes in a state machine. It must always lead to the activation of a state where the state machine will stay until it receives its first event. It is allowed to use junctions in the initial transition to let guard conditions decide which state that should be activated. However, in this case it's required that there is at least one junction transition without a guard condition (or with an else guard). If all transition paths are guarded there is a risk that none of the guard conditions will be fulfilled, which would mean that no state will be activated. That would effectively break the functioning of the state machine. capsule N { statemachine { state State; junction j; initial -> j; j -> State when `x == 5`; // CPP_4002 }; };","title":"CPP_4002_guardedInitialTransition"},{"location":"validation/#tc-validation-rules","text":"TC files are validated to detect problems related to TC properties. The rules that perform this validation can be enabled and disabled, and have their severity customized, in the same way as the Art validation rules . They use the prefix \"TC\" and ids in the range starting from 7000 and above. These rules are listed below.","title":"TC Validation Rules"},{"location":"validation/#tc_7000_wrongvaluetype","text":"Severity Reason Quick Fix Error A TC property has the wrong type of value. N/A Each TC property has a type as shown in this table . The value provided for a TC property must have the expected type. Here are some examples where TC property values have types that don't match the types of these TC properties: tc.copyrightText = true; // TC_7000 (expects a string, and not a boolean) tc.cppCodeStandard = 98; // TC_7000 (expects an enum string such as \"C++ 98\", and not a number) tc.sources = ''; // TC_7000 (expects a list of strings, and not a single string)","title":"TC_7000_wrongValueType"},{"location":"validation/#tc_7001_tcpropertynotyetsupported","text":"Severity Reason Quick Fix Warning A TC property is assigned a value, but Code RealTime does not yet support this property. N/A TC files are not only used by Code RealTime but also by Model RealTime. Even if the format of TC files is the same in these products, there are certain TC properties which are supported by Model RealTime, but not yet supported by Code RealTime. You can still assign values to such properties but they will be ignored. tc.compilationMakeInsert = ''; // TC_7001","title":"TC_7001_tcPropertyNotYetSupported"},{"location":"validation/#tc_7002_propertynotapplicableforlibrarytc","text":"Severity Reason Quick Fix Warning A TC property that is only applicable for an executable TC is used in a library TC. N/A Certain TC properties are only meaningful if used in a TC that builds a library. For example, setting linkCommand does not make sense on a library TC since a library is not linked. let tc = TCF.define(TCF.CPP_TRANSFORM); // The \"topCapsule\" property is not set, which means this is a library TC tc.linkCommand = 'ld'; // TC_7002","title":"TC_7002_propertyNotApplicableForLibraryTC"},{"location":"validation/#tc_7003_prerequisitepatherror","text":"Severity Reason Quick Fix Error A prerequisite TC cannot be resolved. N/A TCs that are specified as prerequisites must exist. If the path cannot be resolved to a valid TC file then it must either be corrected or deleted. A relative path is resolved against the location of the TC where the prerequisites property is set. tc.prerequisites = [\"../../TestUtils/testlibX.tcjs\"]; // TC_7003 (referenced TC file does not exist)","title":"TC_7003_prerequisitePathError"},{"location":"validation/#tc_7004_invalidtopcapsule","text":"Severity Reason Quick Fix Error The specified top capsule cannot be found. N/A The topCapsule property is mandatory for executable TCs. In fact, it's the presence of this property that makes it an executable TC. A capsule with the specified name must exist in one of the Art files that is built by the TC (directly or indirectly). If you specify a top capsule that cannot be found, make sure you have spelled it correctly (use Content Assist in the TC editor so you can avoid typos). Also make sure that the Art file where the top capsule is defined is not excluded from the build by use of the sources property. tc.topCapsule = 'NonExistentCapsule'; // TC_7004 (referenced top capsule does not exist)","title":"TC_7004_invalidTopCapsule"},{"location":"validation/#tc_7005_invalidunitname","text":"Severity Reason Quick Fix Error The unitName property contains characters that are illegal in a file name. N/A The unitName property specifies the name of the generated unit files (by default called UnitName.h and UnitName.cpp ). Hence, it cannot contain characters that are not allowed in a file name. Different operating systems have different rules that a valid file name must adhere to. tc.unitName = 'UnitName:1'; // TC_7005 (colon is not a valid file name character on Windows)","title":"TC_7005_invalidUnitName"},{"location":"validation/#tc_7006_invalidtargetrtslocation","text":"Severity Reason Quick Fix Error The specified path to the TargetRTS does not exist or is invalid. N/A The targetRTSLocation property must specify a folder that exists and contains a TargetRTS to compile generated code against. tc.targetRTSLocation = \"C:\\\\MyTargets\\\\\"; // TC_7006 (if that folder does not exist)","title":"TC_7006_invalidTargetRTSLocation"},{"location":"validation/#tc_7007_invalidtargetconfig","text":"Severity Reason Quick Fix Error The specified target configuration does not exist. N/A The targetConfiguration property must specify the name of a target configuration that exists in the folder specified by the targetRTSLocation property. If you specify a target configuration that cannot be found, make sure you have spelled it correctly (use Content Assist in the TC editor so you can avoid typos). tc.targetConfiguration = \"WinT.x64-MinGW-12.2.0\"; // TC_7007 (misspelled \"MinGw\")","title":"TC_7007_invalidTargetConfig"},{"location":"validation/#tc_7008_invalidcodestandard","text":"Severity Reason Quick Fix Error The specified C++ code standard does not exist. N/A The cppCodeStandard property must specify a valid C++ code standard. If you specify a code standard that cannot be found, make sure you have spelled it correctly (use Content Assist in the TC editor so you can avoid typos). tc.cppCodeStandard = \"C++ 18\"; // TC_7008 (there is no C++ language standard C++ 18)","title":"TC_7008_invalidCodeStandard"},{"location":"validation/#tc_7009_invalidtargetfolder","text":"Severity Reason Quick Fix Error The specified target folder is invalid. N/A The targetFolder property specifies the folder where to place generated files. The folder doesn't have to exist, since it will be created automatically by the code generator if needed. However, it's required that the folder has a name that is valid. Different operating systems have different rules that a valid folder name must adhere to. tc.targetFolder = 'capsule_cpp_inheritance_target:'; // TC_7009 (invalid character ':' in target folder)","title":"TC_7009_invalidTargetFolder"},{"location":"validation/#tc_7010_physicalthreadwithoutlogicalthread","text":"Severity Reason Quick Fix Warning A physical thread has no logical thread mapped to it. N/A A physical thread is referenced through a logical thread that is mapped to it in the TC. Multiple logical threads can be mapped to the same physical thread, but if a physical thread has no logical threads mapped to it, it's useless since it then cannot be referenced by the application. Note that this rule does not apply for the default MainThread and TimerThread. Solve this problem either by deleting the Thread object that represents the physical thread from the TC, or map a logical thread to it using the logical property. See the threads property for more information. tc.threads = [ { name: 'MyThread', logical: [ ] // TC_7010 } ];","title":"TC_7010_physicalThreadWithoutLogicalThread"},{"location":"validation/#tc_7011_duplicatephysicalthreadname","text":"Severity Reason Quick Fix Error There are multiple physical threads with the same name. N/A The names of physical threads in an application must be unique. See the threads property for more information. tc.threads = [ { name: 'MyThread', logical: [ 'L1' ] }, { name: 'MyThread', // TC_7011 (MyThread already defined) logical: [ 'L2' ] } ];","title":"TC_7011_duplicatePhysicalThreadName"},{"location":"validation/#tc_7012_duplicatelogicalthreadname","text":"Severity Reason Quick Fix Error There are multiple logical threads with the same name. N/A The names of logical threads in an application must be unique. In a library TC the logical threads are specified as a list of strings in the threads property and this list should not contain duplicates. In an executable TC the logical threads are instead defined implicitly when mapping them to physical threads using the logical property on the Thread object. Also in this case, the same logical thread name should not be used more than once. tc.threads = [ { name: 'MyThread', logical: [ 'L1', 'L1', 'L2' ] // TC_7012 (L1 defined (and mapped to MyThread) twice) }, { name: 'MyThread2', logical: [ 'L2' ] // TC_7012 (L2 already mapped to MyThread above) } ]; A special situation is when an executable TC has several library TCs as prerequisites (direcly or indirectly). These library TCs may define logical threads with clashing names. You must make sure that names of logical threads in all prerequisite libraries are unique. One way to accomplish this could be to prefix a logical thread in a library with the name of the library.","title":"TC_7012_duplicateLogicalThreadName"},{"location":"validation/#tc_7013_physicalthreadsinlibrary","text":"Severity Reason Quick Fix Warning Physical threads are defined in a library TC. N/A In a library TC you should only define logical threads. These must be mapped to physical threads in the executable TC which has the library TC as a prerequisite. If you anyway define physical threads in a library TC, they will be ignored. See the threads property for more information. // tc.topCapsule not defined, i.e. this is a library TC tc.threads = [ // TC_7013 { name: 'MyThread', logical: [ 'L1' ] } ];","title":"TC_7013_physicalThreadsInLibrary"},{"location":"validation/#tc_7014_incorrectthreadproperty","text":"Severity Reason Quick Fix Error A thread property is incorrectly specified. N/A This problem is reported if the threads property contains a value of unexpected type. For an executable TC this property should be set to a list of Thread objects representing physical threads, while for a library TC it should be set to a list of strings which are the names of the logical threads defined in the library. The problem is also reported if a Thread object for a physical thread has a property of unexpected type. All properties of such a Thread object should be of string type, except logical which should be a list of strings. tc.threads = [ { name: 'MyThread', priority: 20000, // TC_7014 (the priority should be specified as a string and not a number) logical: [ 'L1' ] } ];","title":"TC_7014_incorrectThreadProperty"},{"location":"validation/#tc_7015_librarythreadnotmappedtophysicalthread","text":"Severity Reason Quick Fix Error A logical thread in a library TC is not mapped to a physical thread. N/A A library TC uses the threads property for specifying logical threads. When an executable TC uses a library TC as its prerequisite, all logical threads of the library must be mapped to physical threads. Read more about library threads here . // In a library TC lic.tcjs: tc.threads = [ 'LibThread1', 'LibThread2' ]; // In an executable TC exe.tcjs: tc.prerequisites = [\"lib.tcjs\"]; tc.threads = [ { name: 'MyThread', logical: [ 'LibThread1' ] // TC_7015 (library logical thread 'LibThread2' not mapped) } ];","title":"TC_7015_libraryThreadNotMappedToPhysicalThread"},{"location":"validation/#core-validation-rules","text":"There are certain core rules that run before the semantic validation rules mentioned above. They are responsible for making sure that the Art file is syntactically correct and that all references it contains can be successfully bound to valid Art elements. Since these rules run before semantic validation rules they cannot be disabled or have their severity changed. Core validation rules have ids in the range starting from 9000 and above and are listed below.","title":"Core Validation Rules"},{"location":"validation/#art_9000_syntaxerror","text":"Severity Reason Quick Fix Error Parsing of the Art file failed due to a syntax error. Remove Extraneous Input If an Art file contains a syntax error, it cannot be parsed into valid Art elements and the parser will then report this error. There are many ways to introduce syntax errors in an Art file and the error message from the parser will usually help you understand what is wrong by telling you both what incorrect thing was encountered and what is instead expected at that position. If the syntax error is caused by extra characters at a place where no extra characters are expected a Quick Fix can be used for removing the \"extraneous input\". capsule A { state machine // ART_9000 (mismatched input 'state' expecting 'statemachine') }; capsule B { statemachine { state State; initial -> State; }; prt // ART_9000 (extraneous input 'prt' expecting '}') };","title":"ART_9000_syntaxError"},{"location":"validation/#art_9001_unresolvedreference","text":"Severity Reason Quick Fix Error A referenced Art element cannot be found. N/A For an Art file to be well-formed, all references it contains must be possible to resolve to valid Art elements (located either in the same Art file, or in another Art file in the workspace). Aside from simple spelling mistakes, the most common reason for this error is that you forgot to add the folder that contains the Art file with the target Art element into the workspace. Also note that if the referenced Art element is in a different workspace folder you must have an active TC which specifies a TC in that workspace folder as a prerequisite. capsule C { port p : Unknown; // ART_9001 (Couldn't resolve reference to Protocol 'Unknown'.) statemachine { state State; initial -> State; }; };","title":"ART_9001_unresolvedReference"},{"location":"validation/#internal-errors","text":"A special validation rule is used for detecting and reporting so called internal errors. These are errors that should never occur, but if they still do they are caused by a defect in Code RealTime. If you encounter an internal error please report it as described here .","title":"Internal Errors"},{"location":"validation/#art_9999_internalerror","text":"Severity Reason Quick Fix Error An internal error has occurred. N/A Internal errors may arise from bugs and often result from unexpected situations. While it may be possible to workaround an internal error, the problem can only be fully solved by updating Code RealTime. Therefore, the first thing you should do if you get an internal error is to make sure you are running the latest version of Code RealTime (see Releases ). If you don't, then please uplift to the latest version as there is a chance the problem has been fixed in that version. If that doesn't help, please report the internal error as described here .","title":"ART_9999_internalError"},{"location":"art-lang/","text":"Art is a language for developing stateful and event-driven realtime applications. By stateful we mean that the application consists of objects whose behavior can be described with state machines. By event-driven we mean that these objects communicate with each other by sending events, which can cause their state machines to transition from one state to another when received. The Art language provides high-level concepts not directly found in the C++ language. All these high-level concepts are transformed into C++ code by the Art compiler . Generated code uses a run-time library known as the TargetRTS ( Target RunTime System ). The TargetRTS is a C++ library that acts as a layer between the generated code and the underlying platform (hardware, operating system etc) on which the realtime application runs. Art is well suited for describing both the behavior and structure of a realtime application, but it uses C++ as expression and action language. C++ is also used for declaring types, variables, functions etc. As a rule of thumb, Art uses C++ for everything where C++ is a good fit, and only provides new language concepts where no appropriate constructs exist in C++. This means that if you already know C++, you can quickly learn Art too, and existing C++ code you have already written can be used in your Art application. Note that the translation of Art to C++ also involves analysis of the C++ code that is present in the Art files. The code generator supports certain C++ extensions in such embedded C++ code and will \"expand\" them to C++ code as part of code generation for an Art file. Concepts and Terminology In Art the concept of a capsule is central. A capsule is like a C++ class, but with a few differences and extensions. A C++ class is passive in the sense that a caller can access its public member functions and variables at any time. Hence a C++ object always executes in the context of the caller, and when a member function is called, the caller is blocked until the function call returns. A capsule, however, is active and has its own execution context. This means that we never call a capsule member function or access a capsule member variable from outside the capsule itself. Instead we communicate with the capsule by sending events to it. Each capsule instance has a queue of events it has received and those events will be dispatched to the capsule instance one by one. The sender of the event is not blocked, as the event will be handled by the capsule instance asynchronously when it is later dispatched. The picture below shows 3 capsule instances each holding a queue with events that have been received, but not yet dispatched. Note that this picture is conceptual. In a real implementation several performance optimizations are applied, for example it's common to let a single thread drive more than one capsule instance, and several capsule instances can share a common event queue. But from a conceptual point of view each capsule instance has its own queue of events that are waiting to be dispatched to it. Events have a priority which determines how they are ordered in the queue. Events with high priority are placed before events with lower priority, and if two events have the same priority they are ordered according to when they arrive. A capsule may have ports. A port is typed by a protocol which defines the events that may be sent in to the port (these are known as in-events ), as well as the events the capsule itself may send out through the port for others to receive (these are called out-events ). Ports can be used both for internal and external communication. A port used for external communication is called a service port . Together, the service ports constitute the communication interface of the capsule, and decide what \"services\" the capsule provides for other capsules to use. A simple capsule which only handles a small number of events, may be able to handle all these events using a single state machine. However, when new ports are added (or new events in protocols typing existing ports), the capsule interface grows and the state machine has to grow with it, since there will be more events for it to handle. Eventually a point is reached where it will not be practical for a capsule to handle any more events in its own state machine, because it has grown too large or complex. If not before, this is the time to define a composite structure for the capsule. A composite structure is created by decomposing a capsule using capsule parts. A capsule part (or, for simplicity, just part ) is typed by another capsule and is a way for a capsule to delegate some of its responsibilities to other capsules. Such a decomposition is purely an implementation detail that is not visible from the outside of the capsule. When you send an event to a capsule you cannot know if the capsule will handle the event itself, or if it will forward the event to another capsule typing one of its capsule parts. The ability to decompose a capsule into parts is important for managing complexity. When a capsule has grown too big and complex you can decompose it into capsule parts without changing the communication interface of the capsule. Ports of capsules typing capsule parts are connected to each other by means of connectors. A connector is a conceptual construct for showing how events are routed in the composite structure of a capsule. At run-time connectors don't exist, and ports are directly connected to each other. Because of this, it's not mandatory to use connectors. You can also choose to dynamically connect (and disconnect) ports at run-time. Although this provides for more flexibility, it has the drawback of making it impossible to statically visualize the communication paths of a capsule. Ports that connect statically to other ports via connectors are called wired ports. Ports that are connected dynamically without use of static connectors are called unwired ports. The picture below shows the structure of a capsule Top which consists of two capsule parts ping and pong each holding a capsule instance (a Pinger capsule and a Ponger capsule respectively). The connector between the wired ports p on these capsules makes it possible for these capsules to communicate with each other. Communication can also happen using the unwired ports q1 and q2 if they are connected at run-time. The picture also shows that the capsule Ponger is further decomposed using a capsule part inner . All events sent to port p of Ponger will be further routed to port i of the Internal capsule. Regardless if ports are statically connected by connectors (wired ports), or dynamically connected at run-time (unwired ports), they must be compatible with each other. This means that the out-events of one port must match the in-events of the other port, for the ports to be possible to connect. This constraint ensures that events are never lost when traveling between two connected ports. To make it possible to describe the events that may be sent between two connected ports using a single protocol, one of the ports can be declared as conjugated . For a conjugated port the meaning of in-events and out-events are swapped, so that the in-events are the events that may be sent out through the port, and the out-events are the ports that may be sent to the port. In the picture above port q1 is non-conjugated ( ) while port q2 is conjugated ( ). Both capsule parts and ports may have multiplicity. You can think about a capsule part with multiplicity > 1 as an array that holds capsule instances at run-time. In the same way you can think about a port with multiplicity > 1 as an array that holds connections to port instances at run-time. The multiplicity of ports and parts must match when connecting two ports with each other. Once again, this constraint ensures that events will not be lost when traveling between the connected ports at run-time. The picture below shows a capsule with a part and a port that both have multiplicity > 1. In structure diagrams such parts and ports are shown as \"stacked boxes\". In addition to regular C++ member functions a capsule may have a state machine as its behavior. A state machine describes how an instance of the capsule may move between different states through its life-time. A transition that connects a source state with a target state may be triggered when a received event from a capsule's event queue is dispatched. Several conditions must hold true for the transition to trigger. For example, the event must match a trigger that specifies the expected type of event and the port on which it was received. It's also possible to associate a boolean guard condition with the transition and/or with the trigger which must be true for the transition to trigger. A transition may have an effect , which is a piece of C++ code that executes when the transition gets triggered. The picture below shows a state machine containing a few states and transitions. The presence of transition guard code is shown with a yellow dot and the presence of transition effect code is shown with a blue dot. Both these are C++ code snippets that are embedded in the Art file. When a capsule instance is created (this is sometimes referred to as capsule incarnation ), it's state machine starts to execute by triggering the transition that goes out from the initial state (the circular blue symbol to the left in the above diagram). Each state machine must have exactly one such initial state with an outgoing transition. Since this initial transition is triggered automatically when the capsule instance is created it cannot have constraints such as triggers and guard conditions. The initial transition is an example of a non-triggered transition since it cannot have triggers. The path from the source state to the target state can sometimes consist of more than one transition. In that case only the first of these is a triggered transition that may have triggers that specify when it will trigger. Once the first transition in this path has triggered, subsequent non-triggered transitions will always execute, one by one according to how they are connected in the state machine. However, also non-triggered transitions (with the exception of the initial transition) may have guards. Such guards are usually evaluated before the triggered transition triggers to ensure that they all are enabled, so that it's guaranteed that the target state can be reached. There is one exception to this rule, for transitions that leave a choice . Such guards are only evaluated once the choice has been reached to dynamically decide which outgoing transition to take next. This also means that guards of such transitions must be written so that at least (and at most) one outgoing transition is enabled, or there is a risk that the state machine will get stuck in the choice. In the state machine shown below the transitions t2 and t5 are triggered transitions, while other transitions are non-triggered. Transition t5 can only be triggered if either the guard of t7 or t6 is true, while t2 can be triggered even if neither the guard of t3 nor t4 is true. The target of transition t5 is a junction which is used for either splitting or merging transition paths depending on evaluated guard conditions. A state may be decomposed by a sub state machine. Such a state is called a composite state and a state machine that has composite states is called a hierarchical state machine . Transitions enter a composite state through an entry point and exit it through an exit point . Usually an entry point is connected to a nested state inside the state machine of the composite state, but it can also connect to a deep history . Reaching the deep history of a composite state means that all sub states that were previously active will become active again. Hence, deep history is a way to restore a composite state so all its nested states will be reactivated again recursively. The picture below shows a state machine with a composite state Composite containing two nested states S1 and S2 . When this state machine starts to execute state S1 first becomes active since Composite is entered using the ep1 entry point. Later, when leaving S2 through the ex1 exit point, state X becomes active. Then when leaving X through the transition that connects to the ep2 entry point the state S1 once again becomes active since ep2 is connected to the deep history. Of course, whenever a nested state is active, the enclosing composite state is also active. At any point in time a state machine has an active state configuration , which consists of the set of currently active states. A state may have an entry action and/or exit action which is a C++ code snippet that gets executed whenever the state is entered or exited. Note that state entry actions for nested states also run when those states are entered because of a deep history. In state diagrams the presence of entry and/or exit actions are shown by icons just below the state name. In the state machine shown below state S1 has an entry action, state S2 has an exit action and state S3 has both an entry and an exit action. A transition where the source and target state is the same state is called a self-transition . A special kind of self-transition is an internal transition , which is a transition that when triggered doesn't leave the current state. Hence, when an internal transition is triggered the active state configuration remains unchanged, and neither the entry nor exit action of the state gets executed. In the state machine shown below the state has two self-transitions; t which is a regular self-transition (a.k.a. external self-transition ) and it which is an internal transition. Since a state may have a large number of internal transitions they are not shown inside the state symbol, but if you select the state symbol you can see them in the Properties view. An icon is shown in the upper right corner of states that contain internal transitions. State machines can not only be defined for capsules but also for regular classes. This can be useful if you want a plain passive C++ class to have a state machine. Contrary to a capsule a class may not have ports and doesn't execute in its own context. It's therefore common to associate such a class with a capsule that it can use for sending events through its ports. Transitions of a passive class state machine are triggered by calling trigger operations on the class. Such operations have no code, but just trigger transitions in the class state machine. The realtime application needs to designate one capsule as the top capsule . This is done in the transformation configuration , which is a file containing all the properties used for building the application (e.g. code generator options, compiler settings etc.). There is no language construct in Art for defining a top capsule; any capsule that you define can act as the top capsule. However, in practise you typically decide at an early stage which capsule that will be the top capsule. The top capsule is the entry point of the realtime application. When it starts to execute one instance of the top capsule will be automatically created, and its state machine starts to execute. If you build a library rather than an executable you don't have a top capsule. Embedded C++ Code Art uses C++ as action and expression language. It also uses C++ for defining types, variables and functions. A C++ code snippet can be embedded into an Art file at many places by enclosing it with backticks. Here is an example of how to write the code that should execute when a transition triggers: S1 -> S2 on timer.timeout ` std::cout << \"Hello World!\" << std::endl; `; Here is another example that shows how to include some C++ code as the implementation preface of a capsule: capsule BrewControl { [[rt::impl_preface]] ` #include <iostream> ` }; Code snippets can not only be associated with Art language constructs as in the above two examples, but can also be placed at the Art file level. There are two such file-level code snippets: Declarations (rt::decl) May contain arbitrary C++ declarations. All these code snippets will be generated into a C++ header file with the same name as the Art file. Implementations (rt::impl) May contain arbitrary C++ implementations. All these code snippets will be generated into a C++ implementation file with the same name as the Art file. As an example, assume we have an Art file sample.art with the following contents [[rt::decl]] ` typedef C* Cptr; Cptr func1(); ` [[rt::impl]] ` Cptr func1() { return nullptr; } ` Two C++ files will be generated from this Art file: sample.art.h typedef C* Cptr; Cptr func1(); sample.art.cpp #include \"sample.art.h\" Cptr func1() { return nullptr; } File-level code snippets are useful whenever you need to include some C++ code in your application that doesn't naturally belong to any particular Art element. They can for example be used for declaring and implementing utility functions or types that are needed by many different Art elements. To use the declared elements from an Art element, you need to add an #include for the generated header file using a code snippet on the Art element. Note that an #include is needed even if the Art element is located in the same Art file as the declared elements it wants to use. Below is an example that shows how a protocol and a capsule can use the type Cptr defined in sample.art by adding #include s: protocol MyEvents { [[rt::header_preface]] ` #include \"sample.art.h\" ` out alert(`Cptr`); }; capsule Cx { [[rt::header_preface]] ` #include \"sample.art.h\" ` [[rt::decl]] ` protected: Cptr m_ptr; ` // ... }; Here an rt::header_preface code snippet is used for making the generated capsule and protocol header files include sample.art.h while an rt::decl code snippet is used for declaring a member variable m_ptr for the capsule. See the documentation of the different Art elements below to learn about what code snippets that are available for each kind of Art element. Art Files and Folders and Reference Binding Any but the simplest of applications will consist of multiple Art files organized into folders. You can create as many Art files as you like, and every Art file may contain one or several Art elements. Art files containing Art elements that are related to each other should be grouped in a folder. For example, if you build a library from certain Art elements it makes sense to put the Art files with those elements in their own folder. Folders with Art files should be added as workspace folders, either using the command File - Add Folder to Workspace (to add a folder to an existing workspace), or using the command File - Open Workspace from File (to open an existing workspace from a file that defines the workspace folders). If your application consists of more than a couple of workspace folders use of a workspace file is recommended as it makes it quick and easy to add all workspace folders in one go with a single command. Note Art files must be on the top level in a workspace folder. Do not place them in subfolders. When an Art file contains a reference to an Art element that cannot be found within the same file, other Art files in the workspace will be searched for an Art element with the referenced name. This search starts with the Art files in the same workspace folder. If a matching Art element is found in one of these files, the reference is bound to it. Otherwise an active transformation configuration (TC) is required, which specifies one or several prerequisites. The Art files in the workspace folders where the prerequisite TCs are located will then be searched. The search continues recursively if the prerequisite TC itself has prerequisites. If a matching Art element cannot be found in any of these locations the reference will be unresolved and an error will be reported. For example: Couldn't resolve reference to Protocol 'UnknownPort'. (ART_9001_unresolvedReference) For more information about unresolved references, see this validation rule . Textual and Graphical Notations The Art language is a textual language, but many parts of it also have a graphical notation. For example, a state machine can be shown using a graphical state diagram, and the composite structure of a capsule can be shown in a structure diagram. Relationships between capsules, protocols and classes, such as inheritance, can be shown in class diagrams. Below are examples of these three kinds of diagrams: Diagrams are automatically updated when the corresponding Art file is modified. They use automatic layout to avoid the need for manual tidy-up of diagrams when something changes. This also significantly reduces the need for storing diagram specific properties in the Art files, such as coordinates or symbol dimensions. However, there are some properties used when rendering diagrams that are stored in the Art file. For example, if you assign a custom color to a state symbol it will be stored as a property on the state. capsule Cap { statemachine { state ColorfulState[[rt::properties(color=\"#b40e0e\")]]; }; }; Art elements are mostly edited using their textual notation, but diagrams also provide some editing capabilities. However, all edit commands performed from a diagram are actually mapped to corresponding textual modifications of the Art file. Editing from a diagram is therefore simply an alternative, and sometimes more convenient way, of editing the textual Art file. Syntax Art uses a syntax that should be familiar to developers with knowledge about languages like C++ and Java. Declarations are terminated with a semicolon ; When multiple elements are declared in the same language construct commas , are used for separating the elements Curly brackets {} are used for grouping nested elements Square brackets [] are used for specifying cardinality (i.e. multiplicity) of elements A dot ( . ) is used as scope resolution operator Line // and block /* */ comments may be freely used for commenting Names and Keywords Names of Art elements must be valid C++ identifiers since they will be used as names of C++ definitions in generated code. Names also must not clash with names used in the TargetRTS. Don't worry - the Art language editor will let you know if you choose a name that won't work. Just like any language, Art has certain keywords that are reserved and which cannot be used as names. These keywords are listed below: Art keywords behavior capsule choice class connect entry entrypoint exclude exit exitpoint fixed history in initial junction notify on optional out part plugin port protocol publish redefine service state statemachine subscribe template trigger typename unwired when with Art is a case-sensitive language and names may use any capitalization. However, just like with most languages, there are conventions for how to capitalize names. Those conventions are described below where each Art language construct is described in detail. Comments The same kinds of comments as in C++ can be used, i.e. line and block comments. // line comment /* block comment */ /* multi-line block comment */ Capsule A capsule defines an active class with its own execution context. It may have ports through which it can receive events . A capsule has a state machine that describes how instances of the capsule transitions between different states in the response to received events. Names of capsules are typically nouns, often describing something that performs some form of activity. For example \"Controller\", \"TrafficLight\" or \"FaultHandler\". By convention names of capsules start with uppercase. Embedded C++ code can be used for declaring member variables, member functions, nested types etc for the capsule. Here is an example of a capsule with a simple state machine and a member variable. capsule Elevator { [[rt::decl]] ` unsigned int currentLevel = 0; ` statemachine { state Waiting; initial -> Waiting; }; }; Note Capsule member variables and member functions may be private or protected, but should usually not be public. To avoid threading issues all communication with a capsule should be done using events, and therefore public members are not recommended. An exception is capsule constructors which need to be accessible from other capsules that create instances of the capsule using a capsule factory. If you anyway let a capsule have public members you need to ensure they are only accessed from the same thread that runs the capsule. The example above uses an rt::decl code snippet for declaring a capsule member variable. It will have the default visibility which is private. Here is the list of all code snippets that can be used for a capsule: Code snippet C++ mapping Example of use rt::header_preface Inserted at the top of the capsule class header file Adding #includes needed by the capsule declaration rt::header_ending Inserted at the bottom of the capsule class header file Declaring a type alias for the capsule class rt::impl_preface Inserted at the top of the capsule class implementation file Adding #includes needed by the capsule implementation rt::impl_ending Inserted at the bottom of the capsule class implementation file Undefining a macro only used in a capsule implementation rt::decl Inserted into the capsule class header file (inside the class) Declaring a capsule member variable or function rt::impl Inserted into the capsule class implementation file Implementing a capsule member function Capsule Constructor Just like a regular class a capsule may have constructors. A capsule constructor is declared using an rt::decl code snippet and defined using an rt::impl code snippet. All capsule constructors have two mandatory parameters: rtg_rts This is the controller ( RTController* ) which will execute an instance of the capsule. It corresponds to the thread that runs the capsule instance. rtg_ref This is the part ( RTActorRef* ) into which the capsule instance will be inserted. Every capsule instance, except the top capsule, resides in exactly one part. After these parameters you can add your own parameters, to pass arbitrary initialization data to the capsule instance. Below is an example where a capsule MyCap has a reference variable m_c . To initialize this variable a capsule constructor is used. capsule MyCap { [[rt::decl]] ` public: MyCap_Actor(RTController*, RTActorRef*, MyClass&); private: MyClass& m_c; ` [[rt::impl]] ` MyCap_Actor::MyCap_Actor(RTController* rtg_rts, RTActorRef* rtg_ref, MyClass& c) :RTActor(rtg_rts, rtg_ref), m_c(c) { } ` }; When you create an instance of the capsule you have to provide arguments that match the parameters of one of its capsule constructors. For this you need to use a capsule factory . You can either specify such a capsule factory statically on a part that is typed by the capsule (see Part with Capsule Factory ), or you can provide a capsule factory dynamically when calling incarnateCustom() on a Frame port to incarnate an optional capsule part. Here is C++ code for doing the latter (assuming the optional part is called thePart ): RTActorId id = frame.incarnateCustom(thePart, RTActorFactory([this](RTController * c, RTActorRef * a, int index) { return new MyCap_Actor(c, a, getMyClass()); // Use capsule constructor })); if (!id.isValid()) { // Failed to incarnate thePart } Note the following: In C++ the capsule class has the \"_Actor\" suffix. A capsule constructor must call the RTActor constructor in its initializer. Code that calls the capsule constructor must include the header file where the capsule is located. Example You can find a sample application that uses a capsule constructor here . Capsule Destructor The destructor of a capsule frees the memory used for representing its states, ports etc. You cannot provide your own code to the destructor implementation. However, the RTActor class, which is the base class of every capsule class, provides a virtual function _predestroy() which you can override in your capsule. This function gets called just before the capsule instance is destroyed and is the place where you should put code that cleans up resources allocated by the capsule. Here is an example: capsule C { [[rt::decl]] ` public: virtual void _predestroy() override { // Clean-up and free allocated resources here SUPER::_predestroy(); } ` // ... }; It's important to remember to invoke the inherited function by calling SUPER::_predestroy() . Example You can find a sample application with a capsule that overrides _predestroy() here . Protocol and Event A protocol defines events that may be sent in to a port (so called in-events) and events that may be sent out from the same port (so called out-events). By grouping events into protocols, and then typing ports with such protocols, we can precisely define which events the capsule may send and receive through that port. By convention names of protocols start with uppercase, while names of events start with lowercase and use camelCase if the name consists of multiple words. A protocol event may have a parameter, which enables it to carry data. You declare a parameter for an event by specifying the C++ type of the data to be carried by the event. Note An event can have at most one parameter. If you need to send multiple data objects with an event you can declare an event parameter of struct or class type. The following code snippets can be used for a protocol: Code snippet C++ mapping Example of use rt::header_preface Inserted at the top of the protocol class header file Adding #includes of header files defining types used as event parameter types rt::header_ending Inserted at the end (or near the end) of the protocol class header file Undefining a local macro that was defined in rt::header_preface Here is an example of a protocol that defines some in-events and some out-events: protocol MachineEvents { in start(); in startDeferred(`unsigned long` /* milliseconds */); out success(); out error(`std::string` /* error message */); in relayEvent(); out relayEvent(); }; The event relayEvent above is both an in-event and an out-event. Such symmetric events are useful in protocols typing ports that may receive and send the same events (for example a port that just forwards received events to another port). By convention a symmetric event is declared on a single line. At run-time we often talk about a message rather than an event. A message is an instance of an event, similar to how a capsule instance is an instance of a capsule. In other words, a message is a run-time concept while an event is a design-time concept. Port A port defines a named point of communication for a capsule. A port is typed by a protocol which defines the events that may be sent in to (in-events) and out from (out-events) the port. A port may be conjugated in order to swap the meaning of in-events and out-events. That is, a capsule may send out-events on its non-conjugated ports, but in-events on its conjugated ports. A port becomes conjugated if you add a tilde (~) after its name. Ports are often named to describe the role or purpose of the communication that takes place on them. By convention names of ports start with lowercase and use camelCase if the name consists of multiple words. Here is an example of a capsule with a few ports. Note that Code RealTime provides several predefined protocols that can be used right away, for example Timing . Also note that you can declare multiple ports on a single line if the ports are of the same kind ( p1 and p2 below are both service ports). capsule Machine { service port control : MachineEvents; behavior port timer : Timing; // predefined Timing protocol service behavior port control2 : CtrlEvents; service port p1~ : MoreEvents, p2~ : OtherEvents; // ... }; Service ports constitute the externally visible communication interface for a capsule, and together they define which events can be sent to the capsule, and which events the capsule can send out for other capsules to receive. In a structure diagram the service ports are shown on the border of a capsule or part symbol. A behavior port is logically connected to the behavior (i.e. state machine ) of a capsule. This means that an event that a capsule receives on a behavior port will be handled by the state machine of that capsule. A non-behavior port, however, will simply route an event to another port to which it is connected. Every event that is sent will ultimately reach a behavior port (provided ports are properly connected), and the state machine of the capsule owning that behavior port will handle the event. In a structure diagram, behavior ports are connected to a small ellipse which represents the capsule state machine. Note that ports can also be shown in a class diagram. When a capsule wants to send an event to another capsule it calls a function on the port. There is one such function for each out-event (or in-event if the port is conjugated). These functions return an object on which a send() function can be called. Note that the sending capsule doesn't need to know which capsule that will receive and handle the sent event. Here is C++ code for sending events on ports with and without data: pongPort.pong().send(); // Send event \"pong\" without data on the \"pongPort\" pingPort.ping(5).send(); // Send event \"ping\" with data (an integer) on the \"pingPort\" Example You can find a sample application that sends events on ports with and without data here . Note that send() is not the only function you can call. For example, you can call invoke() if you want to wait until the receiver has received and replied to the event. This is useful for implementing synchronous communication between capsules. Port Multiplicity At run-time an instance of a port can be connected to a port instance on another capsule. Such connections is what make a sent event be routed from the port on which it is sent, through a number of non-behavior ports, until it finally reaches a behavior port. By default a port has single multiplicity (1) meaning that at most one such connection can be established. However, you can specify a non-single multiplicity for a port to allow for more connections to be created at run-time. In the example below a Server capsule has a port with multiplicity 100. At run-time an instance of that Server capsule can be connected to 100 different client ports, each of which can send events to the server. capsule Server { service port clients : ComEvents[100]; // ... }; In a structure diagram a port is shown as \"stacked\" if it has non-single multiplicity. You can also use a C++ expression to specify the port multiplicity. This can for example be useful if the multiplicity is defined in C++ as a macro, a template parameter or a constexpr. For example: capsule Server { service port clients : ComEvents[`NBR_CLIENTS`]; // ... }; Notification Port Every protocol contains two implicit events rtBound and rtUnbound . A port can choose to receive those events whenever a connection for the port is established (rtBound) or dropped (rtUnbound) at run-time. Declare a port as a notification port to receive these events. capsule Server { service notify port clients : ComEvents[100]; // ... }; Port notifications are useful in dynamic systems when capsules need to wait until other capsules are ready, before they can start to communicate with those capsules. For example, a client may need to wait until a server is ready before it sends a request to that server. In the same way it's often useful to get notified when a connection is dropped, since that means communication on that port should no longer take place. Unwired Port Ports are by default wired, meaning that they should be connected with connectors to specify statically how events will be routed. Having a static connector structure defined has the benefit that it becomes possible to look at a capsule's structure diagram to see how events received by the capsule will be routed at run-time. However, in some dynamic systems it's not possible to describe this statically. Ports may be connected and disconnected dynamically and the run-time connections between port instances may hence vary over time. If you need this flexibility you can declare ports as unwired. Here is an example of an application where a client capsule can connect to different kinds of server capsules. Sometimes it may be connected to server1 and sometimes to server2 . It is therefore not possible to describe the connections of Top statically using connectors, and we can instead declare the ports as unwired. capsule Top { part client : Client; part server1 : Server; part server2 : Server; // ... }; capsule Client { service behavior unwired port p : Protocol; // ... }; capsule Server { service behavior unwired port p~ : Protocol; // ... }; Note Only use unwired ports when required. It's strongly recommended to use wired ports whenever possible to enable the visualization of the connector structure in a structure diagram. When unwired ports are required you should write a comment that describes how they will be connected at run-time, since this often cannot easily be concluded by looking at the C++ code of the capsule. An unwired port is always a behavior port. In a structure diagram an unwired port is drawn with a hollow ellipse, while a wired behavior port is drawn with a filled ellipse. In the structure diagram below port q is wired while port p is unwired. An unwired port is either a service access point (SAP) or a service provision point (SPP) depending on the role it plays in a dynamic connection with another unwired port. The capsule that owns the SAP port uses it to subscribe to a service that is published by another capsule by means of an SPP port. The capsule with the SAP port is often called \"client\" or \"subscriber\" while the capsule with the SPP port is often called \"server\" or \"publisher\". Unwired ports get connected by means of registering them under a service name that should be unique in the application. Registration of unwired ports can either happen automatically when the container capsule instance is created, or programmatically at a later point in time. It's also possible to deregister unwired ports in order to disconnect them. You can specify how an unwired port should be registered by means of the following properties: registration specifies when an unwired port should be registered registration_name specifies the service name with which the port should be registered If you choose to register an unwired port programmatically (using the TargetRTS functions registerSPP() and registerSAP() ) you decide at registration time whether the port should be an SAP or SPP port. However, if you choose to instead let the port be registered automatically you need to declare the port as either a subscribe (SAP) or publish (SPP) port. Here is the same example again, but now with automatic registration of the unwired ports using the service name myService : capsule Client { subscribe behavior port sap [[rt::properties( registration_name = \"myService\") ]] : Protocol; // ... }; capsule Server { publish behavior port spp~ [[rt::properties( registration_name = \"myService\") ]] : Protocol; // ... }; Note that the keyword unwired can be implicit when you declare a port as either a subscribe or publish port. Example You can find a sample application that uses an unwired port here . Connector Connectors describe how events are routed within a capsule by connecting ports in its composite structure. They make it possible to see in a structure diagram which parts of a capsule that can communicate with each other. Each connector connects exactly two ports with each other. A connected port may either be a port of the capsule itself, or a port of a capsule that types one of its capsule parts. A few constraints decide if it's possible to connect two ports: 1) The ports must be wired. Unwired ports cannot be connected. 2) The ports must be typed by the same protocol. 3) The ports' conjugations must match. If the ports are at the same level in the capsule's structure (e.g. both ports belong to capsules typing capsule parts owned by the same capsule), then the connected ports must have the opposite conjugation. This is because events that are sent out from one of the ports must be able to be received by the other port and vice versa. However, if the ports are at different levels in the capsule's structure (e.g. one of them belongs to a capsule typing a capsule part owned by the capsule and the other belongs to the capsule itself), then the ports must have the same conjugation. This is because in this case events are simply delegated from one capsule to another. 4) If a connector is connected to a port and a part (where the port is defined on the capsule that types the part), then the port must be a service port. Only service ports are visible from the outside of a capsule. The example below shows the structure diagram of a capsule Top where we can see two connectors. capsule Top { part ping : Pinger, pong : Ponger; connect ping.p1 with pong.p2; // ... }; capsule Internal { service behavior port i~ : PROTO; // ... }; capsule Pinger { service behavior port p1 : PROTO; // ... }; capsule Ponger { service behavior port p2~ : PROTO; part inner : Internal; connect p2 with inner.i; // ... }; The connector between p1 and p2 goes between two ports on the same level which is why these ports must have opposite conjugation. The connector between p2 and i goes between two ports at different levels which is why these ports must have the same conjugation. The non-behavior port p2 is a so called relay port (it just relays all events it receives to another port) and the connector between p2 and i is sometimes called a delegation connector to describe the fact that capsule Ponger uses it for delegating some of its responsiblities to the capsule Internal . Note that relay ports can be optimized away so they don't exist at run-time (i.e. at run-time port p1 can be directly connected to i ). A connector doesn't have a direction, so it doesn't matter in which order it connects the two ports. That is, connecting X with Y is equivalent to connecting Y with X. Local Binding A connector can connect two behavior ports on the same capsule (with opposite conjugations). At run-time this will lead to a local binding between these ports. This enables the capsule to send events to itself which sometimes can be useful. Here is an example: capsule Top { behavior port pOut : TheProtocol; behavior port pIn~ : TheProtocol; connect pOut with pIn; // ... }; One reason for a capsule to send events to itself could be to split a big and long-running task into smaller tasks. By sending an event to itself after completion of each small task, the capsule can remain responsive to other events that may arrive in the meantime. When it receives the event it sent it can proceed with the next part of the big task. Example You can find a sample application that uses a local binding here . Part A capsule can be decomposed by means of parts (also called \"capsule parts\" to emphasize that they are parts of a capsule). A part is a container that at run-time may hold one or many capsule instances. The part has a multiplicity that specifies the maximum number of capsule instances it can contain at run-time, and it has a type which is another capsule. All capsule instances must either be of that specific capsule type, or of a capsule type that inherits from it. It's common to name parts according to the capsule that types them. For example, a part typed by a capsule Controller may be called controller , ctrl or perhaps theController . By convention part names start with lowercase and use camelCase if the name consists of multiple words. There are three kinds of parts which determine how and when they will be populated with capsule instances. 1) Fixed part In a fixed part capsule instances are created automatically when the container capsule is created, and destroyed when the container is destroyed. Fixed parts by default have multiplicity 1. Such a part will always contain one and only one instance of the capsule that types the part. Example You can find a sample application that has a fixed part with a multiplicity here . 2) Optional part In an optional part capsule instances don't have a strong lifetime relationship with the container capsule as is the case for fixed parts. The capsule instances can be created programmatically using a Frame port at some point after the container capsule has been created, and they can be destroyed before the container capsule is destroyed. However, at the latest they will be automatically destroyed when the container is destroyed. Optional parts by default have multiplicity 0..1. This means that they may either contain zero or one capsule instance at any point in time. The presence of zero in the multiplicity is what makes the part optional. Here is C++ code for creating a capsule instance in an optional part (also known as incarnating the part) and then immediately destroying it: RTActorId id = frame.incarnate(thePart); if (!id.isValid()) { // Failed to incarnate thePart } frame.destroy(id); It's important to check that incarnation was successful since there are many reasons why it can fail (e.g. too low multiplicity to fit the created capsule instance, not enough memory etc). If the instantiated capsule has a constructor you need to use a capsule factory for providing the constructor arguments (either provided when doing the incarnation as shown here or specified on the part as described here ). Example You can find a sample application that creates and destroys capsule instances in optional parts here . 3) Plugin part A plugin part is similar to an optional part in that it is populated by capsule instances programmatically. However, the capsule instances are not created in the plugin part but instead imported into the plugin part from another part. Typically such a capsule instance is first created into an optional part, and then at some later point in time imported into a plugin part. Later it can be deported (i.e. removed) from the plugin part and perhaps imported into another plugin part. This makes it possible to create very dynamic composite structures where the same capsule instance can play different roles in different parts over time. Moving a capsule instance by deporting it from one plugin part and then importing it in another plugin part is more efficient than destroying the capsule instance in one optional part and then creating another capsule instance in another optional part. Plugin parts are typically used together with unwired ports . In general it's possible to import a capsule instance into more than one plugin part at the same time, but it can only be imported if its ports are not already bound in its current location. Plugin parts by default have multiplicity 0..1. In the example below the capsule C contains a few parts of different kinds and multiplicities. Note that you may declare multiple parts on the same line if they are of the same kind (both c and d below are optional parts). capsule C { part a : D; fixed part b : D[4]; optional part c : D, d : D[0..5]; plugin part e : D; part f : D[`COUNT`]; // ... }; Part a is fixed with multiplicity 1 since neither kind nor multiplicity is specified for it. Part b is also fixed (using the fixed keyword for more clarity) and with multiplicity 4. When an instance of capsule C is created 5 instances of capsule D will be automatically created. One of these instances will be inserted into part a and the others into part b . These instances will remain there until the C capsule instance is destroyed. Part c is optional with multiplicity 0..1. At run-time it can contain at most one instance of capsule D . Part d is also optional but can contain up to 5 instances of D as specified by its multiplicity 0..5. Part e is plugin with the default multiplicity 0..1. At run-time at most one instance of capsule D can be imported into it. That instance must already have been created in another part, for example part c . Part f uses a C++ expression for specifying the multiplicity. This can for example be useful if the multiplicity is defined in C++ as a macro, a template parameter or a constexpr. Parts can be shown in a structure diagram: Parts are shown as \"stacked\" if they have non-single multiplicity (multiplicities specified with a C++ expression are assumed to be non-single). Optional parts are shown with a \"diagonal\" background pattern, while plugin parts are shown with a \"double diagonal\" background pattern. Parts can also be shown in a class diagram: In the above diagram the filled diamonds show that there is a strong life-time relationship between a C instance and the instances of D that are located in the fixed and optional parts a , b , c , d and f , while this is not the case for the instance located in the plugin part e as shown by the hollow diamond. Part with Capsule Factory If the capsule that types a part has a capsule constructor with custom constructor parameters, you can define a capsule factory for the part. Such a capsule factory consists of one or both of the below code snippets that define how an instance of that capsule should be created and destroyed. rt::create Defines how to create an instance of the capsule. For example, which constructor arguments to pass, which thread to use for running the created capsule instance, at which index to insert the capsule instance into the part (in case it has multiplicity > 1) etc. rt::destroy Defines how to destroy an instance of the capsule. By default it's destroyed using the delete operator. Here is an example where a part defines a capsule factory that specifies a create function. The create function gets the mandatory constructor parameters rtg_rts and rtg_ref as arguments, as well as an index argument that specifies the index where the created capsule instance will be inserted. part engine : Engine [[rt::create]] ` return new Engine_Actor(rtg_rts, rtg_ref, true /* custom constructor arg */); `; Note that you may want to create a capsule factory for a part also for other reasons than passing custom constructor parameters. For example, you may want to change the default thread ( RTController* ) that should execute the created capsule instance, or you may want to instantiate an inherited capsule rather than the capsule that types the part. Example You can find a sample application here where a fixed part uses an rt::create code snippet for invoking a custom capsule constructor. State Machine State machines are used for specifying the behavior of capsules . It is also possible to provide a state machine for a passive class; see Class with State Machine for more information about that. In this chapter we focus on state machines in capsules. A state machine consists of states and transitions. During its lifetime a capsule instance transitions between the various states of its state machine, as a consequence of receiving events on its behavior ports. When transitioning between two states one or several code snippets may execute. Such code may for example send events to other capsule instances, something that may cause transitions to execute in their state machines. A state machine may also have pseudo states , which just like states may be connected with transitions, but that unlike states are not places where the state machine should stay for some time. For example, most pseudo states like junctions and entry/exit points merely act as connection points that make it possible to execute more than one transition when transitioning between two states. The notable exception is the choice in which actually the state machine may get stuck for ever, but that would be an error situation that should not happen in a correctly designed state machine. State The states of a state machine are the places where the state machine may stay for some time while waiting for a message to arrive that potentially can cause the state machine to transition to another state. States should have names that describe what is happening while the state machine stays there, or what has happened for the state machine to arrive there. For example, \"WaitForInit\", \"Processing\" or \"Terminated\". By convention state names start with uppercase. You can declare multiple states on the same line using a comma-separated list of state names. It can be good to write a comment in front of the state name, if you want to elaborate more on its meaning than what is possible in the name itself. Here is an example of a state machine with some states: capsule TrafficLight { statemachine { state WaitUntilServerReady, CycleLight; state /* pedestrians are crossing the street */ PedestriansCrossing; initial -> WaitUntilServerReady; WaitUntilServerReady -> CycleLight; CycleLight -> PedestriansCrossing; }; }; Here is another example where the state machine is shown in a state diagram. A state comment is not visible in a state diagram, but show up in a tooltip when putting the cursor on a reference to the state. They can thereby make it easier to understand a state machine. States may be nested to create a hierarchical state machine . Entry and Exit Action A state may have an entry and/or exit action which is a code snippet that runs whenever the state is entered and/or exited. state Walking { entry ` server.walk().send(); `; exit ` server.stop().send(); `; }; Example You can find a sample application where a state has an entry and exit action here . Transition A transition connects a source state (or pseudo state) to a target state (or pseudo state). When a capsule instance handles a message that was received on one of its behavior ports, one or several transitions may execute. It's not required to give a name to a transition, but it's possible and often makes the state machine easier to understand. At least triggered transitions (i.e. transitions where the source is a state) should have a name. A transition name can be choosen to describe what has happened when the transition executes, for example \"requestReceived\", \"timeout\" etc. By convention transition names start with lowercase and use camelCase if the name consists of multiple words. A triggered transition has one or several triggers which define when the transition can be triggered. Each trigger specifies a port and an event. The trigger can only trigger its transition if the received message is an instance of the specified event, and was received on the specified port. In addition it's possible to provide guard conditions that must be fulfilled for the trigger to trigger its transition. Such a guard condition can be specified for the transition, but also for each individual trigger. Here is an example of a capsule state machine with two triggered transitions requestReceived and timeout . It also contains an initial transition that has no name. capsule MyCap { statemachine { state Waiting, Processing; initial -> Waiting; requestReceived: Waiting -> Processing on com1.request, com2.request when ` return canHandleNow(); ` ` log.log(\"Handling request\"); log.commit(); handle(msg); `; timeout: Waiting -> Waiting on timer.timeout[`zCount < 10`]; }; }; Note the following: Triggers are specified as PORT.EVENT after the keyword on . You may specify multiple triggers separated by comma ( , ). A guard condition for the transition is specified after the when keyword, while a guard condition for an individual trigger is specified in square brackets ( [] ) after the trigger. A guard condition can either be written as a C++ statement that returns the boolean guard condition (as in the guard for transition requestReceived in the above example), or it can be written as a boolean expression (as in the trigger guard for the timeout trigger in the above example). If the guard condition is simple, as is often the case, using a boolean expression is recommended. However, if needed you can use any number of C++ statements in a guard condition where the last statement should return a boolean expression. For example, you can declare local variables to store partial results when computing the boolean expression. Note Guard conditions should execute fast and have no side-effects. They are called frequently to decide which transition to execute when a message has arrived. Initial Transition Every state machine needs exactly one initial transition. When the state machine starts to run, the first thing that happens is that the initial transition executes and takes the state machine to its first state. Therefore, an initial transition is a non-triggered transition and also cannot have a guard condition. But it can of course have an effect code snippet. The source of the initial transition is the initial pseudo state which is declared using the initial keyword. Just like for any transition it's optional to give a name to the initial transition (in fact it's often left unnamed). For capsule instances that are programmatically created (i.e. located in optional capsule parts) you can provide initialization data at the time of creation in the call to incarnate() on a Frame port. The initialization data can be accessed in the effect code of the initial transition. Here is an example: initial -> WaitForServerInit ` RTpchar str = *((RTpchar*) rtdata); `; Note Any type of data object can be passed as initialization data which means that rtdata is an untyped pointer that has to be casted to the expected type. A more type-safe way of passing initialization data is to define a constructor for a capsule. A capsule constructor can take any number of arguments, while with rtdata only one data object can be passed (even if you of course can group several data objects into a struct or class to circumvent this limitation). With capsule constructors you can pass initialization data also for capsule instances that are located in fixed parts. By default rtdata cannot be modified (it has type const void* ). However, by setting the const_rtdata property to false on the initial transition, you can make it non-const. One reason for doing this could be that the initial transition effect code wants to pass some data back to the code that creates the capsule instance. However, you must be very careful if you do this since this will only work if the creating code runs in the same thread that runs the initial transition. A more legitimate reason could be that you want to move the initialization data into a capsule variable, so you can access it later. Moving data can be more efficient than copying it. [[rt::properties(const_rtdata=false)]] initial -> Waiting ` pC = std::move(*((MyClass*) rtdata)); `; Note that the const_rtdata property can be set on any transition, not just the initial transition. It allows the data received when the transition is triggered to be modified. Example You can find a sample application that has transitions with the property const_rtdata unset here . Internal Transition An internal transition doesn't change the active state and therefore doesn't have a target state. An internal transition is always a triggered transition. You define an internal transition inside the state to which it belongs. Here is an example: state Done { unexpected: on myPort.* ` std::cout << \"Unexpected event received! << std::endl; `; }; Note the usage of an asterisk ( * ) to specify that any event received on myPort will trigger the internal transition when the state machine is in the Done state. Such \"receive-any\" events can of course be used for a trigger of any transition, but can in particular be useful for internal transitions that should handle all messages received on a port that are not handled by other triggered transitions leaving substates of the state. If another event is added to the port's protocol in the future, such a trigger will handle the new event too without a need for being updated. Example You can find a sample application that has an internal transition with a \"receive-any\" event trigger here . Internal transitions are examples of so called self-transitions. To learn about other types of self-transitions see this chapter . Choice and Junction Choices and junctions are pseudo states that make it possible to split transition flows in a state machine. That is, one incoming transition may be split into multiple outgoing transitions. Which of the outgoing transitions that will execute is decided by evaluating their guard conditions. For a junction the guard conditions are evaluated already before leaving the currently active state. Only if there exists a path of transitions where all guards are fulfilled, will the active state be exited and the transitions can execute. Otherwise the state machine stays in its current state and attempts to find another path of transitions to execute. For a choice the guard conditions are evaluated after leaving the current state, when reaching the choice itself. The outgoing transition which has a fulfilled guard will execute next. Note It's important that there always is an outgoing transition for a choice with a fulfilled guard condition. Otherwise the state machine will get stuck in the choice without any chance of getting out of it. The same is true if a junction is used in the initial transition . If such a junction doesn't have an outgoing transition with a fulfilled guard condition then the state machine will stay in the initial state for ever. Choices and junctions must have names, so they can be referenced as the source or target of transitions. You can choose to use a name that gives a hint about what conditions that are checked in the guards of the outgoing transitions. For example, isEnabled for a choice that checks a boolean condition and checkValue when the condition has some other type. If you follow this approach you can then name the outgoing transitions accordingly. For example true and false for a choice that checks a boolean condition. By convention choice and junction names start with lowercase and use camelCase if they consist of multiple words. Sometimes it may be difficult to come up with a good name and in that case you can choose something short and \"technical\" like j1 , check1 etc. Below is an example of a state machine containing a choice and a junction. statemachine { state First, Second, Third; t1: initial -> First; choice isEnabled; junction checkThreshold; switchTurned: First -> isEnabled; true: isEnabled -> Second when ` return isEnabled(); `; false: isEnabled -> Second when ` else `; timeout: First -> checkThreshold; low: checkThreshold -> Third when ` return t < LIMIT1; `; medium: checkThreshold -> Third when ` return t >= LIMIT1 && t < LIMIT2; `; high: checkThreshold -> Third; }; Note the use of the C++ keyword else for defining an else-guard. An else-guard will be fulfilled when no other guard of other outgoing transitions is fulfilled. For choices it's good practise to always have exactly one transition with an else-guard to ensure that at least one guard condition will be fulfilled. Thereby we avoid the risk of the state machine getting stuck in the choice. Else-guards can also be useful for junction transitions, but there they are more optional (except when a junction is used in the initial transition; see the note above). You can also define an else-transition for a choice or junction by simply omitting the guard condition. This is consistent with triggered transitions where the absense of a guard condition is equivalent to a guard condition that always is fulfilled. See the transition high in the above example. Guard conditions should be mutually exclusive so that the order in which they are evaluated doesn't matter. Junctions can also be used for merging multiple incoming transition flows into a single outgoing transition. This can for example be useful if you want to reuse a transition path in the state machine for several triggered transitions. statemachine { state S1, S2; junction j1; initial -> S1; t1: S1 -> j1 on port1.e1 ` // handle e1 `; t2: S1 -> j1 on port2.e2 ` // handle e2 `; t3: S1 -> j1 on port3.e3 ` // handle e3 `; common: j1 -> S2 ` // common code here `; }; Of course, in the above simple example the same code reuse could also be obtained by putting the common code in a capsule member function which is called by each of the incoming transitions. But if the common transition is followed by more non-triggered transitions the above approach is more feasible. When multiple triggered transitions converge into a common transition as in the example above, and the events that trigger those transitions have a data parameter, it's best to access that data in the triggered transitions and not in the common transition. This is especially true if the types of those data parameters are not the same, because in that case the rtdata parameter of the function generated for the common transition will be untyped ( void* ). You can of course still cast it to another type, but that requires that you can know which of the triggered transitions that were triggered. It's therefore better to access the data in the triggered transitions and if necessary store it in a capsule variable which you then can access in the common transition if needed. Example You can find a sample application that demonstrates usage of a choice and junction here . Hierarchical State Machine A state machine is hierarchical if it contains at least one composite state, i.e. a state with a nested state machine. A transition that is triggered in the enclosing state machine (i.e. the state machine that contains the composite state) should enter a composite state by specifying an entry point of the composite state as the target. In the nested state machine another transition can connect that entry point to a state in the nested state machine. A transition in the nested state machine may specify an exit point of the composite state as the target. In the enclosing state machine another transition can connect that exit point to a state in the enclosing state machine. Entry and exit points are pseudo states that need to be named. The names can be chosen to give a hint about when the composite state is entered or exited through them, for example systemStarted or errorDetected . If you want you can prefix the names with ep or ex . It's also common to use short and \"technical\" names like ep1 or ex1 if a more descriptive name doesn't make sense. By convention entry and exit point names start with lowercase and use camelCase if they consist of multiple words. It's also possible to directly enter a composite state without using an entry point. In this case the behavior will depend on whether the composite state is entered for the first time or not. If it is for the first time, the initial transition of the nested state machine will execute after the transition that targets the composite state has executed. Otherwise the composite state will instead be entered using deep history , i.e. by activating the state in the nested state machine that was most recently active (and recursively if that state again is a composite state). Note It's recommended to always enter a composite state using an entry point as the behavior then doesn't depend on if the state was previously entered or not. Below is an example of a hierarchical state machine with a composite state CompositeState that contains a nested state machine. Note that you can declare multiple entry or exit points on the same line. statemachine { initial -> CompositeState.ep1; state CompositeState { state Nested; entrypoint ep1, ep2; exitpoint ex1; initial -> Nested; ep1 -> Nested; Nested -> ex1; ep2 -> history*; }; state Other; CompositeState.ex1 -> Other; Other -> CompositeState.ep2; }; Note that a dot ( . ) is used as scope resolution operator, to make it possible to reference an entry or exit point from the enclosing state machine. Inside the nested state machine the entry and exit points are directly accessible without use of the scope resolution operator (using it there would be an error). It is possible to only connect an entry point on the \"outside\". Entering the state via such an entry point will behave in the same way as entering the composite state without using an entry point (see above). It's therefore not recommended. In the same way it's possible to exit a composite state using an exit point that only is connected on the \"inside\". In this case the composite state is not exited and instead the previously active substate again becomes active (recursively, just like for deep history ). This is also not recommended, unless the transition is a local transition . Example You can find a sample application that contains a composite state with an entry and exit point here . Just like a junction , an entry or exit point can have multiple outgoing transitions. Guards on those transitions decide which of them to execute, and are evaluated before leaving the current state. Therefore, the same recommendations as for guard conditions of junctions apply for entry and exit points. Deep History Every nested state machine has an implicit pseudo state with the name history* (in state diagrams it's shown as H* to save space). It can be used as a target for any transition inside the nested state machine. When it is reached, the state machine will restore the previously active substate. If that state again is a composite state, its previously active substate will also be restored. This goes on recursively for all nested state machines (which is why it's called a deep history). In the example above we can see that the transition from ep2 targets the deep history pseudo state. This means that if the Nested substate is active and then the transition to ex1 gets triggered, the state Other becomes active. If then the transition to ep2 gets triggered the CompositeState will be entered using deep history so that the Nested substate will again become active. Example You can find a sample application that uses the deep history pseudo state here . Local Transition A transition in a nested state machine that connects an entry point and exit point on the same state, and these entry/exit points only are connected on the \"inside\", is a local transition . A local transition is a self-transition that behaves something in between an internal transition and a regular (a.k.a. external) self-transition. An internal transition defined on a composite state handles a message without exiting neither that composite state, nor any of its substates. However, a local transition will exit the substates, run the effect code, and then enter the substates again. But the composite state itself will not be exited and entered. An external self-transition on the other hand will exit both the composite state and all active substates recursively, run the effect code, and then enter these states again. Both for local and external self-transitions exiting of states happens bottom-up which means that the deepest nested substate will first be exited, then its parent state, and so on. Entering happens in the opposite order, i.e. in a top-down fashion. Let's look at an example to understand the difference between these three kinds of self-transitions: statemachine { initial -> SelfTransitionExample; state SelfTransitionExample { state Nested1 { state Nested2; }; internal: on port1.e1 ` // Internal transition `; entrypoint e1; exitpoint e2; local: e1 -> e2 ` // Local transition `; }; external: SelfTransitionExample -> SelfTransitionExample on port2.e2 ` // External transition `; }; Assume the currently active state configuration is { SelfTransitionExample , Nested1 , Nested2 } when one of the self-transitions get triggered: Internal transition ( internal ) No state is exited and the active state configuration remains unchanged. Local transition ( local ) 1) Nested2 is exited. 2) Nested1 is exited. 3) local executes. 4) Nested1 is entered. 5) Nested2 is entered. External transition ( external ) 1) Nested2 is exited. 2) Nested1 is exited. 3) SelfTransitionExample is exited. 4) external executes. 5) SelfTransitionExample is entered. 6) Nested1 is entered. 7) Nested2 is entered. Example You can find a sample application that has a local transition here . Class with State Machine Art allows you to create passive classes with state machines. This can be an alternative to using a capsule in case you only need a passive stateful data object, and don't need the ability to send events to it, or to let it execute in its own context. A class with a state machine is more lightweight than a capsule at runtime. Transitions in a class state machine are triggered by calling trigger operations on the class. A trigger operation is similar to a regular member function in C++, but does not have a code behavior of its own. Instead, when you call a trigger operation on an object of a class with a state machine it may trigger a transition in the class' state machine. That transition may have an effect code snippet that will execute. A trigger operation can have parameters which allows you to pass data when calling them. Those parameters can be accessed in the transition that is triggered by it. Below is an example of a class with a state machine with two trigger operations initialize and finalize . Note that you can define multiple trigger operations on the same line. class DataObject { /* Trigger Operations */ trigger initialize(`int` data), finalize(); /* State Machine */ statemachine { state Initial, Initialized, Finalized; initial -> Initial; init: Initial -> Initialized on initialize(`int`) ` // Initialized int i = data; `; Initialized -> Finalized on finalize() ` // Finalized `; }; }; Just like for C++ member functions, trigger operations support overloading. That is, you can have many trigger operations with the same name as long as their full signatures are unique. The signature of a trigger operation consists of its name and the types of all its parameters. When you reference a trigger operation with parameters as a transition trigger, you need to include the types of the parameters (see the trigger for the init transition above). The same transition can be triggered by multiple trigger operations (just like a transition in a capsule state machine can be triggered by multiple events). However, in that case those trigger operations should agree on the names and types of their parameters so that the transition effect code can access them in a way that works regardless of which of the trigger operations that will trigger the transition. Names of classes with state machines by convention start with uppercase, while names of trigger operations and their parameters by convention start with lowercase and use camelCase if the name consists of multiple words. A common design pattern is to let a class-with-statemachine instance be managed by a single capsule instance. This means that the capsule instance is responsible both for creating, using and finally destroying the class-with-statemachine instance. If you follow this pattern it is thread-safe to for example call public member functions defined on the capsule from a transition in the class state machine (or, better, to call non-public member functions by letting the class be a friend of the capsule). This can for example be used as a means for the class state machine to send events through the ports of the capsule (i.e. it can call a capsule member function that sends the event). However, to avoid exposing the full capsule functionality to the class state machine it's recommended to define an interface (i.e. abstract C++ class) which the capsule can implement. This interface can contain only those member functions which the class needs to call on the capsule. A class state machine can use the same constructs as a capsule state machine with a few exceptions: The initial transition cannot access initialization data as can a capsule's initial transition . Instead you can define one or several constructors for the class with parameters needed for passing initialization data when the class-with-statemachine instance is created. See Constructor for more information. The state machine can be hierarchical but the deep history pseudo state is not supported. Instead the shallow history pseudo state can be used. Even if it's possible for a class with a state machine to inherit from another class with a state machine, this doesn't mean that the state machines will be inherited as is the case for capsule inheritance. Read more about this in Inheritance . A class with state machine can have the same code snippets as a capsule. Constructor By default the initial transition of a class state machine executes at the time of constructing the class-with-statemachine instance. This happens because the generated default constructor will call an operation rtg_init1() which contains the code from the initial transition. If you want to wait with \"starting\" the state machine until a later point in time you need to define your own parameterless constructor which doesn't call this function. You can define any constructors you need on a class with a state machine. They are regular C++ constructors and allow to pass initialization data when creating a class-with-statemachine instance. Remember to call the rtg_init1() function in all such constructors, if you want the state machine to start at the time of creating the class-with-statemachine instance. Here is an example of a class with a state machine that has a user-defined constructor: class PC { [[rt::decl]] ` private: double m_data; public: PC(double data); ` [[rt::impl]] ` PC::PC(double data) : m_data(data) { rtg_init1(); } ` statemachine { state First; initial -> First ` // State machine started `; }; }; Shallow History Every nested state machine has an implicit pseudo state with the name history (in state diagrams it's shown as H to save space). It can be used as a target for any transition inside the nested state machine. When it is reached, the state machine will restore the previously active substate. However, if that state again is a composite state it's previously active substate will not be restored. This is in contrast to the deep history for capsule state machines, and is why for a class state machine this pseudo state is referred to as a shallow history. Here is an example: class MyClass { statemachine { state First { entrypoint ep1; ep1 -> history; }; initial -> First.ep1; }; }; Inheritance By using inheritance you can reuse and customize generic ( base ) Art elements into more specific ( derived ) Art elements. An Art element can inherit either from one or several other Art elements, and/or it can inherit from one or several C++ classes. The derived Art element can redefine elements of the base element. The redefining element (located in the derived element) can change one or several properties of the redefined element (located in the base element). This is very similar to how inheritance works in C++, with the difference that in C++ a redefining element has more restrictions on what properties that can be changed in the redefined element. For example, a redefining member function (known as an overridden member function in C++ terminology) must keep the same signature as the redefined member function (known as a virtual base member function in C++ terminology), and can only (in fact, must) change its implementation. In some cases Art inheritance not only allows to redefine inherited elements, but also to completely exclude them. An excluded element is not present in the derived element, so exclusion can be seen as a special form of redefinition where the whole element is removed in the derived element. In C++ it's not possible to exclude any inherited members. Capsule Inheritance A capsule can inherit from another capsule. Only one base capsule is allowed; multiple inheritance is not supported for capsules. In addition a capsule can inherit from any number of C++ classes (or structs). The derived capsule is type compatible with the base capsule in the sense that if you have a capsule part typed by the base capsule, you can at runtime incarnate it with instances of the derived capsule. Capsule inheritance has multiple dimensions. One dimension is the usual C++ inheritance between classes (remember that a capsule is an active class). In this dimension it is for example possible to redefine (a.k.a override) a virtual member function defined in the base capsule or in another base C++ class. But there is also a second dimension where the state machine of the derived capsule will implicitly inherit from the state machine of the base capsule. This makes it possible to redefine transitions and states. For example, a redefining transition in a derived capsule can change the effect code, the guard condition or the target state or pseudo state. And a redefining state in a derived capsule can change the entry or exit action, as well as any substate or subtransition in case the state is composite and has a nested state machine. It's also possible to completely exclude a state or a transition, either in the capsule's top state machine, or in a nested state machine. Below is an example of a capsule D that inherits from another capsule B . In addition the capsule D inherits from two C++ classes IDataManager and IController . capsule B { [[rt::decl]] ` protected: virtual void doSmth(); ` [[rt::impl]] ` void B_Actor::doSmth() { // ... } ` statemachine { state BS, BS2; _Initial: initial -> BS; }; }; capsule D : B, `IDataManager`, `IController` { [[rt::decl]] ` // IDataManager impl protected: void manageData() override; // IController impl void control() override; void doSmth() override; ` [[rt::impl]] ` // impl of manageData() and control() void D_Actor::doSmth() { // ... SUPER::doSmth(); // Call inherited function } ` statemachine { state DS; state exclude BS2; redefine _Initial: initial -> DS; }; }; In the example we can see that D overrides functions from the base C++ classes that are assumed to be virtual (or pure virtual). For brevity the implementations of these functions have been omitted but would be placed in the rt::impl code snippet. D also overrides a virtual function doSmth() from the base capsule B . The implementation of that function (also placed in the rt::impl code snippet) calls the inherited function by using a macro SUPER . This macro expands to the name of the base capsule class. Using this macro, instead of the base capsule class name, makes it easier to copy/paste code from one capsule to another. Example You can find a sample application where a capsule inherits from both another capsule and from C++ classes here . We can also see an example of a state machine redefinition. The initial transition _Initial of B 's state machine is redefined in D 's state machine so that it targets state DS instead of state BS . In the state diagram of D the state BS and the initial pseudo state are drawn with gray color and dashed outline, to show that they are inherited. The transition _Initial is also drawn with dashed outline, but with a different line style (\"dash-dot-dot\"), and with a green label to show that it's redefining the inherited initial transition. The state BS2 is excluded in D 's state machine. In state diagrams excluded elements are shown with a \"crossed\" background. Note that to be able to redefine the initial transition of B it is necessary to give it a name (so that it can be referenced as redefined from D ). This is yet another reason why it's good practise to give names to transitions, even if it's not mandated. But, of course, if you want to prevent anyone from creating a derived capsule with a state machine that redefines a certain transition, you can accomplish that by not giving a name to that transition. In effect, an unnamed transition is final , i.e. cannot be overridden or excluded. The rule that a capsule state machine must have exactly one initial transition also applies to a derived capsule. Therefore, when you introduce inheritance between two existing capsules, you typically first get an error saying that the derived capsule has two initial transitions (one inherited, and one locally defined). You then need to decide if you want to either remove the initial transition in the derived capsule, or (like in the above example) instead redefine the initial transition. Example You can find sample applications where capsule state machines are inherited here: Redefining a transition effect Redefining a transition trigger Redefining a transition guard Excluding a transition Capsule inheritance also has a third dimension, which relates to its structure. Parts and ports defined in the base capsule are inherited by the derived capsule. Just like for states and transitions, it's possible to redefine or exclude a part or a port. A redefining port can change the type (i.e. protocol ), multiplicity and the notification property of the redefined port. A redefining part can change the type, multiplicity and kind (fixed, optional or plugin) of the redefined part. Below is an example of a capsule DPPI that inherits from another capsule BPPI . The port port1 and the part part1 is redefined, while the port port2 and part part2 are excluded. capsule BPPI { service port port1 : PR1; behavior port port2 : PR1; part part1 : Cap1; part part2 : Cap1; statemachine { state State; initial -> State; }; }; capsule DPPI : BPPI { service notify port redefine port1 : PR2[10]; optional part redefine part1 : Cap2[0..20]; part exclude part2; behavior port exclude port2; statemachine { state State2; }; }; Redefined and excluded elements are also shown in class diagrams. Below is the class diagram for the capsules in the above example. Example You can find a sample application where parts are inherited here . Class Inheritance A class with state machine can inherit from other classes with state machines, or from C++ classes (or structs). Multiple inheritance is supported. Contrary to capsule inheritance , class inheritance does not imply inheritance between the state machines in the derived and base classes. This means it's not possible to redefine or exclude states and transitions in an inherited class state machine. Nor is it possible to redefine trigger operations. In fact, the derived class will have two state machines (its own, plus the one inherited from the base class) and these two state machines will execute independently of each other. That is, class inheritance is more a way of aggregating state machines rather than reusing and redefining them. Because of this, it's rather unusual to let two classes with state machines inherit each other. It's more useful to let a class with state machine inherit from other C++ classes. Below is an example of a class with state machine that inherits from two C++ classes DataContainer<CData> and IDisposable . class DataClass : `DataContainer<CData>`, `IDisposable` { [[rt::decl]] ` void dispose() override; // From IDisposable ` [[rt::impl]] ` void DataClass:dispose() { // impl } ` statemachine { state State; initial -> State; }; }; Protocol Inheritance A protocol may inherit events from another protocol. Only one base protocol is allowed; multiple inheritance is not supported for protocols. Inherited events can be redefined, but not excluded. A redefining event in a derived protocol can change the type of the event parameter as defined in the base protocol. In the example below, the protocol ExtendedMachineEvents adds one more in-event stop to the inherited MachineEvents protocol. It also redefines the startDeferred event to change its parameter type. protocol MachineEvents { in start(); in startDeferred(`unsigned long` /* milliseconds */); out success(); out error(`std::string` /* error message */); }; protocol ExtendedMachineEvents : MachineEvents { in stop(); in redefine startDeferred(`unsigned long long`); }; Example You can find sample applications using protocol inheritance here: A derived protocol inherits events from a base protocol A derived protocol redefines the parameter type of an inherited event Property Properties are name-value pairs that provide a generic mechanism for augmenting Art elements with extra data. Such data can be utilized by tools that operate on a parsed Art file, such as the code generator and semantic checker. Most Art elements can have properties and the syntax for specifying properties is the same regardless of the kind of element. However, different kinds of Art elements can have different properties. For Art elements that have a name, properties are specified right after the name. For elements without name, properties are specified before the element itself. In both cases the syntax looks like this: [[rt::properties( <property name>=<property value>, <property name>=<property value>, ... <property name>=<property value> )]] All properties have a default value, so you only need to specify a property if you want to set it to something else. The default values have been chosen so that you in most cases don't need to specify any properties at all. A property has a type, and its value must conform to that type. The following property types are supported: Boolean Boolean properties have a value that is either true or false . If you want to set a boolean property to true you can use a shorthand syntax where you just specify the property name. For example: capsule CapProp [[rt::properties( generate_file_impl=false, generate_file_header )]] { // ... }; Writing generate_file_header is equivalent to writing generate_file_header=true . However, this particular property has the default value true and hence doesn't need to be set at all. Integer Integer properties have a numeric value (>= 0). Here is an example: protocol XProtocol [[rt::properties( version=1 )]]{ // ... }; String String properties have a string value, enclosed in double quotes. Here is an example: class MC [[rt::properties( rule_config=\"E0022\" )]]{ // ... }; Enumeration A property of enumeration type has a value that references a literal of the enumeration. There are different enumerations used for different properties. The best way to learn about what enumeration literals that are available for a certain property is to use the Content Assist feature in the Art file editor. Place the cursor after the equal sign, and press Ctrl + Space . Here is an example of defining a property of enumeration type: class MC [[rt::properties( kind=struct )]]{ // ... }; Note that in some cases the name of an enumeration literal starts with underscore ( _ ) to prevent it from clashing with the set of Art keywords . Below is a table that lists all properties that can be used on different kinds of Art elements. Each property is described in a section of its own below the table. Art Elements Property Type Default Capsule , Class generate_file_header Boolean true Capsule , Class generate_file_impl Boolean true Capsule , Class , Protocol , Port , Initial transition , Triggered transition Trigger rule_config String \"\" Class , Protocol version Integer 0 Class generate_descriptor Enumeration (true, false, manual) true Class kind Enumeration (_class, struct, union) _class Class generate_class Boolean true Class generate_statemachine Boolean true Class const_target_param_for_decode Boolean false Class default_constructor_generate Boolean true Class default_constructor_explicit Boolean false Class default_constructor_inline Boolean false Class default_constructor_default Boolean false Class default_constructor_delete Boolean false Class default_constructor_visibility Enumeration (public, protected, private) public Port registration Enumeration (automatic, automatic_locked, application) automatic Port registration_name String \"\" Initial transition , Triggered transition const_rtdata Boolean true Transition , State , Choice , Junction , Entry Point , Exit Point color String \"\" generate_file_header By default a capsule or class is translated to one header file ( .h ) and one implementation file ( .cpp ). Set this property to false to prevent generation of the header file, for example if you prefer to write it manually. generate_file_impl By default a capsule or class is translated to one header file ( .h ) and one implementation file ( .cpp ). Set this property to false to prevent generation of the implementation file, for example if you prefer to write it manually. rule_config This property is used for configuring validation rules for an Art element. Read more about this here . version Specifies the version of an Art element. You can use this to keep track of updates to types used in APIs (increase the version when the element changes). generate_descriptor By default a type descriptor will be generated for each class . The TargetRTS uses the type descriptor to know how to initialize, copy, move, destroy, encode or decode an instance of that class. Set this property to false for classes that don't need a type descriptor. Set it to manual if the class needs a type descriptor but you want to implement it manually rather than using the implementation that is generated by default. Note that even if you set this property to true so that a default type descriptor is generated, you can still override individual type descriptor functions for the class. kind By default a class is translated to a C++ class. You can use this property to instead translate it to a struct or union . generate_class If set to false no C++ code will be generated for the class. generate_statemachine If set to false code generation for the class' state machine will be suppressed. You can use this if the state machine is informal, and you prefer to implement it manually in another way. const_target_param_for_decode By default a decode function uses a non-const target parameter. This is because usually a decode implementation must call non-const functions on the decoded object to populate it with data from the decoding. However, if it doesn't need to call such functions you can set this property so that the target parameter is declared as const. default_constructor_generate If set to false a default (i.e. parameterless) constructor will not be generated for the class. default_constructor_explicit If set to true the default (i.e. parameterless) constructor will be declared as explicit. default_constructor_inline If set to true the default (i.e. parameterless) constructor will be declared as inline. It's implementation will then be generated into the header file. default_constructor_default If set to true the default (i.e. parameterless) constructor will be declared as defaulted. This tells the compiler to synthesize a default constructor even if one normally would not be synthesized (for example because there is a user-defined constructor with parameters). default_constructor_delete If set to true the default (i.e. parameterless) constructor will be declared as deleted. This will cause the compiler to generate an error if it is invoked. This can be used for preventing objects of the class to be created. default_constructor_visibility This property can be used for setting the visibility of the default (i.e. parameterless) constructor. By default it will be public but you can change it either to protected or private . registration This property specifies how to register an unwired port at runtime. The default is automatic which means the port will be registered automatically when the container capsule instance is initialized. The value automatic_locked has the same meaning but the registration will be \"locked\" so that any future attempt to deregister it, or register it under a different name, will fail. Set the property to application to programmatically register the port using the functions registerSPP() and registerSAP() respectively. registration_name This property specifies the name to use when registering an unwired port at runtime. By default the port name is used, but it can be overridden using this property. const_rtdata This property can be set on transitions where you need to modify the data it receives when it's triggered. If the property is set to false the rtdata parameter in the transition function will be non-const. It can then be modified, which for example can avoid copying received message data and instead move it using its move constructor or move assignment operator. [[rt::properties(const_rtdata=false)]] CurrentState -> NextState ` someAttr = std::move(*rtdata); // Avoid copying the message data object `; MyTransition: [[rt::properties(const_rtdata=false)]] OtherState -> NextState ` pC = std::move(*((MyClass*) rtdata)); // Avoid copying the message data object `; Note that the const_rtdata property appears in the Art syntax right after the transition name. If the transition has no name, it appears in the beginning of the transition declaration. color Specifies which color to use for an Art element in a diagram. Colors should be specified as RGB values using 6 hexadecimal digits. For example, \"#ff00ff\". The Art text editor will help you set an appropriate color by means of a color picker. Note that you can also set the color directly from the diagram. Select a symbol or line and then set the color property using the Properties view (under \"Appearance\").","title":"The Art Language"},{"location":"art-lang/#concepts-and-terminology","text":"In Art the concept of a capsule is central. A capsule is like a C++ class, but with a few differences and extensions. A C++ class is passive in the sense that a caller can access its public member functions and variables at any time. Hence a C++ object always executes in the context of the caller, and when a member function is called, the caller is blocked until the function call returns. A capsule, however, is active and has its own execution context. This means that we never call a capsule member function or access a capsule member variable from outside the capsule itself. Instead we communicate with the capsule by sending events to it. Each capsule instance has a queue of events it has received and those events will be dispatched to the capsule instance one by one. The sender of the event is not blocked, as the event will be handled by the capsule instance asynchronously when it is later dispatched. The picture below shows 3 capsule instances each holding a queue with events that have been received, but not yet dispatched. Note that this picture is conceptual. In a real implementation several performance optimizations are applied, for example it's common to let a single thread drive more than one capsule instance, and several capsule instances can share a common event queue. But from a conceptual point of view each capsule instance has its own queue of events that are waiting to be dispatched to it. Events have a priority which determines how they are ordered in the queue. Events with high priority are placed before events with lower priority, and if two events have the same priority they are ordered according to when they arrive. A capsule may have ports. A port is typed by a protocol which defines the events that may be sent in to the port (these are known as in-events ), as well as the events the capsule itself may send out through the port for others to receive (these are called out-events ). Ports can be used both for internal and external communication. A port used for external communication is called a service port . Together, the service ports constitute the communication interface of the capsule, and decide what \"services\" the capsule provides for other capsules to use. A simple capsule which only handles a small number of events, may be able to handle all these events using a single state machine. However, when new ports are added (or new events in protocols typing existing ports), the capsule interface grows and the state machine has to grow with it, since there will be more events for it to handle. Eventually a point is reached where it will not be practical for a capsule to handle any more events in its own state machine, because it has grown too large or complex. If not before, this is the time to define a composite structure for the capsule. A composite structure is created by decomposing a capsule using capsule parts. A capsule part (or, for simplicity, just part ) is typed by another capsule and is a way for a capsule to delegate some of its responsibilities to other capsules. Such a decomposition is purely an implementation detail that is not visible from the outside of the capsule. When you send an event to a capsule you cannot know if the capsule will handle the event itself, or if it will forward the event to another capsule typing one of its capsule parts. The ability to decompose a capsule into parts is important for managing complexity. When a capsule has grown too big and complex you can decompose it into capsule parts without changing the communication interface of the capsule. Ports of capsules typing capsule parts are connected to each other by means of connectors. A connector is a conceptual construct for showing how events are routed in the composite structure of a capsule. At run-time connectors don't exist, and ports are directly connected to each other. Because of this, it's not mandatory to use connectors. You can also choose to dynamically connect (and disconnect) ports at run-time. Although this provides for more flexibility, it has the drawback of making it impossible to statically visualize the communication paths of a capsule. Ports that connect statically to other ports via connectors are called wired ports. Ports that are connected dynamically without use of static connectors are called unwired ports. The picture below shows the structure of a capsule Top which consists of two capsule parts ping and pong each holding a capsule instance (a Pinger capsule and a Ponger capsule respectively). The connector between the wired ports p on these capsules makes it possible for these capsules to communicate with each other. Communication can also happen using the unwired ports q1 and q2 if they are connected at run-time. The picture also shows that the capsule Ponger is further decomposed using a capsule part inner . All events sent to port p of Ponger will be further routed to port i of the Internal capsule. Regardless if ports are statically connected by connectors (wired ports), or dynamically connected at run-time (unwired ports), they must be compatible with each other. This means that the out-events of one port must match the in-events of the other port, for the ports to be possible to connect. This constraint ensures that events are never lost when traveling between two connected ports. To make it possible to describe the events that may be sent between two connected ports using a single protocol, one of the ports can be declared as conjugated . For a conjugated port the meaning of in-events and out-events are swapped, so that the in-events are the events that may be sent out through the port, and the out-events are the ports that may be sent to the port. In the picture above port q1 is non-conjugated ( ) while port q2 is conjugated ( ). Both capsule parts and ports may have multiplicity. You can think about a capsule part with multiplicity > 1 as an array that holds capsule instances at run-time. In the same way you can think about a port with multiplicity > 1 as an array that holds connections to port instances at run-time. The multiplicity of ports and parts must match when connecting two ports with each other. Once again, this constraint ensures that events will not be lost when traveling between the connected ports at run-time. The picture below shows a capsule with a part and a port that both have multiplicity > 1. In structure diagrams such parts and ports are shown as \"stacked boxes\". In addition to regular C++ member functions a capsule may have a state machine as its behavior. A state machine describes how an instance of the capsule may move between different states through its life-time. A transition that connects a source state with a target state may be triggered when a received event from a capsule's event queue is dispatched. Several conditions must hold true for the transition to trigger. For example, the event must match a trigger that specifies the expected type of event and the port on which it was received. It's also possible to associate a boolean guard condition with the transition and/or with the trigger which must be true for the transition to trigger. A transition may have an effect , which is a piece of C++ code that executes when the transition gets triggered. The picture below shows a state machine containing a few states and transitions. The presence of transition guard code is shown with a yellow dot and the presence of transition effect code is shown with a blue dot. Both these are C++ code snippets that are embedded in the Art file. When a capsule instance is created (this is sometimes referred to as capsule incarnation ), it's state machine starts to execute by triggering the transition that goes out from the initial state (the circular blue symbol to the left in the above diagram). Each state machine must have exactly one such initial state with an outgoing transition. Since this initial transition is triggered automatically when the capsule instance is created it cannot have constraints such as triggers and guard conditions. The initial transition is an example of a non-triggered transition since it cannot have triggers. The path from the source state to the target state can sometimes consist of more than one transition. In that case only the first of these is a triggered transition that may have triggers that specify when it will trigger. Once the first transition in this path has triggered, subsequent non-triggered transitions will always execute, one by one according to how they are connected in the state machine. However, also non-triggered transitions (with the exception of the initial transition) may have guards. Such guards are usually evaluated before the triggered transition triggers to ensure that they all are enabled, so that it's guaranteed that the target state can be reached. There is one exception to this rule, for transitions that leave a choice . Such guards are only evaluated once the choice has been reached to dynamically decide which outgoing transition to take next. This also means that guards of such transitions must be written so that at least (and at most) one outgoing transition is enabled, or there is a risk that the state machine will get stuck in the choice. In the state machine shown below the transitions t2 and t5 are triggered transitions, while other transitions are non-triggered. Transition t5 can only be triggered if either the guard of t7 or t6 is true, while t2 can be triggered even if neither the guard of t3 nor t4 is true. The target of transition t5 is a junction which is used for either splitting or merging transition paths depending on evaluated guard conditions. A state may be decomposed by a sub state machine. Such a state is called a composite state and a state machine that has composite states is called a hierarchical state machine . Transitions enter a composite state through an entry point and exit it through an exit point . Usually an entry point is connected to a nested state inside the state machine of the composite state, but it can also connect to a deep history . Reaching the deep history of a composite state means that all sub states that were previously active will become active again. Hence, deep history is a way to restore a composite state so all its nested states will be reactivated again recursively. The picture below shows a state machine with a composite state Composite containing two nested states S1 and S2 . When this state machine starts to execute state S1 first becomes active since Composite is entered using the ep1 entry point. Later, when leaving S2 through the ex1 exit point, state X becomes active. Then when leaving X through the transition that connects to the ep2 entry point the state S1 once again becomes active since ep2 is connected to the deep history. Of course, whenever a nested state is active, the enclosing composite state is also active. At any point in time a state machine has an active state configuration , which consists of the set of currently active states. A state may have an entry action and/or exit action which is a C++ code snippet that gets executed whenever the state is entered or exited. Note that state entry actions for nested states also run when those states are entered because of a deep history. In state diagrams the presence of entry and/or exit actions are shown by icons just below the state name. In the state machine shown below state S1 has an entry action, state S2 has an exit action and state S3 has both an entry and an exit action. A transition where the source and target state is the same state is called a self-transition . A special kind of self-transition is an internal transition , which is a transition that when triggered doesn't leave the current state. Hence, when an internal transition is triggered the active state configuration remains unchanged, and neither the entry nor exit action of the state gets executed. In the state machine shown below the state has two self-transitions; t which is a regular self-transition (a.k.a. external self-transition ) and it which is an internal transition. Since a state may have a large number of internal transitions they are not shown inside the state symbol, but if you select the state symbol you can see them in the Properties view. An icon is shown in the upper right corner of states that contain internal transitions. State machines can not only be defined for capsules but also for regular classes. This can be useful if you want a plain passive C++ class to have a state machine. Contrary to a capsule a class may not have ports and doesn't execute in its own context. It's therefore common to associate such a class with a capsule that it can use for sending events through its ports. Transitions of a passive class state machine are triggered by calling trigger operations on the class. Such operations have no code, but just trigger transitions in the class state machine. The realtime application needs to designate one capsule as the top capsule . This is done in the transformation configuration , which is a file containing all the properties used for building the application (e.g. code generator options, compiler settings etc.). There is no language construct in Art for defining a top capsule; any capsule that you define can act as the top capsule. However, in practise you typically decide at an early stage which capsule that will be the top capsule. The top capsule is the entry point of the realtime application. When it starts to execute one instance of the top capsule will be automatically created, and its state machine starts to execute. If you build a library rather than an executable you don't have a top capsule.","title":"Concepts and Terminology"},{"location":"art-lang/#embedded-c-code","text":"Art uses C++ as action and expression language. It also uses C++ for defining types, variables and functions. A C++ code snippet can be embedded into an Art file at many places by enclosing it with backticks. Here is an example of how to write the code that should execute when a transition triggers: S1 -> S2 on timer.timeout ` std::cout << \"Hello World!\" << std::endl; `; Here is another example that shows how to include some C++ code as the implementation preface of a capsule: capsule BrewControl { [[rt::impl_preface]] ` #include <iostream> ` }; Code snippets can not only be associated with Art language constructs as in the above two examples, but can also be placed at the Art file level. There are two such file-level code snippets: Declarations (rt::decl) May contain arbitrary C++ declarations. All these code snippets will be generated into a C++ header file with the same name as the Art file. Implementations (rt::impl) May contain arbitrary C++ implementations. All these code snippets will be generated into a C++ implementation file with the same name as the Art file. As an example, assume we have an Art file sample.art with the following contents [[rt::decl]] ` typedef C* Cptr; Cptr func1(); ` [[rt::impl]] ` Cptr func1() { return nullptr; } ` Two C++ files will be generated from this Art file: sample.art.h typedef C* Cptr; Cptr func1(); sample.art.cpp #include \"sample.art.h\" Cptr func1() { return nullptr; } File-level code snippets are useful whenever you need to include some C++ code in your application that doesn't naturally belong to any particular Art element. They can for example be used for declaring and implementing utility functions or types that are needed by many different Art elements. To use the declared elements from an Art element, you need to add an #include for the generated header file using a code snippet on the Art element. Note that an #include is needed even if the Art element is located in the same Art file as the declared elements it wants to use. Below is an example that shows how a protocol and a capsule can use the type Cptr defined in sample.art by adding #include s: protocol MyEvents { [[rt::header_preface]] ` #include \"sample.art.h\" ` out alert(`Cptr`); }; capsule Cx { [[rt::header_preface]] ` #include \"sample.art.h\" ` [[rt::decl]] ` protected: Cptr m_ptr; ` // ... }; Here an rt::header_preface code snippet is used for making the generated capsule and protocol header files include sample.art.h while an rt::decl code snippet is used for declaring a member variable m_ptr for the capsule. See the documentation of the different Art elements below to learn about what code snippets that are available for each kind of Art element.","title":"Embedded C++ Code"},{"location":"art-lang/#art-files-and-folders-and-reference-binding","text":"Any but the simplest of applications will consist of multiple Art files organized into folders. You can create as many Art files as you like, and every Art file may contain one or several Art elements. Art files containing Art elements that are related to each other should be grouped in a folder. For example, if you build a library from certain Art elements it makes sense to put the Art files with those elements in their own folder. Folders with Art files should be added as workspace folders, either using the command File - Add Folder to Workspace (to add a folder to an existing workspace), or using the command File - Open Workspace from File (to open an existing workspace from a file that defines the workspace folders). If your application consists of more than a couple of workspace folders use of a workspace file is recommended as it makes it quick and easy to add all workspace folders in one go with a single command. Note Art files must be on the top level in a workspace folder. Do not place them in subfolders. When an Art file contains a reference to an Art element that cannot be found within the same file, other Art files in the workspace will be searched for an Art element with the referenced name. This search starts with the Art files in the same workspace folder. If a matching Art element is found in one of these files, the reference is bound to it. Otherwise an active transformation configuration (TC) is required, which specifies one or several prerequisites. The Art files in the workspace folders where the prerequisite TCs are located will then be searched. The search continues recursively if the prerequisite TC itself has prerequisites. If a matching Art element cannot be found in any of these locations the reference will be unresolved and an error will be reported. For example: Couldn't resolve reference to Protocol 'UnknownPort'. (ART_9001_unresolvedReference) For more information about unresolved references, see this validation rule .","title":"Art Files and Folders and Reference Binding"},{"location":"art-lang/#textual-and-graphical-notations","text":"The Art language is a textual language, but many parts of it also have a graphical notation. For example, a state machine can be shown using a graphical state diagram, and the composite structure of a capsule can be shown in a structure diagram. Relationships between capsules, protocols and classes, such as inheritance, can be shown in class diagrams. Below are examples of these three kinds of diagrams: Diagrams are automatically updated when the corresponding Art file is modified. They use automatic layout to avoid the need for manual tidy-up of diagrams when something changes. This also significantly reduces the need for storing diagram specific properties in the Art files, such as coordinates or symbol dimensions. However, there are some properties used when rendering diagrams that are stored in the Art file. For example, if you assign a custom color to a state symbol it will be stored as a property on the state. capsule Cap { statemachine { state ColorfulState[[rt::properties(color=\"#b40e0e\")]]; }; }; Art elements are mostly edited using their textual notation, but diagrams also provide some editing capabilities. However, all edit commands performed from a diagram are actually mapped to corresponding textual modifications of the Art file. Editing from a diagram is therefore simply an alternative, and sometimes more convenient way, of editing the textual Art file.","title":"Textual and Graphical Notations"},{"location":"art-lang/#syntax","text":"Art uses a syntax that should be familiar to developers with knowledge about languages like C++ and Java. Declarations are terminated with a semicolon ; When multiple elements are declared in the same language construct commas , are used for separating the elements Curly brackets {} are used for grouping nested elements Square brackets [] are used for specifying cardinality (i.e. multiplicity) of elements A dot ( . ) is used as scope resolution operator Line // and block /* */ comments may be freely used for commenting","title":"Syntax"},{"location":"art-lang/#names-and-keywords","text":"Names of Art elements must be valid C++ identifiers since they will be used as names of C++ definitions in generated code. Names also must not clash with names used in the TargetRTS. Don't worry - the Art language editor will let you know if you choose a name that won't work. Just like any language, Art has certain keywords that are reserved and which cannot be used as names. These keywords are listed below: Art keywords behavior capsule choice class connect entry entrypoint exclude exit exitpoint fixed history in initial junction notify on optional out part plugin port protocol publish redefine service state statemachine subscribe template trigger typename unwired when with Art is a case-sensitive language and names may use any capitalization. However, just like with most languages, there are conventions for how to capitalize names. Those conventions are described below where each Art language construct is described in detail.","title":"Names and Keywords"},{"location":"art-lang/#comments","text":"The same kinds of comments as in C++ can be used, i.e. line and block comments. // line comment /* block comment */ /* multi-line block comment */","title":"Comments"},{"location":"art-lang/#capsule","text":"A capsule defines an active class with its own execution context. It may have ports through which it can receive events . A capsule has a state machine that describes how instances of the capsule transitions between different states in the response to received events. Names of capsules are typically nouns, often describing something that performs some form of activity. For example \"Controller\", \"TrafficLight\" or \"FaultHandler\". By convention names of capsules start with uppercase. Embedded C++ code can be used for declaring member variables, member functions, nested types etc for the capsule. Here is an example of a capsule with a simple state machine and a member variable. capsule Elevator { [[rt::decl]] ` unsigned int currentLevel = 0; ` statemachine { state Waiting; initial -> Waiting; }; }; Note Capsule member variables and member functions may be private or protected, but should usually not be public. To avoid threading issues all communication with a capsule should be done using events, and therefore public members are not recommended. An exception is capsule constructors which need to be accessible from other capsules that create instances of the capsule using a capsule factory. If you anyway let a capsule have public members you need to ensure they are only accessed from the same thread that runs the capsule. The example above uses an rt::decl code snippet for declaring a capsule member variable. It will have the default visibility which is private. Here is the list of all code snippets that can be used for a capsule: Code snippet C++ mapping Example of use rt::header_preface Inserted at the top of the capsule class header file Adding #includes needed by the capsule declaration rt::header_ending Inserted at the bottom of the capsule class header file Declaring a type alias for the capsule class rt::impl_preface Inserted at the top of the capsule class implementation file Adding #includes needed by the capsule implementation rt::impl_ending Inserted at the bottom of the capsule class implementation file Undefining a macro only used in a capsule implementation rt::decl Inserted into the capsule class header file (inside the class) Declaring a capsule member variable or function rt::impl Inserted into the capsule class implementation file Implementing a capsule member function","title":"Capsule"},{"location":"art-lang/#capsule-constructor","text":"Just like a regular class a capsule may have constructors. A capsule constructor is declared using an rt::decl code snippet and defined using an rt::impl code snippet. All capsule constructors have two mandatory parameters: rtg_rts This is the controller ( RTController* ) which will execute an instance of the capsule. It corresponds to the thread that runs the capsule instance. rtg_ref This is the part ( RTActorRef* ) into which the capsule instance will be inserted. Every capsule instance, except the top capsule, resides in exactly one part. After these parameters you can add your own parameters, to pass arbitrary initialization data to the capsule instance. Below is an example where a capsule MyCap has a reference variable m_c . To initialize this variable a capsule constructor is used. capsule MyCap { [[rt::decl]] ` public: MyCap_Actor(RTController*, RTActorRef*, MyClass&); private: MyClass& m_c; ` [[rt::impl]] ` MyCap_Actor::MyCap_Actor(RTController* rtg_rts, RTActorRef* rtg_ref, MyClass& c) :RTActor(rtg_rts, rtg_ref), m_c(c) { } ` }; When you create an instance of the capsule you have to provide arguments that match the parameters of one of its capsule constructors. For this you need to use a capsule factory . You can either specify such a capsule factory statically on a part that is typed by the capsule (see Part with Capsule Factory ), or you can provide a capsule factory dynamically when calling incarnateCustom() on a Frame port to incarnate an optional capsule part. Here is C++ code for doing the latter (assuming the optional part is called thePart ): RTActorId id = frame.incarnateCustom(thePart, RTActorFactory([this](RTController * c, RTActorRef * a, int index) { return new MyCap_Actor(c, a, getMyClass()); // Use capsule constructor })); if (!id.isValid()) { // Failed to incarnate thePart } Note the following: In C++ the capsule class has the \"_Actor\" suffix. A capsule constructor must call the RTActor constructor in its initializer. Code that calls the capsule constructor must include the header file where the capsule is located. Example You can find a sample application that uses a capsule constructor here .","title":"Capsule Constructor"},{"location":"art-lang/#capsule-destructor","text":"The destructor of a capsule frees the memory used for representing its states, ports etc. You cannot provide your own code to the destructor implementation. However, the RTActor class, which is the base class of every capsule class, provides a virtual function _predestroy() which you can override in your capsule. This function gets called just before the capsule instance is destroyed and is the place where you should put code that cleans up resources allocated by the capsule. Here is an example: capsule C { [[rt::decl]] ` public: virtual void _predestroy() override { // Clean-up and free allocated resources here SUPER::_predestroy(); } ` // ... }; It's important to remember to invoke the inherited function by calling SUPER::_predestroy() . Example You can find a sample application with a capsule that overrides _predestroy() here .","title":"Capsule Destructor"},{"location":"art-lang/#protocol-and-event","text":"A protocol defines events that may be sent in to a port (so called in-events) and events that may be sent out from the same port (so called out-events). By grouping events into protocols, and then typing ports with such protocols, we can precisely define which events the capsule may send and receive through that port. By convention names of protocols start with uppercase, while names of events start with lowercase and use camelCase if the name consists of multiple words. A protocol event may have a parameter, which enables it to carry data. You declare a parameter for an event by specifying the C++ type of the data to be carried by the event. Note An event can have at most one parameter. If you need to send multiple data objects with an event you can declare an event parameter of struct or class type. The following code snippets can be used for a protocol: Code snippet C++ mapping Example of use rt::header_preface Inserted at the top of the protocol class header file Adding #includes of header files defining types used as event parameter types rt::header_ending Inserted at the end (or near the end) of the protocol class header file Undefining a local macro that was defined in rt::header_preface Here is an example of a protocol that defines some in-events and some out-events: protocol MachineEvents { in start(); in startDeferred(`unsigned long` /* milliseconds */); out success(); out error(`std::string` /* error message */); in relayEvent(); out relayEvent(); }; The event relayEvent above is both an in-event and an out-event. Such symmetric events are useful in protocols typing ports that may receive and send the same events (for example a port that just forwards received events to another port). By convention a symmetric event is declared on a single line. At run-time we often talk about a message rather than an event. A message is an instance of an event, similar to how a capsule instance is an instance of a capsule. In other words, a message is a run-time concept while an event is a design-time concept.","title":"Protocol and Event"},{"location":"art-lang/#port","text":"A port defines a named point of communication for a capsule. A port is typed by a protocol which defines the events that may be sent in to (in-events) and out from (out-events) the port. A port may be conjugated in order to swap the meaning of in-events and out-events. That is, a capsule may send out-events on its non-conjugated ports, but in-events on its conjugated ports. A port becomes conjugated if you add a tilde (~) after its name. Ports are often named to describe the role or purpose of the communication that takes place on them. By convention names of ports start with lowercase and use camelCase if the name consists of multiple words. Here is an example of a capsule with a few ports. Note that Code RealTime provides several predefined protocols that can be used right away, for example Timing . Also note that you can declare multiple ports on a single line if the ports are of the same kind ( p1 and p2 below are both service ports). capsule Machine { service port control : MachineEvents; behavior port timer : Timing; // predefined Timing protocol service behavior port control2 : CtrlEvents; service port p1~ : MoreEvents, p2~ : OtherEvents; // ... }; Service ports constitute the externally visible communication interface for a capsule, and together they define which events can be sent to the capsule, and which events the capsule can send out for other capsules to receive. In a structure diagram the service ports are shown on the border of a capsule or part symbol. A behavior port is logically connected to the behavior (i.e. state machine ) of a capsule. This means that an event that a capsule receives on a behavior port will be handled by the state machine of that capsule. A non-behavior port, however, will simply route an event to another port to which it is connected. Every event that is sent will ultimately reach a behavior port (provided ports are properly connected), and the state machine of the capsule owning that behavior port will handle the event. In a structure diagram, behavior ports are connected to a small ellipse which represents the capsule state machine. Note that ports can also be shown in a class diagram. When a capsule wants to send an event to another capsule it calls a function on the port. There is one such function for each out-event (or in-event if the port is conjugated). These functions return an object on which a send() function can be called. Note that the sending capsule doesn't need to know which capsule that will receive and handle the sent event. Here is C++ code for sending events on ports with and without data: pongPort.pong().send(); // Send event \"pong\" without data on the \"pongPort\" pingPort.ping(5).send(); // Send event \"ping\" with data (an integer) on the \"pingPort\" Example You can find a sample application that sends events on ports with and without data here . Note that send() is not the only function you can call. For example, you can call invoke() if you want to wait until the receiver has received and replied to the event. This is useful for implementing synchronous communication between capsules.","title":"Port"},{"location":"art-lang/#port-multiplicity","text":"At run-time an instance of a port can be connected to a port instance on another capsule. Such connections is what make a sent event be routed from the port on which it is sent, through a number of non-behavior ports, until it finally reaches a behavior port. By default a port has single multiplicity (1) meaning that at most one such connection can be established. However, you can specify a non-single multiplicity for a port to allow for more connections to be created at run-time. In the example below a Server capsule has a port with multiplicity 100. At run-time an instance of that Server capsule can be connected to 100 different client ports, each of which can send events to the server. capsule Server { service port clients : ComEvents[100]; // ... }; In a structure diagram a port is shown as \"stacked\" if it has non-single multiplicity. You can also use a C++ expression to specify the port multiplicity. This can for example be useful if the multiplicity is defined in C++ as a macro, a template parameter or a constexpr. For example: capsule Server { service port clients : ComEvents[`NBR_CLIENTS`]; // ... };","title":"Port Multiplicity"},{"location":"art-lang/#notification-port","text":"Every protocol contains two implicit events rtBound and rtUnbound . A port can choose to receive those events whenever a connection for the port is established (rtBound) or dropped (rtUnbound) at run-time. Declare a port as a notification port to receive these events. capsule Server { service notify port clients : ComEvents[100]; // ... }; Port notifications are useful in dynamic systems when capsules need to wait until other capsules are ready, before they can start to communicate with those capsules. For example, a client may need to wait until a server is ready before it sends a request to that server. In the same way it's often useful to get notified when a connection is dropped, since that means communication on that port should no longer take place.","title":"Notification Port"},{"location":"art-lang/#unwired-port","text":"Ports are by default wired, meaning that they should be connected with connectors to specify statically how events will be routed. Having a static connector structure defined has the benefit that it becomes possible to look at a capsule's structure diagram to see how events received by the capsule will be routed at run-time. However, in some dynamic systems it's not possible to describe this statically. Ports may be connected and disconnected dynamically and the run-time connections between port instances may hence vary over time. If you need this flexibility you can declare ports as unwired. Here is an example of an application where a client capsule can connect to different kinds of server capsules. Sometimes it may be connected to server1 and sometimes to server2 . It is therefore not possible to describe the connections of Top statically using connectors, and we can instead declare the ports as unwired. capsule Top { part client : Client; part server1 : Server; part server2 : Server; // ... }; capsule Client { service behavior unwired port p : Protocol; // ... }; capsule Server { service behavior unwired port p~ : Protocol; // ... }; Note Only use unwired ports when required. It's strongly recommended to use wired ports whenever possible to enable the visualization of the connector structure in a structure diagram. When unwired ports are required you should write a comment that describes how they will be connected at run-time, since this often cannot easily be concluded by looking at the C++ code of the capsule. An unwired port is always a behavior port. In a structure diagram an unwired port is drawn with a hollow ellipse, while a wired behavior port is drawn with a filled ellipse. In the structure diagram below port q is wired while port p is unwired. An unwired port is either a service access point (SAP) or a service provision point (SPP) depending on the role it plays in a dynamic connection with another unwired port. The capsule that owns the SAP port uses it to subscribe to a service that is published by another capsule by means of an SPP port. The capsule with the SAP port is often called \"client\" or \"subscriber\" while the capsule with the SPP port is often called \"server\" or \"publisher\". Unwired ports get connected by means of registering them under a service name that should be unique in the application. Registration of unwired ports can either happen automatically when the container capsule instance is created, or programmatically at a later point in time. It's also possible to deregister unwired ports in order to disconnect them. You can specify how an unwired port should be registered by means of the following properties: registration specifies when an unwired port should be registered registration_name specifies the service name with which the port should be registered If you choose to register an unwired port programmatically (using the TargetRTS functions registerSPP() and registerSAP() ) you decide at registration time whether the port should be an SAP or SPP port. However, if you choose to instead let the port be registered automatically you need to declare the port as either a subscribe (SAP) or publish (SPP) port. Here is the same example again, but now with automatic registration of the unwired ports using the service name myService : capsule Client { subscribe behavior port sap [[rt::properties( registration_name = \"myService\") ]] : Protocol; // ... }; capsule Server { publish behavior port spp~ [[rt::properties( registration_name = \"myService\") ]] : Protocol; // ... }; Note that the keyword unwired can be implicit when you declare a port as either a subscribe or publish port. Example You can find a sample application that uses an unwired port here .","title":"Unwired Port"},{"location":"art-lang/#connector","text":"Connectors describe how events are routed within a capsule by connecting ports in its composite structure. They make it possible to see in a structure diagram which parts of a capsule that can communicate with each other. Each connector connects exactly two ports with each other. A connected port may either be a port of the capsule itself, or a port of a capsule that types one of its capsule parts. A few constraints decide if it's possible to connect two ports: 1) The ports must be wired. Unwired ports cannot be connected. 2) The ports must be typed by the same protocol. 3) The ports' conjugations must match. If the ports are at the same level in the capsule's structure (e.g. both ports belong to capsules typing capsule parts owned by the same capsule), then the connected ports must have the opposite conjugation. This is because events that are sent out from one of the ports must be able to be received by the other port and vice versa. However, if the ports are at different levels in the capsule's structure (e.g. one of them belongs to a capsule typing a capsule part owned by the capsule and the other belongs to the capsule itself), then the ports must have the same conjugation. This is because in this case events are simply delegated from one capsule to another. 4) If a connector is connected to a port and a part (where the port is defined on the capsule that types the part), then the port must be a service port. Only service ports are visible from the outside of a capsule. The example below shows the structure diagram of a capsule Top where we can see two connectors. capsule Top { part ping : Pinger, pong : Ponger; connect ping.p1 with pong.p2; // ... }; capsule Internal { service behavior port i~ : PROTO; // ... }; capsule Pinger { service behavior port p1 : PROTO; // ... }; capsule Ponger { service behavior port p2~ : PROTO; part inner : Internal; connect p2 with inner.i; // ... }; The connector between p1 and p2 goes between two ports on the same level which is why these ports must have opposite conjugation. The connector between p2 and i goes between two ports at different levels which is why these ports must have the same conjugation. The non-behavior port p2 is a so called relay port (it just relays all events it receives to another port) and the connector between p2 and i is sometimes called a delegation connector to describe the fact that capsule Ponger uses it for delegating some of its responsiblities to the capsule Internal . Note that relay ports can be optimized away so they don't exist at run-time (i.e. at run-time port p1 can be directly connected to i ). A connector doesn't have a direction, so it doesn't matter in which order it connects the two ports. That is, connecting X with Y is equivalent to connecting Y with X.","title":"Connector"},{"location":"art-lang/#local-binding","text":"A connector can connect two behavior ports on the same capsule (with opposite conjugations). At run-time this will lead to a local binding between these ports. This enables the capsule to send events to itself which sometimes can be useful. Here is an example: capsule Top { behavior port pOut : TheProtocol; behavior port pIn~ : TheProtocol; connect pOut with pIn; // ... }; One reason for a capsule to send events to itself could be to split a big and long-running task into smaller tasks. By sending an event to itself after completion of each small task, the capsule can remain responsive to other events that may arrive in the meantime. When it receives the event it sent it can proceed with the next part of the big task. Example You can find a sample application that uses a local binding here .","title":"Local Binding"},{"location":"art-lang/#part","text":"A capsule can be decomposed by means of parts (also called \"capsule parts\" to emphasize that they are parts of a capsule). A part is a container that at run-time may hold one or many capsule instances. The part has a multiplicity that specifies the maximum number of capsule instances it can contain at run-time, and it has a type which is another capsule. All capsule instances must either be of that specific capsule type, or of a capsule type that inherits from it. It's common to name parts according to the capsule that types them. For example, a part typed by a capsule Controller may be called controller , ctrl or perhaps theController . By convention part names start with lowercase and use camelCase if the name consists of multiple words. There are three kinds of parts which determine how and when they will be populated with capsule instances. 1) Fixed part In a fixed part capsule instances are created automatically when the container capsule is created, and destroyed when the container is destroyed. Fixed parts by default have multiplicity 1. Such a part will always contain one and only one instance of the capsule that types the part. Example You can find a sample application that has a fixed part with a multiplicity here . 2) Optional part In an optional part capsule instances don't have a strong lifetime relationship with the container capsule as is the case for fixed parts. The capsule instances can be created programmatically using a Frame port at some point after the container capsule has been created, and they can be destroyed before the container capsule is destroyed. However, at the latest they will be automatically destroyed when the container is destroyed. Optional parts by default have multiplicity 0..1. This means that they may either contain zero or one capsule instance at any point in time. The presence of zero in the multiplicity is what makes the part optional. Here is C++ code for creating a capsule instance in an optional part (also known as incarnating the part) and then immediately destroying it: RTActorId id = frame.incarnate(thePart); if (!id.isValid()) { // Failed to incarnate thePart } frame.destroy(id); It's important to check that incarnation was successful since there are many reasons why it can fail (e.g. too low multiplicity to fit the created capsule instance, not enough memory etc). If the instantiated capsule has a constructor you need to use a capsule factory for providing the constructor arguments (either provided when doing the incarnation as shown here or specified on the part as described here ). Example You can find a sample application that creates and destroys capsule instances in optional parts here . 3) Plugin part A plugin part is similar to an optional part in that it is populated by capsule instances programmatically. However, the capsule instances are not created in the plugin part but instead imported into the plugin part from another part. Typically such a capsule instance is first created into an optional part, and then at some later point in time imported into a plugin part. Later it can be deported (i.e. removed) from the plugin part and perhaps imported into another plugin part. This makes it possible to create very dynamic composite structures where the same capsule instance can play different roles in different parts over time. Moving a capsule instance by deporting it from one plugin part and then importing it in another plugin part is more efficient than destroying the capsule instance in one optional part and then creating another capsule instance in another optional part. Plugin parts are typically used together with unwired ports . In general it's possible to import a capsule instance into more than one plugin part at the same time, but it can only be imported if its ports are not already bound in its current location. Plugin parts by default have multiplicity 0..1. In the example below the capsule C contains a few parts of different kinds and multiplicities. Note that you may declare multiple parts on the same line if they are of the same kind (both c and d below are optional parts). capsule C { part a : D; fixed part b : D[4]; optional part c : D, d : D[0..5]; plugin part e : D; part f : D[`COUNT`]; // ... }; Part a is fixed with multiplicity 1 since neither kind nor multiplicity is specified for it. Part b is also fixed (using the fixed keyword for more clarity) and with multiplicity 4. When an instance of capsule C is created 5 instances of capsule D will be automatically created. One of these instances will be inserted into part a and the others into part b . These instances will remain there until the C capsule instance is destroyed. Part c is optional with multiplicity 0..1. At run-time it can contain at most one instance of capsule D . Part d is also optional but can contain up to 5 instances of D as specified by its multiplicity 0..5. Part e is plugin with the default multiplicity 0..1. At run-time at most one instance of capsule D can be imported into it. That instance must already have been created in another part, for example part c . Part f uses a C++ expression for specifying the multiplicity. This can for example be useful if the multiplicity is defined in C++ as a macro, a template parameter or a constexpr. Parts can be shown in a structure diagram: Parts are shown as \"stacked\" if they have non-single multiplicity (multiplicities specified with a C++ expression are assumed to be non-single). Optional parts are shown with a \"diagonal\" background pattern, while plugin parts are shown with a \"double diagonal\" background pattern. Parts can also be shown in a class diagram: In the above diagram the filled diamonds show that there is a strong life-time relationship between a C instance and the instances of D that are located in the fixed and optional parts a , b , c , d and f , while this is not the case for the instance located in the plugin part e as shown by the hollow diamond.","title":"Part"},{"location":"art-lang/#part-with-capsule-factory","text":"If the capsule that types a part has a capsule constructor with custom constructor parameters, you can define a capsule factory for the part. Such a capsule factory consists of one or both of the below code snippets that define how an instance of that capsule should be created and destroyed. rt::create Defines how to create an instance of the capsule. For example, which constructor arguments to pass, which thread to use for running the created capsule instance, at which index to insert the capsule instance into the part (in case it has multiplicity > 1) etc. rt::destroy Defines how to destroy an instance of the capsule. By default it's destroyed using the delete operator. Here is an example where a part defines a capsule factory that specifies a create function. The create function gets the mandatory constructor parameters rtg_rts and rtg_ref as arguments, as well as an index argument that specifies the index where the created capsule instance will be inserted. part engine : Engine [[rt::create]] ` return new Engine_Actor(rtg_rts, rtg_ref, true /* custom constructor arg */); `; Note that you may want to create a capsule factory for a part also for other reasons than passing custom constructor parameters. For example, you may want to change the default thread ( RTController* ) that should execute the created capsule instance, or you may want to instantiate an inherited capsule rather than the capsule that types the part. Example You can find a sample application here where a fixed part uses an rt::create code snippet for invoking a custom capsule constructor.","title":"Part with Capsule Factory"},{"location":"art-lang/#state-machine","text":"State machines are used for specifying the behavior of capsules . It is also possible to provide a state machine for a passive class; see Class with State Machine for more information about that. In this chapter we focus on state machines in capsules. A state machine consists of states and transitions. During its lifetime a capsule instance transitions between the various states of its state machine, as a consequence of receiving events on its behavior ports. When transitioning between two states one or several code snippets may execute. Such code may for example send events to other capsule instances, something that may cause transitions to execute in their state machines. A state machine may also have pseudo states , which just like states may be connected with transitions, but that unlike states are not places where the state machine should stay for some time. For example, most pseudo states like junctions and entry/exit points merely act as connection points that make it possible to execute more than one transition when transitioning between two states. The notable exception is the choice in which actually the state machine may get stuck for ever, but that would be an error situation that should not happen in a correctly designed state machine.","title":"State Machine"},{"location":"art-lang/#state","text":"The states of a state machine are the places where the state machine may stay for some time while waiting for a message to arrive that potentially can cause the state machine to transition to another state. States should have names that describe what is happening while the state machine stays there, or what has happened for the state machine to arrive there. For example, \"WaitForInit\", \"Processing\" or \"Terminated\". By convention state names start with uppercase. You can declare multiple states on the same line using a comma-separated list of state names. It can be good to write a comment in front of the state name, if you want to elaborate more on its meaning than what is possible in the name itself. Here is an example of a state machine with some states: capsule TrafficLight { statemachine { state WaitUntilServerReady, CycleLight; state /* pedestrians are crossing the street */ PedestriansCrossing; initial -> WaitUntilServerReady; WaitUntilServerReady -> CycleLight; CycleLight -> PedestriansCrossing; }; }; Here is another example where the state machine is shown in a state diagram. A state comment is not visible in a state diagram, but show up in a tooltip when putting the cursor on a reference to the state. They can thereby make it easier to understand a state machine. States may be nested to create a hierarchical state machine .","title":"State"},{"location":"art-lang/#entry-and-exit-action","text":"A state may have an entry and/or exit action which is a code snippet that runs whenever the state is entered and/or exited. state Walking { entry ` server.walk().send(); `; exit ` server.stop().send(); `; }; Example You can find a sample application where a state has an entry and exit action here .","title":"Entry and Exit Action"},{"location":"art-lang/#transition","text":"A transition connects a source state (or pseudo state) to a target state (or pseudo state). When a capsule instance handles a message that was received on one of its behavior ports, one or several transitions may execute. It's not required to give a name to a transition, but it's possible and often makes the state machine easier to understand. At least triggered transitions (i.e. transitions where the source is a state) should have a name. A transition name can be choosen to describe what has happened when the transition executes, for example \"requestReceived\", \"timeout\" etc. By convention transition names start with lowercase and use camelCase if the name consists of multiple words. A triggered transition has one or several triggers which define when the transition can be triggered. Each trigger specifies a port and an event. The trigger can only trigger its transition if the received message is an instance of the specified event, and was received on the specified port. In addition it's possible to provide guard conditions that must be fulfilled for the trigger to trigger its transition. Such a guard condition can be specified for the transition, but also for each individual trigger. Here is an example of a capsule state machine with two triggered transitions requestReceived and timeout . It also contains an initial transition that has no name. capsule MyCap { statemachine { state Waiting, Processing; initial -> Waiting; requestReceived: Waiting -> Processing on com1.request, com2.request when ` return canHandleNow(); ` ` log.log(\"Handling request\"); log.commit(); handle(msg); `; timeout: Waiting -> Waiting on timer.timeout[`zCount < 10`]; }; }; Note the following: Triggers are specified as PORT.EVENT after the keyword on . You may specify multiple triggers separated by comma ( , ). A guard condition for the transition is specified after the when keyword, while a guard condition for an individual trigger is specified in square brackets ( [] ) after the trigger. A guard condition can either be written as a C++ statement that returns the boolean guard condition (as in the guard for transition requestReceived in the above example), or it can be written as a boolean expression (as in the trigger guard for the timeout trigger in the above example). If the guard condition is simple, as is often the case, using a boolean expression is recommended. However, if needed you can use any number of C++ statements in a guard condition where the last statement should return a boolean expression. For example, you can declare local variables to store partial results when computing the boolean expression. Note Guard conditions should execute fast and have no side-effects. They are called frequently to decide which transition to execute when a message has arrived.","title":"Transition"},{"location":"art-lang/#initial-transition","text":"Every state machine needs exactly one initial transition. When the state machine starts to run, the first thing that happens is that the initial transition executes and takes the state machine to its first state. Therefore, an initial transition is a non-triggered transition and also cannot have a guard condition. But it can of course have an effect code snippet. The source of the initial transition is the initial pseudo state which is declared using the initial keyword. Just like for any transition it's optional to give a name to the initial transition (in fact it's often left unnamed). For capsule instances that are programmatically created (i.e. located in optional capsule parts) you can provide initialization data at the time of creation in the call to incarnate() on a Frame port. The initialization data can be accessed in the effect code of the initial transition. Here is an example: initial -> WaitForServerInit ` RTpchar str = *((RTpchar*) rtdata); `; Note Any type of data object can be passed as initialization data which means that rtdata is an untyped pointer that has to be casted to the expected type. A more type-safe way of passing initialization data is to define a constructor for a capsule. A capsule constructor can take any number of arguments, while with rtdata only one data object can be passed (even if you of course can group several data objects into a struct or class to circumvent this limitation). With capsule constructors you can pass initialization data also for capsule instances that are located in fixed parts. By default rtdata cannot be modified (it has type const void* ). However, by setting the const_rtdata property to false on the initial transition, you can make it non-const. One reason for doing this could be that the initial transition effect code wants to pass some data back to the code that creates the capsule instance. However, you must be very careful if you do this since this will only work if the creating code runs in the same thread that runs the initial transition. A more legitimate reason could be that you want to move the initialization data into a capsule variable, so you can access it later. Moving data can be more efficient than copying it. [[rt::properties(const_rtdata=false)]] initial -> Waiting ` pC = std::move(*((MyClass*) rtdata)); `; Note that the const_rtdata property can be set on any transition, not just the initial transition. It allows the data received when the transition is triggered to be modified. Example You can find a sample application that has transitions with the property const_rtdata unset here .","title":"Initial Transition"},{"location":"art-lang/#internal-transition","text":"An internal transition doesn't change the active state and therefore doesn't have a target state. An internal transition is always a triggered transition. You define an internal transition inside the state to which it belongs. Here is an example: state Done { unexpected: on myPort.* ` std::cout << \"Unexpected event received! << std::endl; `; }; Note the usage of an asterisk ( * ) to specify that any event received on myPort will trigger the internal transition when the state machine is in the Done state. Such \"receive-any\" events can of course be used for a trigger of any transition, but can in particular be useful for internal transitions that should handle all messages received on a port that are not handled by other triggered transitions leaving substates of the state. If another event is added to the port's protocol in the future, such a trigger will handle the new event too without a need for being updated. Example You can find a sample application that has an internal transition with a \"receive-any\" event trigger here . Internal transitions are examples of so called self-transitions. To learn about other types of self-transitions see this chapter .","title":"Internal Transition"},{"location":"art-lang/#choice-and-junction","text":"Choices and junctions are pseudo states that make it possible to split transition flows in a state machine. That is, one incoming transition may be split into multiple outgoing transitions. Which of the outgoing transitions that will execute is decided by evaluating their guard conditions. For a junction the guard conditions are evaluated already before leaving the currently active state. Only if there exists a path of transitions where all guards are fulfilled, will the active state be exited and the transitions can execute. Otherwise the state machine stays in its current state and attempts to find another path of transitions to execute. For a choice the guard conditions are evaluated after leaving the current state, when reaching the choice itself. The outgoing transition which has a fulfilled guard will execute next. Note It's important that there always is an outgoing transition for a choice with a fulfilled guard condition. Otherwise the state machine will get stuck in the choice without any chance of getting out of it. The same is true if a junction is used in the initial transition . If such a junction doesn't have an outgoing transition with a fulfilled guard condition then the state machine will stay in the initial state for ever. Choices and junctions must have names, so they can be referenced as the source or target of transitions. You can choose to use a name that gives a hint about what conditions that are checked in the guards of the outgoing transitions. For example, isEnabled for a choice that checks a boolean condition and checkValue when the condition has some other type. If you follow this approach you can then name the outgoing transitions accordingly. For example true and false for a choice that checks a boolean condition. By convention choice and junction names start with lowercase and use camelCase if they consist of multiple words. Sometimes it may be difficult to come up with a good name and in that case you can choose something short and \"technical\" like j1 , check1 etc. Below is an example of a state machine containing a choice and a junction. statemachine { state First, Second, Third; t1: initial -> First; choice isEnabled; junction checkThreshold; switchTurned: First -> isEnabled; true: isEnabled -> Second when ` return isEnabled(); `; false: isEnabled -> Second when ` else `; timeout: First -> checkThreshold; low: checkThreshold -> Third when ` return t < LIMIT1; `; medium: checkThreshold -> Third when ` return t >= LIMIT1 && t < LIMIT2; `; high: checkThreshold -> Third; }; Note the use of the C++ keyword else for defining an else-guard. An else-guard will be fulfilled when no other guard of other outgoing transitions is fulfilled. For choices it's good practise to always have exactly one transition with an else-guard to ensure that at least one guard condition will be fulfilled. Thereby we avoid the risk of the state machine getting stuck in the choice. Else-guards can also be useful for junction transitions, but there they are more optional (except when a junction is used in the initial transition; see the note above). You can also define an else-transition for a choice or junction by simply omitting the guard condition. This is consistent with triggered transitions where the absense of a guard condition is equivalent to a guard condition that always is fulfilled. See the transition high in the above example. Guard conditions should be mutually exclusive so that the order in which they are evaluated doesn't matter. Junctions can also be used for merging multiple incoming transition flows into a single outgoing transition. This can for example be useful if you want to reuse a transition path in the state machine for several triggered transitions. statemachine { state S1, S2; junction j1; initial -> S1; t1: S1 -> j1 on port1.e1 ` // handle e1 `; t2: S1 -> j1 on port2.e2 ` // handle e2 `; t3: S1 -> j1 on port3.e3 ` // handle e3 `; common: j1 -> S2 ` // common code here `; }; Of course, in the above simple example the same code reuse could also be obtained by putting the common code in a capsule member function which is called by each of the incoming transitions. But if the common transition is followed by more non-triggered transitions the above approach is more feasible. When multiple triggered transitions converge into a common transition as in the example above, and the events that trigger those transitions have a data parameter, it's best to access that data in the triggered transitions and not in the common transition. This is especially true if the types of those data parameters are not the same, because in that case the rtdata parameter of the function generated for the common transition will be untyped ( void* ). You can of course still cast it to another type, but that requires that you can know which of the triggered transitions that were triggered. It's therefore better to access the data in the triggered transitions and if necessary store it in a capsule variable which you then can access in the common transition if needed. Example You can find a sample application that demonstrates usage of a choice and junction here .","title":"Choice and Junction"},{"location":"art-lang/#hierarchical-state-machine","text":"A state machine is hierarchical if it contains at least one composite state, i.e. a state with a nested state machine. A transition that is triggered in the enclosing state machine (i.e. the state machine that contains the composite state) should enter a composite state by specifying an entry point of the composite state as the target. In the nested state machine another transition can connect that entry point to a state in the nested state machine. A transition in the nested state machine may specify an exit point of the composite state as the target. In the enclosing state machine another transition can connect that exit point to a state in the enclosing state machine. Entry and exit points are pseudo states that need to be named. The names can be chosen to give a hint about when the composite state is entered or exited through them, for example systemStarted or errorDetected . If you want you can prefix the names with ep or ex . It's also common to use short and \"technical\" names like ep1 or ex1 if a more descriptive name doesn't make sense. By convention entry and exit point names start with lowercase and use camelCase if they consist of multiple words. It's also possible to directly enter a composite state without using an entry point. In this case the behavior will depend on whether the composite state is entered for the first time or not. If it is for the first time, the initial transition of the nested state machine will execute after the transition that targets the composite state has executed. Otherwise the composite state will instead be entered using deep history , i.e. by activating the state in the nested state machine that was most recently active (and recursively if that state again is a composite state). Note It's recommended to always enter a composite state using an entry point as the behavior then doesn't depend on if the state was previously entered or not. Below is an example of a hierarchical state machine with a composite state CompositeState that contains a nested state machine. Note that you can declare multiple entry or exit points on the same line. statemachine { initial -> CompositeState.ep1; state CompositeState { state Nested; entrypoint ep1, ep2; exitpoint ex1; initial -> Nested; ep1 -> Nested; Nested -> ex1; ep2 -> history*; }; state Other; CompositeState.ex1 -> Other; Other -> CompositeState.ep2; }; Note that a dot ( . ) is used as scope resolution operator, to make it possible to reference an entry or exit point from the enclosing state machine. Inside the nested state machine the entry and exit points are directly accessible without use of the scope resolution operator (using it there would be an error). It is possible to only connect an entry point on the \"outside\". Entering the state via such an entry point will behave in the same way as entering the composite state without using an entry point (see above). It's therefore not recommended. In the same way it's possible to exit a composite state using an exit point that only is connected on the \"inside\". In this case the composite state is not exited and instead the previously active substate again becomes active (recursively, just like for deep history ). This is also not recommended, unless the transition is a local transition . Example You can find a sample application that contains a composite state with an entry and exit point here . Just like a junction , an entry or exit point can have multiple outgoing transitions. Guards on those transitions decide which of them to execute, and are evaluated before leaving the current state. Therefore, the same recommendations as for guard conditions of junctions apply for entry and exit points.","title":"Hierarchical State Machine"},{"location":"art-lang/#deep-history","text":"Every nested state machine has an implicit pseudo state with the name history* (in state diagrams it's shown as H* to save space). It can be used as a target for any transition inside the nested state machine. When it is reached, the state machine will restore the previously active substate. If that state again is a composite state, its previously active substate will also be restored. This goes on recursively for all nested state machines (which is why it's called a deep history). In the example above we can see that the transition from ep2 targets the deep history pseudo state. This means that if the Nested substate is active and then the transition to ex1 gets triggered, the state Other becomes active. If then the transition to ep2 gets triggered the CompositeState will be entered using deep history so that the Nested substate will again become active. Example You can find a sample application that uses the deep history pseudo state here .","title":"Deep History"},{"location":"art-lang/#local-transition","text":"A transition in a nested state machine that connects an entry point and exit point on the same state, and these entry/exit points only are connected on the \"inside\", is a local transition . A local transition is a self-transition that behaves something in between an internal transition and a regular (a.k.a. external) self-transition. An internal transition defined on a composite state handles a message without exiting neither that composite state, nor any of its substates. However, a local transition will exit the substates, run the effect code, and then enter the substates again. But the composite state itself will not be exited and entered. An external self-transition on the other hand will exit both the composite state and all active substates recursively, run the effect code, and then enter these states again. Both for local and external self-transitions exiting of states happens bottom-up which means that the deepest nested substate will first be exited, then its parent state, and so on. Entering happens in the opposite order, i.e. in a top-down fashion. Let's look at an example to understand the difference between these three kinds of self-transitions: statemachine { initial -> SelfTransitionExample; state SelfTransitionExample { state Nested1 { state Nested2; }; internal: on port1.e1 ` // Internal transition `; entrypoint e1; exitpoint e2; local: e1 -> e2 ` // Local transition `; }; external: SelfTransitionExample -> SelfTransitionExample on port2.e2 ` // External transition `; }; Assume the currently active state configuration is { SelfTransitionExample , Nested1 , Nested2 } when one of the self-transitions get triggered: Internal transition ( internal ) No state is exited and the active state configuration remains unchanged. Local transition ( local ) 1) Nested2 is exited. 2) Nested1 is exited. 3) local executes. 4) Nested1 is entered. 5) Nested2 is entered. External transition ( external ) 1) Nested2 is exited. 2) Nested1 is exited. 3) SelfTransitionExample is exited. 4) external executes. 5) SelfTransitionExample is entered. 6) Nested1 is entered. 7) Nested2 is entered. Example You can find a sample application that has a local transition here .","title":"Local Transition"},{"location":"art-lang/#class-with-state-machine","text":"Art allows you to create passive classes with state machines. This can be an alternative to using a capsule in case you only need a passive stateful data object, and don't need the ability to send events to it, or to let it execute in its own context. A class with a state machine is more lightweight than a capsule at runtime. Transitions in a class state machine are triggered by calling trigger operations on the class. A trigger operation is similar to a regular member function in C++, but does not have a code behavior of its own. Instead, when you call a trigger operation on an object of a class with a state machine it may trigger a transition in the class' state machine. That transition may have an effect code snippet that will execute. A trigger operation can have parameters which allows you to pass data when calling them. Those parameters can be accessed in the transition that is triggered by it. Below is an example of a class with a state machine with two trigger operations initialize and finalize . Note that you can define multiple trigger operations on the same line. class DataObject { /* Trigger Operations */ trigger initialize(`int` data), finalize(); /* State Machine */ statemachine { state Initial, Initialized, Finalized; initial -> Initial; init: Initial -> Initialized on initialize(`int`) ` // Initialized int i = data; `; Initialized -> Finalized on finalize() ` // Finalized `; }; }; Just like for C++ member functions, trigger operations support overloading. That is, you can have many trigger operations with the same name as long as their full signatures are unique. The signature of a trigger operation consists of its name and the types of all its parameters. When you reference a trigger operation with parameters as a transition trigger, you need to include the types of the parameters (see the trigger for the init transition above). The same transition can be triggered by multiple trigger operations (just like a transition in a capsule state machine can be triggered by multiple events). However, in that case those trigger operations should agree on the names and types of their parameters so that the transition effect code can access them in a way that works regardless of which of the trigger operations that will trigger the transition. Names of classes with state machines by convention start with uppercase, while names of trigger operations and their parameters by convention start with lowercase and use camelCase if the name consists of multiple words. A common design pattern is to let a class-with-statemachine instance be managed by a single capsule instance. This means that the capsule instance is responsible both for creating, using and finally destroying the class-with-statemachine instance. If you follow this pattern it is thread-safe to for example call public member functions defined on the capsule from a transition in the class state machine (or, better, to call non-public member functions by letting the class be a friend of the capsule). This can for example be used as a means for the class state machine to send events through the ports of the capsule (i.e. it can call a capsule member function that sends the event). However, to avoid exposing the full capsule functionality to the class state machine it's recommended to define an interface (i.e. abstract C++ class) which the capsule can implement. This interface can contain only those member functions which the class needs to call on the capsule. A class state machine can use the same constructs as a capsule state machine with a few exceptions: The initial transition cannot access initialization data as can a capsule's initial transition . Instead you can define one or several constructors for the class with parameters needed for passing initialization data when the class-with-statemachine instance is created. See Constructor for more information. The state machine can be hierarchical but the deep history pseudo state is not supported. Instead the shallow history pseudo state can be used. Even if it's possible for a class with a state machine to inherit from another class with a state machine, this doesn't mean that the state machines will be inherited as is the case for capsule inheritance. Read more about this in Inheritance . A class with state machine can have the same code snippets as a capsule.","title":"Class with State Machine"},{"location":"art-lang/#constructor","text":"By default the initial transition of a class state machine executes at the time of constructing the class-with-statemachine instance. This happens because the generated default constructor will call an operation rtg_init1() which contains the code from the initial transition. If you want to wait with \"starting\" the state machine until a later point in time you need to define your own parameterless constructor which doesn't call this function. You can define any constructors you need on a class with a state machine. They are regular C++ constructors and allow to pass initialization data when creating a class-with-statemachine instance. Remember to call the rtg_init1() function in all such constructors, if you want the state machine to start at the time of creating the class-with-statemachine instance. Here is an example of a class with a state machine that has a user-defined constructor: class PC { [[rt::decl]] ` private: double m_data; public: PC(double data); ` [[rt::impl]] ` PC::PC(double data) : m_data(data) { rtg_init1(); } ` statemachine { state First; initial -> First ` // State machine started `; }; };","title":"Constructor"},{"location":"art-lang/#shallow-history","text":"Every nested state machine has an implicit pseudo state with the name history (in state diagrams it's shown as H to save space). It can be used as a target for any transition inside the nested state machine. When it is reached, the state machine will restore the previously active substate. However, if that state again is a composite state it's previously active substate will not be restored. This is in contrast to the deep history for capsule state machines, and is why for a class state machine this pseudo state is referred to as a shallow history. Here is an example: class MyClass { statemachine { state First { entrypoint ep1; ep1 -> history; }; initial -> First.ep1; }; };","title":"Shallow History"},{"location":"art-lang/#inheritance","text":"By using inheritance you can reuse and customize generic ( base ) Art elements into more specific ( derived ) Art elements. An Art element can inherit either from one or several other Art elements, and/or it can inherit from one or several C++ classes. The derived Art element can redefine elements of the base element. The redefining element (located in the derived element) can change one or several properties of the redefined element (located in the base element). This is very similar to how inheritance works in C++, with the difference that in C++ a redefining element has more restrictions on what properties that can be changed in the redefined element. For example, a redefining member function (known as an overridden member function in C++ terminology) must keep the same signature as the redefined member function (known as a virtual base member function in C++ terminology), and can only (in fact, must) change its implementation. In some cases Art inheritance not only allows to redefine inherited elements, but also to completely exclude them. An excluded element is not present in the derived element, so exclusion can be seen as a special form of redefinition where the whole element is removed in the derived element. In C++ it's not possible to exclude any inherited members.","title":"Inheritance"},{"location":"art-lang/#capsule-inheritance","text":"A capsule can inherit from another capsule. Only one base capsule is allowed; multiple inheritance is not supported for capsules. In addition a capsule can inherit from any number of C++ classes (or structs). The derived capsule is type compatible with the base capsule in the sense that if you have a capsule part typed by the base capsule, you can at runtime incarnate it with instances of the derived capsule. Capsule inheritance has multiple dimensions. One dimension is the usual C++ inheritance between classes (remember that a capsule is an active class). In this dimension it is for example possible to redefine (a.k.a override) a virtual member function defined in the base capsule or in another base C++ class. But there is also a second dimension where the state machine of the derived capsule will implicitly inherit from the state machine of the base capsule. This makes it possible to redefine transitions and states. For example, a redefining transition in a derived capsule can change the effect code, the guard condition or the target state or pseudo state. And a redefining state in a derived capsule can change the entry or exit action, as well as any substate or subtransition in case the state is composite and has a nested state machine. It's also possible to completely exclude a state or a transition, either in the capsule's top state machine, or in a nested state machine. Below is an example of a capsule D that inherits from another capsule B . In addition the capsule D inherits from two C++ classes IDataManager and IController . capsule B { [[rt::decl]] ` protected: virtual void doSmth(); ` [[rt::impl]] ` void B_Actor::doSmth() { // ... } ` statemachine { state BS, BS2; _Initial: initial -> BS; }; }; capsule D : B, `IDataManager`, `IController` { [[rt::decl]] ` // IDataManager impl protected: void manageData() override; // IController impl void control() override; void doSmth() override; ` [[rt::impl]] ` // impl of manageData() and control() void D_Actor::doSmth() { // ... SUPER::doSmth(); // Call inherited function } ` statemachine { state DS; state exclude BS2; redefine _Initial: initial -> DS; }; }; In the example we can see that D overrides functions from the base C++ classes that are assumed to be virtual (or pure virtual). For brevity the implementations of these functions have been omitted but would be placed in the rt::impl code snippet. D also overrides a virtual function doSmth() from the base capsule B . The implementation of that function (also placed in the rt::impl code snippet) calls the inherited function by using a macro SUPER . This macro expands to the name of the base capsule class. Using this macro, instead of the base capsule class name, makes it easier to copy/paste code from one capsule to another. Example You can find a sample application where a capsule inherits from both another capsule and from C++ classes here . We can also see an example of a state machine redefinition. The initial transition _Initial of B 's state machine is redefined in D 's state machine so that it targets state DS instead of state BS . In the state diagram of D the state BS and the initial pseudo state are drawn with gray color and dashed outline, to show that they are inherited. The transition _Initial is also drawn with dashed outline, but with a different line style (\"dash-dot-dot\"), and with a green label to show that it's redefining the inherited initial transition. The state BS2 is excluded in D 's state machine. In state diagrams excluded elements are shown with a \"crossed\" background. Note that to be able to redefine the initial transition of B it is necessary to give it a name (so that it can be referenced as redefined from D ). This is yet another reason why it's good practise to give names to transitions, even if it's not mandated. But, of course, if you want to prevent anyone from creating a derived capsule with a state machine that redefines a certain transition, you can accomplish that by not giving a name to that transition. In effect, an unnamed transition is final , i.e. cannot be overridden or excluded. The rule that a capsule state machine must have exactly one initial transition also applies to a derived capsule. Therefore, when you introduce inheritance between two existing capsules, you typically first get an error saying that the derived capsule has two initial transitions (one inherited, and one locally defined). You then need to decide if you want to either remove the initial transition in the derived capsule, or (like in the above example) instead redefine the initial transition. Example You can find sample applications where capsule state machines are inherited here: Redefining a transition effect Redefining a transition trigger Redefining a transition guard Excluding a transition Capsule inheritance also has a third dimension, which relates to its structure. Parts and ports defined in the base capsule are inherited by the derived capsule. Just like for states and transitions, it's possible to redefine or exclude a part or a port. A redefining port can change the type (i.e. protocol ), multiplicity and the notification property of the redefined port. A redefining part can change the type, multiplicity and kind (fixed, optional or plugin) of the redefined part. Below is an example of a capsule DPPI that inherits from another capsule BPPI . The port port1 and the part part1 is redefined, while the port port2 and part part2 are excluded. capsule BPPI { service port port1 : PR1; behavior port port2 : PR1; part part1 : Cap1; part part2 : Cap1; statemachine { state State; initial -> State; }; }; capsule DPPI : BPPI { service notify port redefine port1 : PR2[10]; optional part redefine part1 : Cap2[0..20]; part exclude part2; behavior port exclude port2; statemachine { state State2; }; }; Redefined and excluded elements are also shown in class diagrams. Below is the class diagram for the capsules in the above example. Example You can find a sample application where parts are inherited here .","title":"Capsule Inheritance"},{"location":"art-lang/#class-inheritance","text":"A class with state machine can inherit from other classes with state machines, or from C++ classes (or structs). Multiple inheritance is supported. Contrary to capsule inheritance , class inheritance does not imply inheritance between the state machines in the derived and base classes. This means it's not possible to redefine or exclude states and transitions in an inherited class state machine. Nor is it possible to redefine trigger operations. In fact, the derived class will have two state machines (its own, plus the one inherited from the base class) and these two state machines will execute independently of each other. That is, class inheritance is more a way of aggregating state machines rather than reusing and redefining them. Because of this, it's rather unusual to let two classes with state machines inherit each other. It's more useful to let a class with state machine inherit from other C++ classes. Below is an example of a class with state machine that inherits from two C++ classes DataContainer<CData> and IDisposable . class DataClass : `DataContainer<CData>`, `IDisposable` { [[rt::decl]] ` void dispose() override; // From IDisposable ` [[rt::impl]] ` void DataClass:dispose() { // impl } ` statemachine { state State; initial -> State; }; };","title":"Class Inheritance"},{"location":"art-lang/#protocol-inheritance","text":"A protocol may inherit events from another protocol. Only one base protocol is allowed; multiple inheritance is not supported for protocols. Inherited events can be redefined, but not excluded. A redefining event in a derived protocol can change the type of the event parameter as defined in the base protocol. In the example below, the protocol ExtendedMachineEvents adds one more in-event stop to the inherited MachineEvents protocol. It also redefines the startDeferred event to change its parameter type. protocol MachineEvents { in start(); in startDeferred(`unsigned long` /* milliseconds */); out success(); out error(`std::string` /* error message */); }; protocol ExtendedMachineEvents : MachineEvents { in stop(); in redefine startDeferred(`unsigned long long`); }; Example You can find sample applications using protocol inheritance here: A derived protocol inherits events from a base protocol A derived protocol redefines the parameter type of an inherited event","title":"Protocol Inheritance"},{"location":"art-lang/#property","text":"Properties are name-value pairs that provide a generic mechanism for augmenting Art elements with extra data. Such data can be utilized by tools that operate on a parsed Art file, such as the code generator and semantic checker. Most Art elements can have properties and the syntax for specifying properties is the same regardless of the kind of element. However, different kinds of Art elements can have different properties. For Art elements that have a name, properties are specified right after the name. For elements without name, properties are specified before the element itself. In both cases the syntax looks like this: [[rt::properties( <property name>=<property value>, <property name>=<property value>, ... <property name>=<property value> )]] All properties have a default value, so you only need to specify a property if you want to set it to something else. The default values have been chosen so that you in most cases don't need to specify any properties at all. A property has a type, and its value must conform to that type. The following property types are supported: Boolean Boolean properties have a value that is either true or false . If you want to set a boolean property to true you can use a shorthand syntax where you just specify the property name. For example: capsule CapProp [[rt::properties( generate_file_impl=false, generate_file_header )]] { // ... }; Writing generate_file_header is equivalent to writing generate_file_header=true . However, this particular property has the default value true and hence doesn't need to be set at all. Integer Integer properties have a numeric value (>= 0). Here is an example: protocol XProtocol [[rt::properties( version=1 )]]{ // ... }; String String properties have a string value, enclosed in double quotes. Here is an example: class MC [[rt::properties( rule_config=\"E0022\" )]]{ // ... }; Enumeration A property of enumeration type has a value that references a literal of the enumeration. There are different enumerations used for different properties. The best way to learn about what enumeration literals that are available for a certain property is to use the Content Assist feature in the Art file editor. Place the cursor after the equal sign, and press Ctrl + Space . Here is an example of defining a property of enumeration type: class MC [[rt::properties( kind=struct )]]{ // ... }; Note that in some cases the name of an enumeration literal starts with underscore ( _ ) to prevent it from clashing with the set of Art keywords . Below is a table that lists all properties that can be used on different kinds of Art elements. Each property is described in a section of its own below the table. Art Elements Property Type Default Capsule , Class generate_file_header Boolean true Capsule , Class generate_file_impl Boolean true Capsule , Class , Protocol , Port , Initial transition , Triggered transition Trigger rule_config String \"\" Class , Protocol version Integer 0 Class generate_descriptor Enumeration (true, false, manual) true Class kind Enumeration (_class, struct, union) _class Class generate_class Boolean true Class generate_statemachine Boolean true Class const_target_param_for_decode Boolean false Class default_constructor_generate Boolean true Class default_constructor_explicit Boolean false Class default_constructor_inline Boolean false Class default_constructor_default Boolean false Class default_constructor_delete Boolean false Class default_constructor_visibility Enumeration (public, protected, private) public Port registration Enumeration (automatic, automatic_locked, application) automatic Port registration_name String \"\" Initial transition , Triggered transition const_rtdata Boolean true Transition , State , Choice , Junction , Entry Point , Exit Point color String \"\"","title":"Property"},{"location":"art-lang/#generate_file_header","text":"By default a capsule or class is translated to one header file ( .h ) and one implementation file ( .cpp ). Set this property to false to prevent generation of the header file, for example if you prefer to write it manually.","title":"generate_file_header"},{"location":"art-lang/#generate_file_impl","text":"By default a capsule or class is translated to one header file ( .h ) and one implementation file ( .cpp ). Set this property to false to prevent generation of the implementation file, for example if you prefer to write it manually.","title":"generate_file_impl"},{"location":"art-lang/#rule_config","text":"This property is used for configuring validation rules for an Art element. Read more about this here .","title":"rule_config"},{"location":"art-lang/#version","text":"Specifies the version of an Art element. You can use this to keep track of updates to types used in APIs (increase the version when the element changes).","title":"version"},{"location":"art-lang/#generate_descriptor","text":"By default a type descriptor will be generated for each class . The TargetRTS uses the type descriptor to know how to initialize, copy, move, destroy, encode or decode an instance of that class. Set this property to false for classes that don't need a type descriptor. Set it to manual if the class needs a type descriptor but you want to implement it manually rather than using the implementation that is generated by default. Note that even if you set this property to true so that a default type descriptor is generated, you can still override individual type descriptor functions for the class.","title":"generate_descriptor"},{"location":"art-lang/#kind","text":"By default a class is translated to a C++ class. You can use this property to instead translate it to a struct or union .","title":"kind"},{"location":"art-lang/#generate_class","text":"If set to false no C++ code will be generated for the class.","title":"generate_class"},{"location":"art-lang/#generate_statemachine","text":"If set to false code generation for the class' state machine will be suppressed. You can use this if the state machine is informal, and you prefer to implement it manually in another way.","title":"generate_statemachine"},{"location":"art-lang/#const_target_param_for_decode","text":"By default a decode function uses a non-const target parameter. This is because usually a decode implementation must call non-const functions on the decoded object to populate it with data from the decoding. However, if it doesn't need to call such functions you can set this property so that the target parameter is declared as const.","title":"const_target_param_for_decode"},{"location":"art-lang/#default_constructor_generate","text":"If set to false a default (i.e. parameterless) constructor will not be generated for the class.","title":"default_constructor_generate"},{"location":"art-lang/#default_constructor_explicit","text":"If set to true the default (i.e. parameterless) constructor will be declared as explicit.","title":"default_constructor_explicit"},{"location":"art-lang/#default_constructor_inline","text":"If set to true the default (i.e. parameterless) constructor will be declared as inline. It's implementation will then be generated into the header file.","title":"default_constructor_inline"},{"location":"art-lang/#default_constructor_default","text":"If set to true the default (i.e. parameterless) constructor will be declared as defaulted. This tells the compiler to synthesize a default constructor even if one normally would not be synthesized (for example because there is a user-defined constructor with parameters).","title":"default_constructor_default"},{"location":"art-lang/#default_constructor_delete","text":"If set to true the default (i.e. parameterless) constructor will be declared as deleted. This will cause the compiler to generate an error if it is invoked. This can be used for preventing objects of the class to be created.","title":"default_constructor_delete"},{"location":"art-lang/#default_constructor_visibility","text":"This property can be used for setting the visibility of the default (i.e. parameterless) constructor. By default it will be public but you can change it either to protected or private .","title":"default_constructor_visibility"},{"location":"art-lang/#registration","text":"This property specifies how to register an unwired port at runtime. The default is automatic which means the port will be registered automatically when the container capsule instance is initialized. The value automatic_locked has the same meaning but the registration will be \"locked\" so that any future attempt to deregister it, or register it under a different name, will fail. Set the property to application to programmatically register the port using the functions registerSPP() and registerSAP() respectively.","title":"registration"},{"location":"art-lang/#registration_name","text":"This property specifies the name to use when registering an unwired port at runtime. By default the port name is used, but it can be overridden using this property.","title":"registration_name"},{"location":"art-lang/#const_rtdata","text":"This property can be set on transitions where you need to modify the data it receives when it's triggered. If the property is set to false the rtdata parameter in the transition function will be non-const. It can then be modified, which for example can avoid copying received message data and instead move it using its move constructor or move assignment operator. [[rt::properties(const_rtdata=false)]] CurrentState -> NextState ` someAttr = std::move(*rtdata); // Avoid copying the message data object `; MyTransition: [[rt::properties(const_rtdata=false)]] OtherState -> NextState ` pC = std::move(*((MyClass*) rtdata)); // Avoid copying the message data object `; Note that the const_rtdata property appears in the Art syntax right after the transition name. If the transition has no name, it appears in the beginning of the transition declaration.","title":"const_rtdata"},{"location":"art-lang/#color","text":"Specifies which color to use for an Art element in a diagram. Colors should be specified as RGB values using 6 hexadecimal digits. For example, \"#ff00ff\". The Art text editor will help you set an appropriate color by means of a color picker. Note that you can also set the color directly from the diagram. Select a symbol or line and then set the color property using the Properties view (under \"Appearance\").","title":"color"},{"location":"art-lang/cpp-extensions/","text":"An Art file may contain code snippets at various places. The C++ code of such snippets is either an expression (e.g. a guard condition), statements (e.g. a transition effect) or declarations (e.g. types, functions, variables, etc). Most code snippets are just copied verbatimly to generated C++ files when translating an Art file to C++. However, some code snippets where declarations can be placed ( rt::decl and rt::impl ) are parsed and analyzed by the code generator. Certain C++ extensions (for example attributes applied on the declarations), in those code snippets are translated to additional C++ code by the code generator. This allows the code generator to augment the C++ code that you write with additional boiler-plate code. This chapter describes which C++ extensions that can be used, and what code is generated for them. Type Descriptor A type descriptor is meta data about a C++ type. The TargetRTS uses the type descriptor to know how to initialize, copy, move, destroy, encode and decode an instance of the type. Type descriptors for all primitive C++ types are included in the TargetRTS, but for other types you need to ensure a type descriptor is available if you plan to use it in a way where the TargetRTS needs it. Note Most types in your application may not need a type descriptor, and for some types it will be enough to provide a partial implementation of the type descriptor. Only implement what is necessary for how the type actually will be used. For example, if you send an instance of a type in an event between two capsules, and the instance is copied rather than moved, then the type descriptor needs a copy function but doesn't need a move function. And if you don't encode instances to strings (or decode them from strings) then the type descriptor doesn't need encode and decode functions. Always think about how a type will be used before deciding if it needs a type descriptor or not. C++ Implementation The C++ implementation of a type descriptor consists of four parts. In the code shown below we assume the type descriptor describes a type called \"MyType\". 1) A type descriptor object This is a variable typed by RTObject_class with a name that has the prefix \"RTType_\". It will be declared in the header file: extern const RTObject_class RTType_MyType; and implemented in the implementation file: const RTObject_class RTType_MyType = { // Initialization of RTObject_class corresponding to properties of MyType }; Member variables of RTObject_class store all information about the type, such as its name and byte size. Some of the member variables store pointers to type descriptor functions which the TargetRTS will call when it needs to do something with an instance of the type, for example copy or encode it. 2) Type descriptor functions These are functions with a certain prototype, each of which performs a specific action on an instance of the type. The type descriptor object stores pointers to these functions. For a partial type descriptor, some of these pointers will be nullptr and then the corresponding type descriptor function does not exist. Below is the list of type descriptor functions that can be part of a type descriptor: Name Prototype Purpose init void rtg_MyType_init(const RTObject_class* type, MyType* target) Initializes an instance of the type copy void rtg_MyType_copy(const RTObject_class* type, MyType* target, const MyType* source) Copies one instance of the type (source) to another (target) move void rtg_MyType_move(const RTObject_class* type, MyType* target, MyType* source) Moves one instance of the type (source) to another (target) destroy void rtg_MyType_destroy(const RTObject_class* type, MyType* target) Destroys an instance of the type encode void rtg_MyType_encode(const RTObject_class* type, const MyType* source, RTEncoding* coding) Encodes an instance of the type decode void rtg_MyType_decode(const RTObject_class* type, MyType* target, RTDecoding* coding) Decodes an instance of the type The encode function usually encodes the instance into a string representation, and the decode function usually parses the same string representation and creates an instance of the type from it. However, the functions use interface classes RTEncoding and RTDecoding from the TargetRTS which can be implemented in many different ways. Note also that you can globally disable the support for encoding and/or decoding by unsetting the macros OBJECT_ENCODE and OBJECT_DECODE respectively. 3) A type installer object Decoding functions typically need to look up a type descriptor from the name of the type. For example, if it finds the type name \"MyType\" in the string that it parses, it needs to find the type descriptor object for \"MyType\" so it can allocate memory for an instance of \"MyType\" and then initialize it. To facilitate this lookup the TargetRTS keeps a type descriptor registry. The purpose of the type installer object is to add the type descriptor to this registry. The C++ code looks like this: #if OBJECT_DECODE RTTypeInstaller rtg_MyType_installer( RTType_MyType ); #endif 4) A \"typed value\" struct This is a struct which encapsulates an untyped instance of the type and its type descriptor. Its name has the prefix \"RTTypedValue_\". The struct has constructors that enable construction from a reference to an instance of the type. The typed value struct is the glue between generated code and TargetRTS code. TargetRTS functions get an untyped instance together with the type descriptor, and the type descriptor provides all information it needs to know about the type. The typed value struct will be declared and implemented in the header file: struct RTTypedValue_MyType { const void * data; // Untyped pointer to an instance of MyType const RTObject_class * type; // Type descriptor for MyType const bool rValueRef = false; // Was the typed value struct created from an rvalue or lvalue reference to MyType? inline RTTypedValue_MyType( const MyType & rtg_value ) : data( &rtg_value ) , type( &RTType_MyType ) { } inline RTTypedValue_MyType( const MyType && rtg_value ) : data( &rtg_value ) , type( &RTType_Colors ) , rValueRef( true ) { } inline RTTypedValue_MyType( const MyType & rtg_value, const RTObject_class * rtg_type ) : data( &rtg_value ) , type( rtg_type ) { } inline RTTypedValue_MyType( const MyType && rtg_value, const RTObject_class * rtg_type ) : data( &rtg_value ) , type( rtg_type ) , rValueRef( true ) { } inline ~RTTypedValue_MyType( void ) { } }; Automatically Generated The code generator will automatically generate a type descriptor for a type if you mark it with the rt::auto_descriptor attribute. The generated type descriptor functions will get a default implementation that depends on the kind of type. If the default implementation is not appropriate for your type you can simply provide your own implementation of one or many type descriptor functions in an rt::impl code snippet. Note If you write your own type descriptor function it's important that its prototype exactly matches what is listed in this table . It's recommended to use Content Assist within the rt::impl code snippet to avoid typos and reduce typing effort. Here are some examples of using the rt::auto_descriptor attribute on different kinds of types: enum [[rt::auto_descriptor]] Status { Error, OK }; enum class [[rt::auto_descriptor]] Colors { Red, Green, Yellow }; struct [[rt::auto_descriptor]] Point { int x; int y; }; #include <string> typedef std::string [[rt::auto_descriptor]] MyString; #include <vector> using MyVector [[rt::auto_descriptor]] = std::vector<int>; An automatically generated type descriptor behaves like this: The init function for an enum will initialize it to the value of its first literal. For other types it will initialize the instance by invoking the parameterless constructor. The copy function for an enum just assigns the source parameter to the target parameter. For other types it will invoke the copy constructor. The move function is not available for an enum. For other types it will invoke the move constructor. The destroy function for an enum does nothing. For other types it will invoke the destructor. The encode function for an enum encodes it into an integer representation (0 for the first literal, 1 for the second, etc). For a typedef or type alias there is no default encode implementation. A structured type (struct or class) is encoded by calling put_struct on the RTEncoding . The TargetRTS provides encoding implementations that produce either JSON or a simple ASCII format. For types that have a default encode implementation, the decode implementation will read the encoded representation and create a corresponding instance of the type. For a typedef or type alias there is no default decode implementation. Here is an example of how to override the default implementation of a type descriptor (for an enum), and to provide a missing type descriptor function (for a typedef): [[rt::decl]] ` enum class [[rt::auto_descriptor]] Colors { Red, Green, Yellow }; #include <string> typedef std::string [[rt::auto_descriptor]] MyString; ` [[rt::impl]] ` static void rtg_Colors_init( const RTObject_class * type, Colors * target ) { *target = Colors::Green; // Make Green the default color instead of Red } #if OBJECT_ENCODE static int rtg_MyString_encode(const RTObject_class* type, const MyString* source, RTEncoding* coding ) { return coding->put_string(source->c_str()); // Encode as string literal } #endif ` Note that the default implementation of a type descriptor for a typedef or type alias makes the assumption that the typedefed or aliased type is a structured type which has both a parameterless constructor, a copy constructor and a move constructor. If this assumption is not correct, you need to write your own type descriptor functions, or even implement the whole type descriptor manually . Example You can find sample applications that use automatically generated type descriptors here: Automatically generated type descriptor for an enum Automatically generated type descriptor for an enum class with a custom encode function Automatically generated type descriptor for a struct Automatically generated type descriptor for a struct that contains another struct Automatically generated type descriptor for a typedef and type alias Manually Implemented If a type needs a type descriptor but the default implementation is not appropriate, and it's also not enough to simply override one or a few of the type descriptor functions with custom implementations, you can choose to implement the type descriptor manually. To do so you need to mark the type with the rt::manual_descriptor attribute. The code generator will then skip generation of the following parts of the type descriptor: The implementation of the type descriptor object. The variable will be declared in the header file, but no implementation will be generated. The type descriptor functions. If your type descriptor needs any of the functions you can implement them and reference them from the implementation of the type descriptor object. As an example assume we have a type alias for the Colors enum from the previous example. We only plan to use this type for standard enum encoding/decoding, but we want the Yellow color to be the default. Since the default type descriptor implementation for a type alias assumes the aliased type to be a structured type, we choose to do a manual implementation of the type descriptor instead of overriding several type descriptor functions (most of which we anyway won't need). [[rt::decl]] ` using MyColors [rt::manual_descriptor] = Colors; ` [[rt::impl]] ` static void rtg_MyColors_init( const RTObject_class * type, MyColors * target ) { *target = Colors::Yellow; // Default color } // Manual type descriptor implementation const RTObject_class RTType_MyColors = { nullptr , nullptr , \"MyColors\" , 0 /* RTVersionId */ , sizeof( MyColors ) , reinterpret_cast< RTInitFunction > ( rtg_MyColors_init ) , nullptr #if RT_VERSION_NUMBER >= 7105 , nullptr #endif #if OBJECT_DECODE , RTenum_decode #endif #if OBJECT_ENCODE , RTenum_encode #endif , RTnop_destroy , 0 , nullptr }; ` Use the Content Assist template \"New Type Descriptor Object\" to avoid typing all code manually. Example You can find a sample application that uses a manually implemented type descriptor here . Field Descriptor A type descriptor for a structured type (class or struct) contains information about the member variables (a.k.a fields) of the type. This information is stored in a field descriptor object typed by the TargetRTS class RTFieldDescriptor . If the structured type only contains public member variables, the code generator can generate the field descriptor as a global object in the implementation file. However, if at least one member variable is either private or protected, you need to declare the type descriptor inside the type, as a public member variable. The reason is that the byte offset of each member variable is stored in the field descriptor, and computing this offset requires access to the member variable from the field descriptor. Below is an example of a struct and a class. The struct only contains public member variables and hence it's not necessary to declare the field descriptor manually. However, since the class contains a private member variable, we need to declare a field descriptor for it. [[rt::decl]] ` struct [[rt::auto_descriptor]] Point { int x; int y; }; class [[rt::auto_descriptor]] DataPoint : public Point { private: long data; public: static const RTFieldDescriptor rtg_DataPoint_fields[]; }; ` A field descriptor member variable must have the name rtg_<type>_fields , where <type> is the name of the structured type. Use Content Assist to create a class or struct that contains a field descriptor. Example You can find a sample application where a field descriptor is declared here . Inheritance If a class or struct inherits from another class or struct, as in the example above, then the type descriptor of the derived type will have a reference to the type descriptor of the base type. In this case both types need to have a type descriptor. A type descriptor can at most reference one base type descriptor (a.k.a. a super descriptor) which means that only single inheritance is supported for automatically generated type descriptors. If you use multiple inheritance you have to write a manual type descriptor for the derived type. Example You can find a sample application that uses an automatically implemented type descriptor for a class that inherits from another class here .","title":"C++ Extensions"},{"location":"art-lang/cpp-extensions/#type-descriptor","text":"A type descriptor is meta data about a C++ type. The TargetRTS uses the type descriptor to know how to initialize, copy, move, destroy, encode and decode an instance of the type. Type descriptors for all primitive C++ types are included in the TargetRTS, but for other types you need to ensure a type descriptor is available if you plan to use it in a way where the TargetRTS needs it. Note Most types in your application may not need a type descriptor, and for some types it will be enough to provide a partial implementation of the type descriptor. Only implement what is necessary for how the type actually will be used. For example, if you send an instance of a type in an event between two capsules, and the instance is copied rather than moved, then the type descriptor needs a copy function but doesn't need a move function. And if you don't encode instances to strings (or decode them from strings) then the type descriptor doesn't need encode and decode functions. Always think about how a type will be used before deciding if it needs a type descriptor or not.","title":"Type Descriptor"},{"location":"art-lang/cpp-extensions/#c-implementation","text":"The C++ implementation of a type descriptor consists of four parts. In the code shown below we assume the type descriptor describes a type called \"MyType\". 1) A type descriptor object This is a variable typed by RTObject_class with a name that has the prefix \"RTType_\". It will be declared in the header file: extern const RTObject_class RTType_MyType; and implemented in the implementation file: const RTObject_class RTType_MyType = { // Initialization of RTObject_class corresponding to properties of MyType }; Member variables of RTObject_class store all information about the type, such as its name and byte size. Some of the member variables store pointers to type descriptor functions which the TargetRTS will call when it needs to do something with an instance of the type, for example copy or encode it. 2) Type descriptor functions These are functions with a certain prototype, each of which performs a specific action on an instance of the type. The type descriptor object stores pointers to these functions. For a partial type descriptor, some of these pointers will be nullptr and then the corresponding type descriptor function does not exist. Below is the list of type descriptor functions that can be part of a type descriptor: Name Prototype Purpose init void rtg_MyType_init(const RTObject_class* type, MyType* target) Initializes an instance of the type copy void rtg_MyType_copy(const RTObject_class* type, MyType* target, const MyType* source) Copies one instance of the type (source) to another (target) move void rtg_MyType_move(const RTObject_class* type, MyType* target, MyType* source) Moves one instance of the type (source) to another (target) destroy void rtg_MyType_destroy(const RTObject_class* type, MyType* target) Destroys an instance of the type encode void rtg_MyType_encode(const RTObject_class* type, const MyType* source, RTEncoding* coding) Encodes an instance of the type decode void rtg_MyType_decode(const RTObject_class* type, MyType* target, RTDecoding* coding) Decodes an instance of the type The encode function usually encodes the instance into a string representation, and the decode function usually parses the same string representation and creates an instance of the type from it. However, the functions use interface classes RTEncoding and RTDecoding from the TargetRTS which can be implemented in many different ways. Note also that you can globally disable the support for encoding and/or decoding by unsetting the macros OBJECT_ENCODE and OBJECT_DECODE respectively. 3) A type installer object Decoding functions typically need to look up a type descriptor from the name of the type. For example, if it finds the type name \"MyType\" in the string that it parses, it needs to find the type descriptor object for \"MyType\" so it can allocate memory for an instance of \"MyType\" and then initialize it. To facilitate this lookup the TargetRTS keeps a type descriptor registry. The purpose of the type installer object is to add the type descriptor to this registry. The C++ code looks like this: #if OBJECT_DECODE RTTypeInstaller rtg_MyType_installer( RTType_MyType ); #endif 4) A \"typed value\" struct This is a struct which encapsulates an untyped instance of the type and its type descriptor. Its name has the prefix \"RTTypedValue_\". The struct has constructors that enable construction from a reference to an instance of the type. The typed value struct is the glue between generated code and TargetRTS code. TargetRTS functions get an untyped instance together with the type descriptor, and the type descriptor provides all information it needs to know about the type. The typed value struct will be declared and implemented in the header file: struct RTTypedValue_MyType { const void * data; // Untyped pointer to an instance of MyType const RTObject_class * type; // Type descriptor for MyType const bool rValueRef = false; // Was the typed value struct created from an rvalue or lvalue reference to MyType? inline RTTypedValue_MyType( const MyType & rtg_value ) : data( &rtg_value ) , type( &RTType_MyType ) { } inline RTTypedValue_MyType( const MyType && rtg_value ) : data( &rtg_value ) , type( &RTType_Colors ) , rValueRef( true ) { } inline RTTypedValue_MyType( const MyType & rtg_value, const RTObject_class * rtg_type ) : data( &rtg_value ) , type( rtg_type ) { } inline RTTypedValue_MyType( const MyType && rtg_value, const RTObject_class * rtg_type ) : data( &rtg_value ) , type( rtg_type ) , rValueRef( true ) { } inline ~RTTypedValue_MyType( void ) { } };","title":"C++ Implementation"},{"location":"art-lang/cpp-extensions/#automatically-generated","text":"The code generator will automatically generate a type descriptor for a type if you mark it with the rt::auto_descriptor attribute. The generated type descriptor functions will get a default implementation that depends on the kind of type. If the default implementation is not appropriate for your type you can simply provide your own implementation of one or many type descriptor functions in an rt::impl code snippet. Note If you write your own type descriptor function it's important that its prototype exactly matches what is listed in this table . It's recommended to use Content Assist within the rt::impl code snippet to avoid typos and reduce typing effort. Here are some examples of using the rt::auto_descriptor attribute on different kinds of types: enum [[rt::auto_descriptor]] Status { Error, OK }; enum class [[rt::auto_descriptor]] Colors { Red, Green, Yellow }; struct [[rt::auto_descriptor]] Point { int x; int y; }; #include <string> typedef std::string [[rt::auto_descriptor]] MyString; #include <vector> using MyVector [[rt::auto_descriptor]] = std::vector<int>; An automatically generated type descriptor behaves like this: The init function for an enum will initialize it to the value of its first literal. For other types it will initialize the instance by invoking the parameterless constructor. The copy function for an enum just assigns the source parameter to the target parameter. For other types it will invoke the copy constructor. The move function is not available for an enum. For other types it will invoke the move constructor. The destroy function for an enum does nothing. For other types it will invoke the destructor. The encode function for an enum encodes it into an integer representation (0 for the first literal, 1 for the second, etc). For a typedef or type alias there is no default encode implementation. A structured type (struct or class) is encoded by calling put_struct on the RTEncoding . The TargetRTS provides encoding implementations that produce either JSON or a simple ASCII format. For types that have a default encode implementation, the decode implementation will read the encoded representation and create a corresponding instance of the type. For a typedef or type alias there is no default decode implementation. Here is an example of how to override the default implementation of a type descriptor (for an enum), and to provide a missing type descriptor function (for a typedef): [[rt::decl]] ` enum class [[rt::auto_descriptor]] Colors { Red, Green, Yellow }; #include <string> typedef std::string [[rt::auto_descriptor]] MyString; ` [[rt::impl]] ` static void rtg_Colors_init( const RTObject_class * type, Colors * target ) { *target = Colors::Green; // Make Green the default color instead of Red } #if OBJECT_ENCODE static int rtg_MyString_encode(const RTObject_class* type, const MyString* source, RTEncoding* coding ) { return coding->put_string(source->c_str()); // Encode as string literal } #endif ` Note that the default implementation of a type descriptor for a typedef or type alias makes the assumption that the typedefed or aliased type is a structured type which has both a parameterless constructor, a copy constructor and a move constructor. If this assumption is not correct, you need to write your own type descriptor functions, or even implement the whole type descriptor manually . Example You can find sample applications that use automatically generated type descriptors here: Automatically generated type descriptor for an enum Automatically generated type descriptor for an enum class with a custom encode function Automatically generated type descriptor for a struct Automatically generated type descriptor for a struct that contains another struct Automatically generated type descriptor for a typedef and type alias","title":"Automatically Generated"},{"location":"art-lang/cpp-extensions/#manually-implemented","text":"If a type needs a type descriptor but the default implementation is not appropriate, and it's also not enough to simply override one or a few of the type descriptor functions with custom implementations, you can choose to implement the type descriptor manually. To do so you need to mark the type with the rt::manual_descriptor attribute. The code generator will then skip generation of the following parts of the type descriptor: The implementation of the type descriptor object. The variable will be declared in the header file, but no implementation will be generated. The type descriptor functions. If your type descriptor needs any of the functions you can implement them and reference them from the implementation of the type descriptor object. As an example assume we have a type alias for the Colors enum from the previous example. We only plan to use this type for standard enum encoding/decoding, but we want the Yellow color to be the default. Since the default type descriptor implementation for a type alias assumes the aliased type to be a structured type, we choose to do a manual implementation of the type descriptor instead of overriding several type descriptor functions (most of which we anyway won't need). [[rt::decl]] ` using MyColors [rt::manual_descriptor] = Colors; ` [[rt::impl]] ` static void rtg_MyColors_init( const RTObject_class * type, MyColors * target ) { *target = Colors::Yellow; // Default color } // Manual type descriptor implementation const RTObject_class RTType_MyColors = { nullptr , nullptr , \"MyColors\" , 0 /* RTVersionId */ , sizeof( MyColors ) , reinterpret_cast< RTInitFunction > ( rtg_MyColors_init ) , nullptr #if RT_VERSION_NUMBER >= 7105 , nullptr #endif #if OBJECT_DECODE , RTenum_decode #endif #if OBJECT_ENCODE , RTenum_encode #endif , RTnop_destroy , 0 , nullptr }; ` Use the Content Assist template \"New Type Descriptor Object\" to avoid typing all code manually. Example You can find a sample application that uses a manually implemented type descriptor here .","title":"Manually Implemented"},{"location":"art-lang/cpp-extensions/#field-descriptor","text":"A type descriptor for a structured type (class or struct) contains information about the member variables (a.k.a fields) of the type. This information is stored in a field descriptor object typed by the TargetRTS class RTFieldDescriptor . If the structured type only contains public member variables, the code generator can generate the field descriptor as a global object in the implementation file. However, if at least one member variable is either private or protected, you need to declare the type descriptor inside the type, as a public member variable. The reason is that the byte offset of each member variable is stored in the field descriptor, and computing this offset requires access to the member variable from the field descriptor. Below is an example of a struct and a class. The struct only contains public member variables and hence it's not necessary to declare the field descriptor manually. However, since the class contains a private member variable, we need to declare a field descriptor for it. [[rt::decl]] ` struct [[rt::auto_descriptor]] Point { int x; int y; }; class [[rt::auto_descriptor]] DataPoint : public Point { private: long data; public: static const RTFieldDescriptor rtg_DataPoint_fields[]; }; ` A field descriptor member variable must have the name rtg_<type>_fields , where <type> is the name of the structured type. Use Content Assist to create a class or struct that contains a field descriptor. Example You can find a sample application where a field descriptor is declared here .","title":"Field Descriptor"},{"location":"art-lang/cpp-extensions/#inheritance","text":"If a class or struct inherits from another class or struct, as in the example above, then the type descriptor of the derived type will have a reference to the type descriptor of the base type. In this case both types need to have a type descriptor. A type descriptor can at most reference one base type descriptor (a.k.a. a super descriptor) which means that only single inheritance is supported for automatically generated type descriptors. If you use multiple inheritance you have to write a manual type descriptor for the derived type. Example You can find a sample application that uses an automatically implemented type descriptor for a class that inherits from another class here .","title":"Inheritance"},{"location":"building/","text":"Art and C++ files can be built into applications or libraries. The build process consists of three steps: Generate source files In this step Art files are translated to C++ source files. Generate a make file A make file for building generated C++ code (and possibly also other C++ code) is generated. Run make to generate binaries A make tool is invoked for building an executable or library from the generated make file. All these steps require information which is stored in a transformation configuration (TC for short). It is a text file which contains various properties needed for translating Art elements to C++ code, for generating the make file, and finally for launching the make tool. You can have more than one TC in your workspace, but at most one TC in each workspace folder can be active . Set a TC as active by right-clicking on it and perform the command Set as Active . An active TC is marked with a checkmark. Once there is an active TC in a workspace folder, the first and second steps (generation of C++ source files and make file) will happen automatically for all Art files contained in that workspace folder. The files that get generated are placed in its own workspace folder as specified by the targetFolder property of the TC. The C++ code in this target workspace folder is then incrementally and automatically updated as soon as any of these Art files are changed. Also the make file (which by default is placed in a subfolder called default in the target workspace folder) gets updated when needed. Below is an example of a simple target workspace folder. To perform the third step (running make to generate binaries) you can simply go to the target folder in the Terminal and invoke the command make . Alternatively you can use the TC context menu command Build (see below ). TC Context Menu Commands The context menu of a TC provides a few useful commands that automate some of the steps mentioned above: Build This command first generates C++ code and a make file for the TC, and then runs the make tool on the generated make file. Note, however, that this command does not set the TC as active. If you plan to change code snippets in generated code you must set the TC as active yourself. Run First builds the TC, and then attempts to launch the executable that is produced. The executable is launched in a non-debug mode by specifying the launch argument -URTS_DEBUG=quit . If you instead want to launch the executable for debugging it you can go to the Terminal and manually launch it from there without any extra arguments. Note that if your TC creates a library rather than an executable, then this command will still build the TC, but will then give an error message since there is no executable to run. Note For a more flexible way of launching a built executable, consider using a launch configuration . Clean Removes the target workspace folder produced when building a TC. This means that all generated C++ code, the make file, as well as any produced binaries will be removed. If you only want to remove the binaries you can instead go to the Terminal and invoke make clean to clean using the make file. If you build a TC and at least one error exists in the TC itself, in prerequisites TCs or in any of the Art files that will be built, then a dialog will ask if you want to cancel the build (recommended) or proceed anyway (only do this if you are confident the errors are safe to ignore). Use the setting code-rt.build.cancelOnError to suppress this dialog. Build Messages When you use the Build or Run commands on a TC, messages will be printed in two places depending on what kind of message it is: The Terminal view. Messages produced when compiling and linking the generated C++ code will be printed here, for example compilation errors. In many cases such messages will have a reference to a generated C++ file which you can Ctrl -click to open. In case of Run , messages printed by the running executable will also be printed in the Terminal view. To terminate a running executable you can press Ctrl + C in the Terminal view. The Art Build output channel. All other build messages are printed here, for example messages emitted by the C++ code generator. In some cases these messages will have a reference to a file (e.g. an input TC or Art file), and sometimes even to an element within that file. You can Ctrl -click these to open the file and navigate to the element. In case the build fails (e.g. because of compilation errors) a hyperlink will be present for opening the Terminal view where the errors that caused the build to fail can be found. Navigation Between Art and Generated C++ You can navigate from an element in an Art file to the corresponding element in the C++ file that gets generated from that Art file. Use the context menu that appears when you right-click on an element in an Art file and invoke the command Open Generated Code . If C++ code has not yet been generated for the Art file, for example because no active TC has been set, navigation will fail with an error message. When navigating to generated C++ code an attempt is made to put the cursor as close as possible to the relevant C++ element. However, when there is no C++ element that directly corresponds to the selected Art element, the cursor may instead be placed on a container C++ element. If there are more than one C++ element generated from a single Art element, you will be prompted for where to navigate. For example: For C++ code snippets you can as an alternative perform the navigation using a tooltip that appears when you hover over the code snippet: If the cursor is within the C++ code snippet when navigating, the cursor will be set at the same place in the generated C++ code. This is convenient if you start to edit a code snippet in an Art file but later realize that you want to edit it in the generated C++ code instead. You can also navigate in the other direction, i.e. from generated C++ code to the source Art file. This is described below in Making Changes in Generated C++ . Making Changes in Generated C++ C++ code snippets that are embedded in the Art file will be enclosed by special comments in the generated C++ file. You can edit such code snippets in a generated C++ file. When you save the file your changes will be automatically propagated back to the Art file. Here is an example of what a code snippet may look like in the generated C++ code: //{{{USR file:///c:/code-realtime/workspaces/demoWorkspace/HelloWorld.art#::HelloWorld::<TopStateMachine>::<TriggeredTransition_5>::<Effect> std::cout << \"Hello World!\" << std::endl; context()->abort(); //}}}USR The comment contains information about the source Art file and the Art element in that file that contains the code snippet. Warning Only make edits on the lines within the special code snippet comments. If you edit outside the comment those edits will be lost the next time the file gets regenerated. And if you change the comment itself, the propagation of changes back to the Art file will no longer work correctly. One very common scenario where it's useful to change a code snippet in a generated file is when there is a compilation error reported in the code snippet. Navigating from that compilation error will take you to the code snippet in the generated file, and it's convenient to directly fix the problem there. Another scenario is when you write new code in such a code snippet and want to take advantage of the editing support for C++ that is provided by your IDE, and/or need to see the full C++ context of the edited code snippet. You can navigate from the code snippet in the Art file to the code snippet in the generated file as described above . Sometimes you may need to navigate in the other direction, i.e. from a code snippet in the generated C++ code to the source Art file. For example, when editing the effect code of a transition it can be useful to look at that transition in its state machine (either in the Art file or in a state diagram). You can Ctrl -click the hyperlink of the USR-comment to perform this navigation as shown in the picture below. You can make edits in multiple code snippets in a generated file. When the file is saved all edited code snippets will be automatically propagated back to the Art file. Warning Code snippets in Art files can only be updated when there is an active TC set. Changes made in generated code snippets will be lost the next time they are generated, unless you have set the TC as active. To prevent this, always make sure the TC is set as active before you make any changes in generated files. Pay attention to the status bar in the bottom left corner when you save a generated file. If you know at least one code snippet was modified, but still get the message shown below: then you can know the changes failed to propagate to the Art file. If the update was successful you should instead get a message that tells how many code snippets that were updated. For example: Building from the Command Line You can build a TC from the command line by using the Art Compiler .","title":"Building"},{"location":"building/#tc-context-menu-commands","text":"The context menu of a TC provides a few useful commands that automate some of the steps mentioned above: Build This command first generates C++ code and a make file for the TC, and then runs the make tool on the generated make file. Note, however, that this command does not set the TC as active. If you plan to change code snippets in generated code you must set the TC as active yourself. Run First builds the TC, and then attempts to launch the executable that is produced. The executable is launched in a non-debug mode by specifying the launch argument -URTS_DEBUG=quit . If you instead want to launch the executable for debugging it you can go to the Terminal and manually launch it from there without any extra arguments. Note that if your TC creates a library rather than an executable, then this command will still build the TC, but will then give an error message since there is no executable to run. Note For a more flexible way of launching a built executable, consider using a launch configuration . Clean Removes the target workspace folder produced when building a TC. This means that all generated C++ code, the make file, as well as any produced binaries will be removed. If you only want to remove the binaries you can instead go to the Terminal and invoke make clean to clean using the make file. If you build a TC and at least one error exists in the TC itself, in prerequisites TCs or in any of the Art files that will be built, then a dialog will ask if you want to cancel the build (recommended) or proceed anyway (only do this if you are confident the errors are safe to ignore). Use the setting code-rt.build.cancelOnError to suppress this dialog.","title":"TC Context Menu Commands"},{"location":"building/#build-messages","text":"When you use the Build or Run commands on a TC, messages will be printed in two places depending on what kind of message it is: The Terminal view. Messages produced when compiling and linking the generated C++ code will be printed here, for example compilation errors. In many cases such messages will have a reference to a generated C++ file which you can Ctrl -click to open. In case of Run , messages printed by the running executable will also be printed in the Terminal view. To terminate a running executable you can press Ctrl + C in the Terminal view. The Art Build output channel. All other build messages are printed here, for example messages emitted by the C++ code generator. In some cases these messages will have a reference to a file (e.g. an input TC or Art file), and sometimes even to an element within that file. You can Ctrl -click these to open the file and navigate to the element. In case the build fails (e.g. because of compilation errors) a hyperlink will be present for opening the Terminal view where the errors that caused the build to fail can be found.","title":"Build Messages"},{"location":"building/#navigation-between-art-and-generated-c","text":"You can navigate from an element in an Art file to the corresponding element in the C++ file that gets generated from that Art file. Use the context menu that appears when you right-click on an element in an Art file and invoke the command Open Generated Code . If C++ code has not yet been generated for the Art file, for example because no active TC has been set, navigation will fail with an error message. When navigating to generated C++ code an attempt is made to put the cursor as close as possible to the relevant C++ element. However, when there is no C++ element that directly corresponds to the selected Art element, the cursor may instead be placed on a container C++ element. If there are more than one C++ element generated from a single Art element, you will be prompted for where to navigate. For example: For C++ code snippets you can as an alternative perform the navigation using a tooltip that appears when you hover over the code snippet: If the cursor is within the C++ code snippet when navigating, the cursor will be set at the same place in the generated C++ code. This is convenient if you start to edit a code snippet in an Art file but later realize that you want to edit it in the generated C++ code instead. You can also navigate in the other direction, i.e. from generated C++ code to the source Art file. This is described below in Making Changes in Generated C++ .","title":"Navigation Between Art and Generated C++"},{"location":"building/#making-changes-in-generated-c","text":"C++ code snippets that are embedded in the Art file will be enclosed by special comments in the generated C++ file. You can edit such code snippets in a generated C++ file. When you save the file your changes will be automatically propagated back to the Art file. Here is an example of what a code snippet may look like in the generated C++ code: //{{{USR file:///c:/code-realtime/workspaces/demoWorkspace/HelloWorld.art#::HelloWorld::<TopStateMachine>::<TriggeredTransition_5>::<Effect> std::cout << \"Hello World!\" << std::endl; context()->abort(); //}}}USR The comment contains information about the source Art file and the Art element in that file that contains the code snippet. Warning Only make edits on the lines within the special code snippet comments. If you edit outside the comment those edits will be lost the next time the file gets regenerated. And if you change the comment itself, the propagation of changes back to the Art file will no longer work correctly. One very common scenario where it's useful to change a code snippet in a generated file is when there is a compilation error reported in the code snippet. Navigating from that compilation error will take you to the code snippet in the generated file, and it's convenient to directly fix the problem there. Another scenario is when you write new code in such a code snippet and want to take advantage of the editing support for C++ that is provided by your IDE, and/or need to see the full C++ context of the edited code snippet. You can navigate from the code snippet in the Art file to the code snippet in the generated file as described above . Sometimes you may need to navigate in the other direction, i.e. from a code snippet in the generated C++ code to the source Art file. For example, when editing the effect code of a transition it can be useful to look at that transition in its state machine (either in the Art file or in a state diagram). You can Ctrl -click the hyperlink of the USR-comment to perform this navigation as shown in the picture below. You can make edits in multiple code snippets in a generated file. When the file is saved all edited code snippets will be automatically propagated back to the Art file. Warning Code snippets in Art files can only be updated when there is an active TC set. Changes made in generated code snippets will be lost the next time they are generated, unless you have set the TC as active. To prevent this, always make sure the TC is set as active before you make any changes in generated files. Pay attention to the status bar in the bottom left corner when you save a generated file. If you know at least one code snippet was modified, but still get the message shown below: then you can know the changes failed to propagate to the Art file. If the update was successful you should instead get a message that tells how many code snippets that were updated. For example:","title":"Making Changes in Generated C++"},{"location":"building/#building-from-the-command-line","text":"You can build a TC from the command line by using the Art Compiler .","title":"Building from the Command Line"},{"location":"building/art-compiler/","text":"The Art Compiler is a stand-alone tool which can be used for building a TC from the command-line. Using this tool makes it possible to integrate the translation of Art files into C++, and compilation of that C++ code, into your automated build process. Location and Launching The Art Compiler is located in the bin folder of the Code RealTime installation. It's a JAR file with the name artcompiler.jar . Tip The folder where the Art Compiler is located can be seen from the message that is printed in the Art Server output channel when the Code RealTime extension is activated. It's located in the same folder as the Art Language Server JAR file, called artserver.jar . To launch the Art Compiler you need a Java Virtual Machine (JVM). You should use the same JVM as is used for running the Art Language Server (see Setup Java ). Launch the Art Compiler with the java command like this: java <JVM options> -jar <extension-path>/bin/artcompiler.jar <Art Compiler options> Often you don't need to use any JVM option, but if the application is huge you may need to increase the memory of the JVM. Refer to the documentation of your JVM for a list of available JVM options. You may want to use the same JVM options as are used when launching the Art Language Server (see the setting code-rt.languageServer.jvmArgs ), but it's not required to do so. To test that the Art Compiler can be successfully launched you can try to invoke it without any arguments. You should see an output similar to the below: C:\\openjdk-17\\bin\\java -jar C:\\Users\\MATTIAS.MOHLIN\\testarea\\install\\VSCode\\data\\extensions\\hcltechnologies.code-realtime-ce\\bin\\artcompiler.jar 10:24:53 : INFO : Art Compiler 1.1.0-20231212_1212 10:24:53 : INFO : Copyright (C) HCL Technologies Ltd. 2022, 2023. 10:24:54 : INFO : Arguments: Usage: java -jar artcompiler.jar <options> Options: LIST OF OPTIONS All options with argument can be used in format <option> <argument> or <option>=<argument>. Art Compiler Options The Art Compiler accepts options in the form of command-line arguments to artcompiler.jar that start with single or double dash ( - or -- ). Many options can take an argument which then needs to be of the correct type (Boolean, Path etc). You can specify the argument for an option either like this <option> <argument> or like this <option>=<argument> Below is a table that lists all options that are available for the Art Compiler. Each option is described in a section of its own below the table. Option Argument Type buildConfig String buildVariants Path cwd Path generate N/A help N/A out Path ruleConfig String tc Path version N/A buildConfig A build configuration is useful when you want to build a TC that uses build variants . It provides values for build variant settings and hence specifies a certain variant of the application to be built. Read more about build configurations here . buildVariants Specifies a Build Variants script to use for the build. Read more about build variants here . cwd Set the current working directory. By default this is the location from which you launch the Art Compiler. If you use a relative path in options that take a path as argument, such as --out or --tc , the path will be resolved against the current working directory. generate By default the Art Compiler will generate C++ files and a make file, and then build the C++ code by invoking make on the make file. If you set this option then only the files will be generated, but make will not be invoked. Usually the running of make is what takes most time when building a TC, so if you for example only is interested in getting the generated files you can save time by setting this option. help Use this option to print information about the version and all available options . This is the same information as is printed if launching the Art Compiler without any options. If this option is passed, all other options are ignored. out Set the output folder which controls where generated files will be placed. By default it is set to the folder that contains the folder containing the built TC . It hence by default corresponds to the workspace folder used when building from the UI. If you want to place generated files in a different location when building from the command-line you can set this option to another folder. Relative paths specified as targetFolder in TCs will be resolved against the specified --out folder. ruleConfig Specifies which validation rules that should be enabled, and what severity the problems they find should have. Rules are configured using the same syntax as is used for the rule_config property in an Art file. For example: --ruleConfig \"W0009,X7001\" Read more about how to configure validation rules here . tc Specifies the TC to build. This option is mandatory, unless you only pass the help or version options. version Use this option to print the version of the Art Compiler. This version is the same as is used for the Code RealTime extension and can also be seen in the file CHANGELOG.md in the Code RealTime installation folder. If this option is passed, all other options are ignored. Art Compiler Steps and Messages The Art Compiler performs its work using several sequential steps. During each step messages can be printed with a severity that is either INFO, WARNING or ERROR. Messages are printed to stdout with a time stamp. If at least one error is reported when performing one of the steps, the Art Compiler stops and doesn't proceed with the next step. The following steps are performed: The provided options are parsed and validated The TC is evaluated, to compute the values for all TC properties that will be used for the build The Art files are loaded, including RTPredefined.art from the Code RealTime installation The TC is validated, to detect errors and inconsistencies in TC property values The Art files are validated, to check for semantic problems The Art files are transformed to C++. Generated C++ files and a make file for building them are written to disk. A make tool is invoked on the make file for building the C++ code into a library or executable Note that the last step is skipped if the generate option is set. Process Return Value The Art Compiler exits with a zero return value if no errors occur when building the TC. The value will be non-zero in case an error occured and in that case there will also be a printout explaining why the build failed. You can for example use the Art Compiler process return value if you launch it from a script that needs to know if the build was successful or not.","title":"Art Compiler"},{"location":"building/art-compiler/#location-and-launching","text":"The Art Compiler is located in the bin folder of the Code RealTime installation. It's a JAR file with the name artcompiler.jar . Tip The folder where the Art Compiler is located can be seen from the message that is printed in the Art Server output channel when the Code RealTime extension is activated. It's located in the same folder as the Art Language Server JAR file, called artserver.jar . To launch the Art Compiler you need a Java Virtual Machine (JVM). You should use the same JVM as is used for running the Art Language Server (see Setup Java ). Launch the Art Compiler with the java command like this: java <JVM options> -jar <extension-path>/bin/artcompiler.jar <Art Compiler options> Often you don't need to use any JVM option, but if the application is huge you may need to increase the memory of the JVM. Refer to the documentation of your JVM for a list of available JVM options. You may want to use the same JVM options as are used when launching the Art Language Server (see the setting code-rt.languageServer.jvmArgs ), but it's not required to do so. To test that the Art Compiler can be successfully launched you can try to invoke it without any arguments. You should see an output similar to the below: C:\\openjdk-17\\bin\\java -jar C:\\Users\\MATTIAS.MOHLIN\\testarea\\install\\VSCode\\data\\extensions\\hcltechnologies.code-realtime-ce\\bin\\artcompiler.jar 10:24:53 : INFO : Art Compiler 1.1.0-20231212_1212 10:24:53 : INFO : Copyright (C) HCL Technologies Ltd. 2022, 2023. 10:24:54 : INFO : Arguments: Usage: java -jar artcompiler.jar <options> Options: LIST OF OPTIONS All options with argument can be used in format <option> <argument> or <option>=<argument>.","title":"Location and Launching"},{"location":"building/art-compiler/#art-compiler-options","text":"The Art Compiler accepts options in the form of command-line arguments to artcompiler.jar that start with single or double dash ( - or -- ). Many options can take an argument which then needs to be of the correct type (Boolean, Path etc). You can specify the argument for an option either like this <option> <argument> or like this <option>=<argument> Below is a table that lists all options that are available for the Art Compiler. Each option is described in a section of its own below the table. Option Argument Type buildConfig String buildVariants Path cwd Path generate N/A help N/A out Path ruleConfig String tc Path version N/A","title":"Art Compiler Options"},{"location":"building/art-compiler/#buildconfig","text":"A build configuration is useful when you want to build a TC that uses build variants . It provides values for build variant settings and hence specifies a certain variant of the application to be built. Read more about build configurations here .","title":"buildConfig"},{"location":"building/art-compiler/#buildvariants","text":"Specifies a Build Variants script to use for the build. Read more about build variants here .","title":"buildVariants"},{"location":"building/art-compiler/#cwd","text":"Set the current working directory. By default this is the location from which you launch the Art Compiler. If you use a relative path in options that take a path as argument, such as --out or --tc , the path will be resolved against the current working directory.","title":"cwd"},{"location":"building/art-compiler/#generate","text":"By default the Art Compiler will generate C++ files and a make file, and then build the C++ code by invoking make on the make file. If you set this option then only the files will be generated, but make will not be invoked. Usually the running of make is what takes most time when building a TC, so if you for example only is interested in getting the generated files you can save time by setting this option.","title":"generate"},{"location":"building/art-compiler/#help","text":"Use this option to print information about the version and all available options . This is the same information as is printed if launching the Art Compiler without any options. If this option is passed, all other options are ignored.","title":"help"},{"location":"building/art-compiler/#out","text":"Set the output folder which controls where generated files will be placed. By default it is set to the folder that contains the folder containing the built TC . It hence by default corresponds to the workspace folder used when building from the UI. If you want to place generated files in a different location when building from the command-line you can set this option to another folder. Relative paths specified as targetFolder in TCs will be resolved against the specified --out folder.","title":"out"},{"location":"building/art-compiler/#ruleconfig","text":"Specifies which validation rules that should be enabled, and what severity the problems they find should have. Rules are configured using the same syntax as is used for the rule_config property in an Art file. For example: --ruleConfig \"W0009,X7001\" Read more about how to configure validation rules here .","title":"ruleConfig"},{"location":"building/art-compiler/#tc","text":"Specifies the TC to build. This option is mandatory, unless you only pass the help or version options.","title":"tc"},{"location":"building/art-compiler/#version","text":"Use this option to print the version of the Art Compiler. This version is the same as is used for the Code RealTime extension and can also be seen in the file CHANGELOG.md in the Code RealTime installation folder. If this option is passed, all other options are ignored.","title":"version"},{"location":"building/art-compiler/#art-compiler-steps-and-messages","text":"The Art Compiler performs its work using several sequential steps. During each step messages can be printed with a severity that is either INFO, WARNING or ERROR. Messages are printed to stdout with a time stamp. If at least one error is reported when performing one of the steps, the Art Compiler stops and doesn't proceed with the next step. The following steps are performed: The provided options are parsed and validated The TC is evaluated, to compute the values for all TC properties that will be used for the build The Art files are loaded, including RTPredefined.art from the Code RealTime installation The TC is validated, to detect errors and inconsistencies in TC property values The Art files are validated, to check for semantic problems The Art files are transformed to C++. Generated C++ files and a make file for building them are written to disk. A make tool is invoked on the make file for building the C++ code into a library or executable Note that the last step is skipped if the generate option is set.","title":"Art Compiler Steps and Messages"},{"location":"building/art-compiler/#process-return-value","text":"The Art Compiler exits with a zero return value if no errors occur when building the TC. The value will be non-zero in case an error occured and in that case there will also be a printout explaining why the build failed. You can for example use the Art Compiler process return value if you launch it from a script that needs to know if the build was successful or not.","title":"Process Return Value"},{"location":"building/build-variants/","text":"There is often a need to build several variants of the same application. For example: Create a debug versus release build Add special instrumentation in order to detect run-time errors such as memory leaks Build for multiple target platforms A variant of an application may often only use slightly different build settings (for example, setting a compiler flag to include debug symbols), but in some cases the application logic may also be somewhat different (for example, use of some code that is specific to a certain target platform). Code RealTime provides a powerful mechanism, based on scripting, that allows you to build several variants of an application with minimal effort. Dynamic Transformation Configurations A TC is defined using JavaScript which is interpreted when it is built. This opens up for dynamic TC properties where the value of a property is computed at build-time. For simple cases it may be enough to replace static values for TC properties with JavaScript expressions to be able to build several variants of an application. As an example, assume that you want to either build a release or a debug version of an application. The debug version is obtained by compiling the code with the $(DEBUG_TAG) flag. The TC can then for example look like this: let tc = TCF.define(TCF.CPP_TRANSFORM); tc.topCapsule = 'Top'; let system = Java.type('java.lang.System'); let isDebug = system.getenv('DEBUG_BUILD'); tc.compileArguments = isDebug ? '$(DEBUG_TAG)' : ''; TCs are evaluated using Nashorn which is a JavaScript engine running on the Java Virtual Machine. This is why we can access a Java class such as java.lang.System to read the value of an environment variable. With this TC, and the use of an environment variable DEBUG_BUILD , we can now build either a release or a debug version of our application depending on if the environment variable is set or not. However, defining variants of an application like this can become messy for more complex examples. Setting up several environment variables in a consistent fashion will require effort for everyone that needs to build the application, and perhaps you even need to write a script to manage it. But the biggest problem is that the JavaScript that defines the build variants is embedded into the TC file itself. This makes it impossible to reuse a build variant implementation for multiple TCs. Build Variants Script A Build Variants script allows to define build variants outside the TC itself. It defines a number of high-level settings, we call them build variant settings , each of which is implemented by a separate JavaScript file. There are two kinds of build variant settings that can be defined: Boolean settings These are settings that can either be turned on or off. The \"debug\" flag we implemented in the example above is an example of a boolean setting. Enumerated settings These are settings that can have a fixed set of values. A list of supported target platforms could be an example of an enumerated setting. A Build Variants script must have a global function called initBuildVariants which defines the build variant settings. Here is an example where one boolean and one enumerated build variant setting are defined: // Boolean setting let isDebug = { name: 'Debug', script: 'debug.js', defaultValue: false, description: 'If set, a debug version of the application will be built' }; // Enumerated setting let optimization = { name: 'Optimization', alternatives: [ { name: 'HIGH', script: 'opt.js', args: ['HIGH'], description: 'Apply all optimizations', defaultValue: true }, { name: 'MEDIUM', script: 'opt.js', args: ['MEDIUM'], description: 'Apply some optimizations'}, { name: 'OFF', script: 'opt.js', args: ['OFF'], description: 'Turn off all optimizations' } ] }; // This function defines which build variant settings that are applicable for a certain TC function initBuildVariants(tc) { BVF.add(isDebug); BVF.add(optimization); } Note the following: The name property specifies a user-friendly name of the build variant setting. Use the description property to document what the build variant setting means and how it works. In case of an enumerated setting, exactly one of the alternatives should have the defaultValue property set. This alternative will be used in case no value is provided for that build variant setting at build-time. For a boolean setting, defaultValue should be set to either true or false depending on if you want the build setting to be turned on or off by default. The script property specifies the JavaScript file that implements the build variant setting. The path is relative to the location of the Build Variants script (usually they are all placed in the same folder). For a boolean setting the script is only invoked if the setting is set to true . For an enumerated setting the script is always invoked, and the value of the enumerated setting is passed as an argument to the script using the args property. It's therefore possible (and common) to implement all alternatives of an enumerated setting with the same script. The initBuildVariants function gets the built TC as an argument. You can use it for defining different build variant settings for different kinds of TCs. Here is an example where a build variant setting only is defined for an executable TC: function initBuildVariants(tc) { if (tc.topCapsule) { // Executable TC BVF.add(linkOptimization); } else { // Library TC } } Build Variant Setting Script A script that implements a build variant setting is invoked twice when a TC is built. The first time a function preProcess gets called, and the second time a function postProcess gets called. You can define either one or both of these functions depending on your needs. preProcess Function If a preProcess function exists it will be called before the built TC is evaluated. Therefore you cannot access the TC in this function. The only input to the function is the script arguments, as defined by the args property for an enumerated setting. The main reason for implementing a preProcess function is to compute some data based on a build variant setting. Such data can be stored globally and later be accessed when postProcess gets called or in a TC file when setting the value of a TC property. Here is an example: function preProcess( targetPlatform ) { MSG.formatInfo(\"Building for target platform %s\", targetPlatform); TCF.globals().targetPlatform = targetPlatform; if (targetPlatform == 'Win64_MSVS') { TCF.globals().targetCompiler = 'MSVS'; MSG.formatInfo(\"Building with Microsoft Visual Studio Compiler\"); } else { TCF.globals().targetCompiler = 'GCC'; MSG.formatInfo(\"Building with GNU Compiler\"); } } Here we use the MSG object for printing messages to the build log and we use the TCF object for storing globally some data that we have computed based on the build variant setting. Remember that the TCF object also is available in a TC file, which means that TC properties may access the stored global data. postProcess Function If a postProcess function exists it will be called after the built TC has been evaluated. The function gets the built TC as an argument, as well as all its prerequisite TCs. For an enumerated setting it also gets the script arguments as defined by the args property. The function can directly modify properties of both the built TC and all its prerequisites. The property values that the TCs have when the function returns are the ones that will be used in the build. Hence this function gives you full freedom to customize all TC properties so that they have values suitable for the build variant setting. Here is an example that uses the global data computed in the preProcess function above: function postProcess(topTC, allTCs, targetPlatform) { for (i = 0; i < allTCs.length; ++i) { if (TCF.globals().targetCompiler == 'MSVS') { allTCs[i].compileCommand = 'cl'; } else if (TCF.globals().targetCompiler == 'GCC') { allTCs[i].compileCommand = 'gcc'; } if (targetPlatform == 'MacOS') { MSG.formatWarning(\"MacOS builds are not fully supported yet\"); } } } Also in this function we can use the TCF and MSG objects to access global data and to print messages to the build log. But most importantly, we can directly write the properties of the topTC (the TC that is built) and/or allTCs (the TC that is built followed by all its prerequisite TCs). By modifying the compileArguments TC property the build variant setting script can set preprocessor macros in order to customize the code that gets compiled. Hence we can both customize how the application is built, and also what it will do at run-time. This makes Build Variants a very powerful feature for building variants of an application, controlled by a few well-defined high-level build variant settings. Example You can find a sample application that uses build variants here . Build Configuration When building a TC that uses build variants you need to provide values for all build variant settings, except those for which you want to use their default values. These values are referred to as a build configuration . You can only specify a build configuration when building with the Art Compiler . When building from within the IDE, all build variant settings will get their default values. Specify the build configuration by means of the --buildConfig option for the Art Compiler. A boolean build variant setting is set by simply mentioning the name of the setting in the build configuration. To set an enumerated build variant setting use the syntax setting=value . Separate different build variant settings by semicolons. For the sample build variants script above, with one boolean and one enumerated build variant setting, a build configuration can look like this: --buildConfig=\"Debug;Optimization=MEDIUM\" JavaScript API Build variant scripts are implemented with JavaScript and run on a Java Virtual Machine (JVM) by means of an engine called Nashorn . It supports all of ECMAScript 5.1 and many things from ECMAScript 6. Since it runs on the JVM you can access Java classes and methods. See the Nashorn documentation to learn about these possibilities. In addition to standard JavaScript and Java functionality, a build variant script can also use an API provided by Code RealTime. This API consists of a few JavaScript objects and functions. Note that there are three different contexts in which JavaScript executes in Code RealTime and not all parts of the API are available or meaningful in all contexts. Evaluation of a TC : TCs are evaluated when they are built, but also in order to perform validation of TC properties, for example while editing the TC. JavaScript in a TC file has access to the TCF object . Typically on the first line in a TC it's used like this: let tc = TCF.define(TCF.CPP_TRANSFORM); . Since TCs are evaluated frequently all JavaScript it contains should only compute what it necessary for setting the values of TC properties. It should not have any side-effects, and should not print any messages. Build Variants script : A build variants script is evaluated when building a TC with the Art Compiler . This evaluation happens early with the purpose of deciding which build variant settings that are applicable for the build. You can use the BVF object in a build variants script. Build Variant Setting script : A build variant setting script is evaluated when building a TC with the Art Compiler . It's evaluated twice as explained above . You can use the MSG and TCF objects in a build variant setting script. BVF Object This object provides a \"Build Variant Framework\" with functions that are useful when implementing a Build Variants script. The object is only available in that kind of script. BVF.add add(...buildVariantSettings) Adds one or several build variant settings to be available for the current build. Each build variant setting is represented by a JavaScript object that either describes a boolean or enumerated setting as explained above . BVF.addCommonUtils addCommonUtils(...commonUtils) If you implement utility functions that you want to use from several scripts you can make them globally available by means of this function. For example: let myUtils = { name: 'My utils', // Any name script: 'myUtils.js' // Script that contains global utility functions } function initBuildVariants(tc) { BVF.addCommonUtils(myUtils); // ... } All functions defined in \"myUtils.js\" will now be available to be used by build variant setting scripts. BVF.formatInfo formatInfo(msg,...args) Prints an information message to the build log. This function works the same as MSG.formatInfo . BVF.formatWarning formatWarning(msg,...args) Prints a warning message to the build log. This function works the same as MSG.formatWarning . BVF.formatError formatError(msg,...args) Prints an error message to the build log. This function works the same as MSG.formatError . Note that the Art Compiler will stop the build if an error is reported. MSG Object This object provides functions for writing messages to the build log. Each function takes a message and optionally also additional arguments. The message may contain placeholders, such as %s, that will be replaced with the arguments. You must make sure the number of arguments provided match the number of placeholders in the message, and that the type of each argument matches the type of placeholder (e.g. %s for string). The MSG object is only available in a build variant setting script. MSG.formatInfo formatInfo(msg,...args) Prints an information message to the build log. Example: MSG.formatInfo(\"Building for target platform %s\", targetPlatform); MSG.formatWarning formatWarning(msg,...args) Prints a warning message to the build log. MSG.formatError formatError(msg,...args) Prints an error message to the build log. Note that the Art Compiler will stop the build if an error is reported. TCF Object This object provides a \"Transformation Configuration Framework\". It is available in a build variant setting script and also in a TC file. buildVariantsFolder buildVariantsFolder() -> String Returns the full path to the folder where the build variants script is located. buildVariantsScript buildVariantsScript() -> String Returns the full path to the build variants script. define define(descriptorId) -> {TCObject} Creates a new TC object. This function is typically called in the beginning of a TC file to get the TC object whose properties are then set. getTopTC getTopTC() -> {TCObject} Returns the top TC, i.e. the TC that is built. You can use this from a prerequisite TC to access properties set on the top TC. For example, it allows a library TC to set some of its properties to have the same values as are used for the executable TC. This can ensure that a library is built with the same settings that are used for the executable that links with the library. Here is an example of how a library TC can be defined to ensure that it will use the same target configuration as the executable that links with it: let tc = TCF.define(TCF.CPP_TRANSFORM); let topTC = TCF.getTopTC().eval; // eval returns an evaluated TC object, where all properties have ready-to-read values (even for properties with default values) tc.targetConfiguration = topTC.targetConfiguration; globals globals() -> {object} Returns an object that can store global data needed across evaluations of different JavaScript files. For an example, see above . orderedGraph orderedGraph(topTC) -> [{TCObject}] Traverses all prerequisites of a TC ( topTC ) and returns an array that contains them in a depth-first order. The last element of the array is the top TC itself. The function also ensures that all prerequisite TCs are loaded. var prereqs = TCF.orderedGraph(tc); for (i = 0; i < prereqs.length; ++i) { var arguments = prereqs[i].compileArguments; // ... }","title":"Build Variants"},{"location":"building/build-variants/#dynamic-transformation-configurations","text":"A TC is defined using JavaScript which is interpreted when it is built. This opens up for dynamic TC properties where the value of a property is computed at build-time. For simple cases it may be enough to replace static values for TC properties with JavaScript expressions to be able to build several variants of an application. As an example, assume that you want to either build a release or a debug version of an application. The debug version is obtained by compiling the code with the $(DEBUG_TAG) flag. The TC can then for example look like this: let tc = TCF.define(TCF.CPP_TRANSFORM); tc.topCapsule = 'Top'; let system = Java.type('java.lang.System'); let isDebug = system.getenv('DEBUG_BUILD'); tc.compileArguments = isDebug ? '$(DEBUG_TAG)' : ''; TCs are evaluated using Nashorn which is a JavaScript engine running on the Java Virtual Machine. This is why we can access a Java class such as java.lang.System to read the value of an environment variable. With this TC, and the use of an environment variable DEBUG_BUILD , we can now build either a release or a debug version of our application depending on if the environment variable is set or not. However, defining variants of an application like this can become messy for more complex examples. Setting up several environment variables in a consistent fashion will require effort for everyone that needs to build the application, and perhaps you even need to write a script to manage it. But the biggest problem is that the JavaScript that defines the build variants is embedded into the TC file itself. This makes it impossible to reuse a build variant implementation for multiple TCs.","title":"Dynamic Transformation Configurations"},{"location":"building/build-variants/#build-variants-script","text":"A Build Variants script allows to define build variants outside the TC itself. It defines a number of high-level settings, we call them build variant settings , each of which is implemented by a separate JavaScript file. There are two kinds of build variant settings that can be defined: Boolean settings These are settings that can either be turned on or off. The \"debug\" flag we implemented in the example above is an example of a boolean setting. Enumerated settings These are settings that can have a fixed set of values. A list of supported target platforms could be an example of an enumerated setting. A Build Variants script must have a global function called initBuildVariants which defines the build variant settings. Here is an example where one boolean and one enumerated build variant setting are defined: // Boolean setting let isDebug = { name: 'Debug', script: 'debug.js', defaultValue: false, description: 'If set, a debug version of the application will be built' }; // Enumerated setting let optimization = { name: 'Optimization', alternatives: [ { name: 'HIGH', script: 'opt.js', args: ['HIGH'], description: 'Apply all optimizations', defaultValue: true }, { name: 'MEDIUM', script: 'opt.js', args: ['MEDIUM'], description: 'Apply some optimizations'}, { name: 'OFF', script: 'opt.js', args: ['OFF'], description: 'Turn off all optimizations' } ] }; // This function defines which build variant settings that are applicable for a certain TC function initBuildVariants(tc) { BVF.add(isDebug); BVF.add(optimization); } Note the following: The name property specifies a user-friendly name of the build variant setting. Use the description property to document what the build variant setting means and how it works. In case of an enumerated setting, exactly one of the alternatives should have the defaultValue property set. This alternative will be used in case no value is provided for that build variant setting at build-time. For a boolean setting, defaultValue should be set to either true or false depending on if you want the build setting to be turned on or off by default. The script property specifies the JavaScript file that implements the build variant setting. The path is relative to the location of the Build Variants script (usually they are all placed in the same folder). For a boolean setting the script is only invoked if the setting is set to true . For an enumerated setting the script is always invoked, and the value of the enumerated setting is passed as an argument to the script using the args property. It's therefore possible (and common) to implement all alternatives of an enumerated setting with the same script. The initBuildVariants function gets the built TC as an argument. You can use it for defining different build variant settings for different kinds of TCs. Here is an example where a build variant setting only is defined for an executable TC: function initBuildVariants(tc) { if (tc.topCapsule) { // Executable TC BVF.add(linkOptimization); } else { // Library TC } }","title":"Build Variants Script"},{"location":"building/build-variants/#build-variant-setting-script","text":"A script that implements a build variant setting is invoked twice when a TC is built. The first time a function preProcess gets called, and the second time a function postProcess gets called. You can define either one or both of these functions depending on your needs.","title":"Build Variant Setting Script"},{"location":"building/build-variants/#preprocess-function","text":"If a preProcess function exists it will be called before the built TC is evaluated. Therefore you cannot access the TC in this function. The only input to the function is the script arguments, as defined by the args property for an enumerated setting. The main reason for implementing a preProcess function is to compute some data based on a build variant setting. Such data can be stored globally and later be accessed when postProcess gets called or in a TC file when setting the value of a TC property. Here is an example: function preProcess( targetPlatform ) { MSG.formatInfo(\"Building for target platform %s\", targetPlatform); TCF.globals().targetPlatform = targetPlatform; if (targetPlatform == 'Win64_MSVS') { TCF.globals().targetCompiler = 'MSVS'; MSG.formatInfo(\"Building with Microsoft Visual Studio Compiler\"); } else { TCF.globals().targetCompiler = 'GCC'; MSG.formatInfo(\"Building with GNU Compiler\"); } } Here we use the MSG object for printing messages to the build log and we use the TCF object for storing globally some data that we have computed based on the build variant setting. Remember that the TCF object also is available in a TC file, which means that TC properties may access the stored global data.","title":"preProcess Function"},{"location":"building/build-variants/#postprocess-function","text":"If a postProcess function exists it will be called after the built TC has been evaluated. The function gets the built TC as an argument, as well as all its prerequisite TCs. For an enumerated setting it also gets the script arguments as defined by the args property. The function can directly modify properties of both the built TC and all its prerequisites. The property values that the TCs have when the function returns are the ones that will be used in the build. Hence this function gives you full freedom to customize all TC properties so that they have values suitable for the build variant setting. Here is an example that uses the global data computed in the preProcess function above: function postProcess(topTC, allTCs, targetPlatform) { for (i = 0; i < allTCs.length; ++i) { if (TCF.globals().targetCompiler == 'MSVS') { allTCs[i].compileCommand = 'cl'; } else if (TCF.globals().targetCompiler == 'GCC') { allTCs[i].compileCommand = 'gcc'; } if (targetPlatform == 'MacOS') { MSG.formatWarning(\"MacOS builds are not fully supported yet\"); } } } Also in this function we can use the TCF and MSG objects to access global data and to print messages to the build log. But most importantly, we can directly write the properties of the topTC (the TC that is built) and/or allTCs (the TC that is built followed by all its prerequisite TCs). By modifying the compileArguments TC property the build variant setting script can set preprocessor macros in order to customize the code that gets compiled. Hence we can both customize how the application is built, and also what it will do at run-time. This makes Build Variants a very powerful feature for building variants of an application, controlled by a few well-defined high-level build variant settings. Example You can find a sample application that uses build variants here .","title":"postProcess Function"},{"location":"building/build-variants/#build-configuration","text":"When building a TC that uses build variants you need to provide values for all build variant settings, except those for which you want to use their default values. These values are referred to as a build configuration . You can only specify a build configuration when building with the Art Compiler . When building from within the IDE, all build variant settings will get their default values. Specify the build configuration by means of the --buildConfig option for the Art Compiler. A boolean build variant setting is set by simply mentioning the name of the setting in the build configuration. To set an enumerated build variant setting use the syntax setting=value . Separate different build variant settings by semicolons. For the sample build variants script above, with one boolean and one enumerated build variant setting, a build configuration can look like this: --buildConfig=\"Debug;Optimization=MEDIUM\"","title":"Build Configuration"},{"location":"building/build-variants/#javascript-api","text":"Build variant scripts are implemented with JavaScript and run on a Java Virtual Machine (JVM) by means of an engine called Nashorn . It supports all of ECMAScript 5.1 and many things from ECMAScript 6. Since it runs on the JVM you can access Java classes and methods. See the Nashorn documentation to learn about these possibilities. In addition to standard JavaScript and Java functionality, a build variant script can also use an API provided by Code RealTime. This API consists of a few JavaScript objects and functions. Note that there are three different contexts in which JavaScript executes in Code RealTime and not all parts of the API are available or meaningful in all contexts. Evaluation of a TC : TCs are evaluated when they are built, but also in order to perform validation of TC properties, for example while editing the TC. JavaScript in a TC file has access to the TCF object . Typically on the first line in a TC it's used like this: let tc = TCF.define(TCF.CPP_TRANSFORM); . Since TCs are evaluated frequently all JavaScript it contains should only compute what it necessary for setting the values of TC properties. It should not have any side-effects, and should not print any messages. Build Variants script : A build variants script is evaluated when building a TC with the Art Compiler . This evaluation happens early with the purpose of deciding which build variant settings that are applicable for the build. You can use the BVF object in a build variants script. Build Variant Setting script : A build variant setting script is evaluated when building a TC with the Art Compiler . It's evaluated twice as explained above . You can use the MSG and TCF objects in a build variant setting script.","title":"JavaScript API"},{"location":"building/build-variants/#bvf-object","text":"This object provides a \"Build Variant Framework\" with functions that are useful when implementing a Build Variants script. The object is only available in that kind of script.","title":"BVF Object"},{"location":"building/build-variants/#bvfadd","text":"add(...buildVariantSettings) Adds one or several build variant settings to be available for the current build. Each build variant setting is represented by a JavaScript object that either describes a boolean or enumerated setting as explained above .","title":"BVF.add"},{"location":"building/build-variants/#bvfaddcommonutils","text":"addCommonUtils(...commonUtils) If you implement utility functions that you want to use from several scripts you can make them globally available by means of this function. For example: let myUtils = { name: 'My utils', // Any name script: 'myUtils.js' // Script that contains global utility functions } function initBuildVariants(tc) { BVF.addCommonUtils(myUtils); // ... } All functions defined in \"myUtils.js\" will now be available to be used by build variant setting scripts.","title":"BVF.addCommonUtils"},{"location":"building/build-variants/#bvfformatinfo","text":"formatInfo(msg,...args) Prints an information message to the build log. This function works the same as MSG.formatInfo .","title":"BVF.formatInfo"},{"location":"building/build-variants/#bvfformatwarning","text":"formatWarning(msg,...args) Prints a warning message to the build log. This function works the same as MSG.formatWarning .","title":"BVF.formatWarning"},{"location":"building/build-variants/#bvfformaterror","text":"formatError(msg,...args) Prints an error message to the build log. This function works the same as MSG.formatError . Note that the Art Compiler will stop the build if an error is reported.","title":"BVF.formatError"},{"location":"building/build-variants/#msg-object","text":"This object provides functions for writing messages to the build log. Each function takes a message and optionally also additional arguments. The message may contain placeholders, such as %s, that will be replaced with the arguments. You must make sure the number of arguments provided match the number of placeholders in the message, and that the type of each argument matches the type of placeholder (e.g. %s for string). The MSG object is only available in a build variant setting script.","title":"MSG Object"},{"location":"building/build-variants/#msgformatinfo","text":"formatInfo(msg,...args) Prints an information message to the build log. Example: MSG.formatInfo(\"Building for target platform %s\", targetPlatform);","title":"MSG.formatInfo"},{"location":"building/build-variants/#msgformatwarning","text":"formatWarning(msg,...args) Prints a warning message to the build log.","title":"MSG.formatWarning"},{"location":"building/build-variants/#msgformaterror","text":"formatError(msg,...args) Prints an error message to the build log. Note that the Art Compiler will stop the build if an error is reported.","title":"MSG.formatError"},{"location":"building/build-variants/#tcf-object","text":"This object provides a \"Transformation Configuration Framework\". It is available in a build variant setting script and also in a TC file.","title":"TCF Object"},{"location":"building/build-variants/#buildvariantsfolder","text":"buildVariantsFolder() -> String Returns the full path to the folder where the build variants script is located.","title":"buildVariantsFolder"},{"location":"building/build-variants/#buildvariantsscript","text":"buildVariantsScript() -> String Returns the full path to the build variants script.","title":"buildVariantsScript"},{"location":"building/build-variants/#define","text":"define(descriptorId) -> {TCObject} Creates a new TC object. This function is typically called in the beginning of a TC file to get the TC object whose properties are then set.","title":"define"},{"location":"building/build-variants/#gettoptc","text":"getTopTC() -> {TCObject} Returns the top TC, i.e. the TC that is built. You can use this from a prerequisite TC to access properties set on the top TC. For example, it allows a library TC to set some of its properties to have the same values as are used for the executable TC. This can ensure that a library is built with the same settings that are used for the executable that links with the library. Here is an example of how a library TC can be defined to ensure that it will use the same target configuration as the executable that links with it: let tc = TCF.define(TCF.CPP_TRANSFORM); let topTC = TCF.getTopTC().eval; // eval returns an evaluated TC object, where all properties have ready-to-read values (even for properties with default values) tc.targetConfiguration = topTC.targetConfiguration;","title":"getTopTC"},{"location":"building/build-variants/#globals","text":"globals() -> {object} Returns an object that can store global data needed across evaluations of different JavaScript files. For an example, see above .","title":"globals"},{"location":"building/build-variants/#orderedgraph","text":"orderedGraph(topTC) -> [{TCObject}] Traverses all prerequisites of a TC ( topTC ) and returns an array that contains them in a depth-first order. The last element of the array is the top TC itself. The function also ensures that all prerequisite TCs are loaded. var prereqs = TCF.orderedGraph(tc); for (i = 0; i < prereqs.length; ++i) { var arguments = prereqs[i].compileArguments; // ... }","title":"orderedGraph"},{"location":"building/launch-configurations/","text":"As described above you can launch a built executable using the Run command in the TC context menu. This is a quick and easy way to run an executable, which is sufficient for simple applications. However, the simplicity comes with several limitations: You cannot specify any custom command-line arguments for the launched executable. In fact, the executable is always launched with one hard-coded argument --URTS_DEBUG=quit which means it will run in non-debug mode. You cannot set any custom environment variables for the launched executable. You cannot set the current working directory for the launched executable. A more flexible way to launch an executable is to use a launch configuration . This is a JSON file that contains several attributes that control how to launch the executable. Using a launch configuration also gives additional benefits: Visual Studio Code and Eclipse Theia knows about launch configurations and provides a dedicated UI for working with them. You can easily manage multiple ways of launching the same application. Just create a launch configuration for each way of launching it. The output from the launched application is printed in the Debug Console rather than the Terminal view. The Debug Console colorizes printed output from the application (red for text printed to stderr and orange for text printed to stdout). You can terminate and relaunch the application using a toolbar instead of using the Terminal view. Creating a Launch Configuration To create a launch configuration open the \"Run and Debug\" view from the activity bar and then click the create a launch.json file hyperlink. You can choose to store the launch configuration either in a workspace folder or in the workspace file. In most cases it makes sense to store it in the same workspace folder that contains the TC that will be used for building the application to launch. However, if you want to share the same launch configuration for multiple applications you can choose to store it in the workspace file instead. When you choose to store the launch configuration in a workspace folder it will be placed in the .vscode folder and get the name launch.json : The created launch configuration looks like this: { \"type\": \"art\", \"request\": \"launch\", \"name\": \"runTC\", \"tc\": \"${workspaceFolder}/${command:AskForTC}\" } You should change the name attribute to give the launch configuration a more meaningful name. You can have multiple launch configurations in the same launch.json file. Create new ones either by copy/paste of another one, or by pressing the Add Configuration... button. You can also create new launch configurations using the drop down menu in the \"Run and Debug\" view: Launching a Launch Configuration The name of a launch configuration appears in the launch configuration drop down menu: Launch the launch configuration by pressing the green arrow button that appears to the left of this drop down menu. You can also perform the launch from the Run menu, using the command Run without Debugging ( Ctrl + F5 ). In that case the launch configuration that is selected in the \"Run and Debug\" view drop down menu will be used. Launch Configuration Attributes Below is a table that lists all attributes that can be used in a launch configuration. Each attribute is described in a section of its own below the table. Attribute Description Mandatory type The type of launch configuration. Always \"art\". Yes request What the launch configuration will do. Always \"launch\". Yes name The name of the launch configuration Yes tc The TC file to use for building and launching the application. Yes args Command line arguments to pass to the launched application. No environment Environment variables to set for the launched application. No cwd Current working directory for the launched application No type This attribute specifies the type of launch configuration. It is mandatory and is always the string \"art\". request This attribute specifies what the launch configuration will do. It is mandatory and is always the string \"launch\". name Specifies the name of the launch configuration. You should give a meaningful and unique name to each launch configuration that describes what it does. The chosen name appears in the drop down menu in the \"Run and Debug\" view. When you first create a launch configuration it gets the name \"runTC\". Make sure to change this default name. tc This attribute specifies which TC file to use for building and launching. The specified TC must build an executable. You must use an absolute path to the TC file, but it can contain the ${workspaceFolder} variable which expands to the location of the workspace folder. By default the tc attribute is set to ${workspaceFolder}/${command:AskForTC} which means you will be prompted for choosing which TC to use when the launch configuration is launched. For a list of other variables that can be used in this attribute see this page . args Specifies the command-line arguments for the launched executable. This is a list of strings, and by default it is set to [\"-URTS_DEBUG=quit\"] which means that the executable will run in non-debug mode. You may add custom command-line arguments for your application as necessary. For example: { \"type\": \"art\", \"request\": \"launch\", \"name\": \"Let my exe listen to a port\", \"tc\": \"${workspaceFolder}/app.tcjs\", \"args\": [\"-URTS_DEBUG=quit\", \"--port=12345\"] } environment Specifies environment variables to be set for the launched executable. This is a list of objects where each object has a property that specifies the name of an environment variable. The environment variable will be set to the value of that property. In the example below the environment variable LD_LIBRARY_PATH will be set to /libs/mylibs to tell a Linux system where to load shared libraries needed by the application. { \"type\": \"art\", \"request\": \"launch\", \"name\": \"Launch and load shared libraries\", \"tc\": \"${workspaceFolder}/app.tcjs\", \"environment\": [{\"LD_LIBRARY_PATH\" : \"/libs/mylibs\"}] } cwd By default the launched application runs in the same folder as where the executable is located. By setting this attribute you can change the current working directory to something else. The value of this attribute must be an absolute path, but certain variables can be used. See this page for more information.","title":"Launch Configurations"},{"location":"building/launch-configurations/#creating-a-launch-configuration","text":"To create a launch configuration open the \"Run and Debug\" view from the activity bar and then click the create a launch.json file hyperlink. You can choose to store the launch configuration either in a workspace folder or in the workspace file. In most cases it makes sense to store it in the same workspace folder that contains the TC that will be used for building the application to launch. However, if you want to share the same launch configuration for multiple applications you can choose to store it in the workspace file instead. When you choose to store the launch configuration in a workspace folder it will be placed in the .vscode folder and get the name launch.json : The created launch configuration looks like this: { \"type\": \"art\", \"request\": \"launch\", \"name\": \"runTC\", \"tc\": \"${workspaceFolder}/${command:AskForTC}\" } You should change the name attribute to give the launch configuration a more meaningful name. You can have multiple launch configurations in the same launch.json file. Create new ones either by copy/paste of another one, or by pressing the Add Configuration... button. You can also create new launch configurations using the drop down menu in the \"Run and Debug\" view:","title":"Creating a Launch Configuration"},{"location":"building/launch-configurations/#launching-a-launch-configuration","text":"The name of a launch configuration appears in the launch configuration drop down menu: Launch the launch configuration by pressing the green arrow button that appears to the left of this drop down menu. You can also perform the launch from the Run menu, using the command Run without Debugging ( Ctrl + F5 ). In that case the launch configuration that is selected in the \"Run and Debug\" view drop down menu will be used.","title":"Launching a Launch Configuration"},{"location":"building/launch-configurations/#launch-configuration-attributes","text":"Below is a table that lists all attributes that can be used in a launch configuration. Each attribute is described in a section of its own below the table. Attribute Description Mandatory type The type of launch configuration. Always \"art\". Yes request What the launch configuration will do. Always \"launch\". Yes name The name of the launch configuration Yes tc The TC file to use for building and launching the application. Yes args Command line arguments to pass to the launched application. No environment Environment variables to set for the launched application. No cwd Current working directory for the launched application No","title":"Launch Configuration Attributes"},{"location":"building/launch-configurations/#type","text":"This attribute specifies the type of launch configuration. It is mandatory and is always the string \"art\".","title":"type"},{"location":"building/launch-configurations/#request","text":"This attribute specifies what the launch configuration will do. It is mandatory and is always the string \"launch\".","title":"request"},{"location":"building/launch-configurations/#name","text":"Specifies the name of the launch configuration. You should give a meaningful and unique name to each launch configuration that describes what it does. The chosen name appears in the drop down menu in the \"Run and Debug\" view. When you first create a launch configuration it gets the name \"runTC\". Make sure to change this default name.","title":"name"},{"location":"building/launch-configurations/#tc","text":"This attribute specifies which TC file to use for building and launching. The specified TC must build an executable. You must use an absolute path to the TC file, but it can contain the ${workspaceFolder} variable which expands to the location of the workspace folder. By default the tc attribute is set to ${workspaceFolder}/${command:AskForTC} which means you will be prompted for choosing which TC to use when the launch configuration is launched. For a list of other variables that can be used in this attribute see this page .","title":"tc"},{"location":"building/launch-configurations/#args","text":"Specifies the command-line arguments for the launched executable. This is a list of strings, and by default it is set to [\"-URTS_DEBUG=quit\"] which means that the executable will run in non-debug mode. You may add custom command-line arguments for your application as necessary. For example: { \"type\": \"art\", \"request\": \"launch\", \"name\": \"Let my exe listen to a port\", \"tc\": \"${workspaceFolder}/app.tcjs\", \"args\": [\"-URTS_DEBUG=quit\", \"--port=12345\"] }","title":"args"},{"location":"building/launch-configurations/#environment","text":"Specifies environment variables to be set for the launched executable. This is a list of objects where each object has a property that specifies the name of an environment variable. The environment variable will be set to the value of that property. In the example below the environment variable LD_LIBRARY_PATH will be set to /libs/mylibs to tell a Linux system where to load shared libraries needed by the application. { \"type\": \"art\", \"request\": \"launch\", \"name\": \"Launch and load shared libraries\", \"tc\": \"${workspaceFolder}/app.tcjs\", \"environment\": [{\"LD_LIBRARY_PATH\" : \"/libs/mylibs\"}] }","title":"environment"},{"location":"building/launch-configurations/#cwd","text":"By default the launched application runs in the same folder as where the executable is located. By setting this attribute you can change the current working directory to something else. The value of this attribute must be an absolute path, but certain variables can be used. See this page for more information.","title":"cwd"},{"location":"building/transformation-configurations/","text":"A transformation configuration (or TC for short) contains all properties needed for transforming Art files into C++ code and for building the generated code into an application or a library. It is a text file in JavaScript format with the file extension .tcjs. Using JavaScript for defining build properties has many advantages. For example, it allows for dynamic properties where the value is not a static value but computed dynamically by JavaScript code when the TC is built. Code RealTime provides a dedicated language server for TCs to make them just as easy to work with as Art files. A form-based editor is also provided as an alternative. Creating Transformation Configurations To create a new TC select a file in the workspace folder that contains the Art files you want to transform to C++. Then invoke the command File - New File - Transformation Configuration . In the popup that appears specify the name of the TC or keep the suggested default name. A .tcjs file will be created with the minimal contents. Specify the mandatory topCapsule property (if you are building an executable) and any other properties needed. Setting a Transformation Configuration as Active You can have more than one TC in your workspace, and also multiple TCs in the same workspace folder, but at most one TC in each workspace folder can be active . Code RealTime uses the active TC in several ways: It controls how to automatically generate C++ code from the Art files in the workspace folder. In this respect it corresponds directly to the --tc option for the Art Compiler . It's used for automatically propagating changes you make in generated files back to the source Art files (see Making Changes in Generated C++ ). It affects how references in Art files are bound to Art elements in other Art files. More precisely, it's the sources and prerequisites properties of the active TC that have an influence on the binding of references (since these properties control which Art files that are visible when building the active TC). Note If you don't set a TC as active none of the above will work (or will work incorrectly). It's therefore strongly recommended to create a TC and set it as active as early as possible when you start to work in a new Art workspace folder. Set a TC as active by right-clicking on it and perform the command Set as Active . An active TC is marked with a checkmark. If the active TC has prerequisites , those too will be set as active. This ensures that the results you get when working with Art files in the IDE will be the same as when you will build the TC using the Art Compiler . You can deactivate an individual TC by removing the file art_build_settings.json in the .vscode folder. To deactivate all TCs in the workspace use the Deactivate All command in the Art Build view . Editing Transformation Configurations You can edit a TC directly as a JavaScript file in the text editor. Features such as content assist, navigation and hover tooltips work very similar to how they work for an Art file: Use content assist ( Ctrl + Space ) after typing tc. to get the list of all available TC properties that can be set. You can also use content assist in many places to get suggestions for valid TC property values, for example the list of available top capsules. Certain references in the TC can be navigated by Ctrl + click. For example, you can navigate to the top capsule. Rest the cursor on a TC property name to get more information about the property. TC properties are validated when edited and found problems will be reported. Click the \"More information\" hyperlink for a more detailed description of a problem, including suggestions for how to fix it. As an alternative to editing a TC as a JavaScript file Code RealTime also provides a form-based editor which may be easier to use, especially until you are familiar with all TC properties that exist and what they mean. To open the form-based TC editor, right-click on a TC file and invoke the context menu command Edit Properties (UI) . Each available TC property has its own widget for viewing and editing the value. The type of widget depends on the type of TC property. For example, an enumerated property like \"C++ Code Standard\" uses a drop down menu. Click the info button to view documentation about a certain TC property. Click the button again to hide the documentation. Certain TC properties have default values. Such values are not stored in the TC file, but the TC editor still shows them so you can know what value will actually be used unless you set a custom value for such a property. You can tell which TC properties that have a custom (i.e. non-default) value set by looking at the color of the property name. Properties with custom values set have names shown in blue which are hyperlinks that will navigate to the value in the TC file. Such properties also have a \"Delete\" button which can be used for deleting the property value (i.e. to restore the property to use its default value). You can freely choose if you want to edit TC files as text files or using the form-based TC editor, and you can even use both at the same time. The form-based TC editor is automatically updated as soon as you edit the TC file, and the TC file is automatically updated when a widget with a modified value loses focus. Transformation Configuration Prerequisites A TC can either build a library or an executable. This is controlled by the topCapsule property. If this property is set the TC will build an executable, otherwise it will build a library. To ensure that a library gets built before an executable that links with it, you can set the prerequisites property of the executable TC to reference the library TC. Doing so will also cause the executable to link with the library automatically (i.e. you then don't need to manually set-up necessary preprocessor include paths or linker paths using other TC properties). If you change the prerequisites of a TC you should again set it as active so that the prerequisite TCs also become active. Art Build View Code RealTime provides a view called Art Build which makes several workflows related to TCs easier. The view shows all TCs that are present in the workspace so you don't have to find them in the Explorer view under each workspace folder. For each TC its prerequisites are shown below in a tree structure. This allows to quickly see which TCs a certain TC depends on through its prerequisites without having to open the TC editor. The smaller gray text to the right of the TC name tells in which workspace folder the TC is located. This helps since it's common to have TCs with the same name in a workspace. You can edit a TC by double-clicking on it. This will open the TC in a text editor. When a TC is selected in the Art Build view you can use the toolbar buttons for building, cleaning and running it. Tip It's common to build the same TC many times when developing an Art application. By keeping that TC selected in the Art Build view you can quickly build it by just pressing its Build toolbar button. Building the TC from the Explorer view requires you to first find it which can be cumbersome since the Explorer view selection changes frequently. There are also a few useful commands in the Art Build view toolbar: Refresh In most cases the Art Build view refreshes automatically when TCs are modified. However, if needed you can force a refresh by pressing this button. Clean All Cleans all TCs by removing all target folders in the workspace. Everything contained in the target folder will be deleted (generated code, makefiles, built binaries, etc). A message will be printed in the Art Server channel in case all target folders could be successfully removed, or if not, which ones that could not be deleted. Collapse All Collapses all TCs to not show any prerequisites. Deactivate All Makes all TCs non-active. This makes it easier to switch from building one set of active TCs to another. Properties Below is a table that lists all properties that can be used in a TC. Note that many TC properties have default values and you only need to specify a value for a TC property if its different from the default value. Each property is described in a section of its own below the table. Property Type Default Value commonPreface String N/A compileArguments String N/A compileCommand String \"$CC\" copyrightText String N/A cppCodeStandard Enum string \"C++ 17\" linkArguments String N/A linkCommand String \"$LD\" makeArguments String N/A makeCommand String \"$defaultMakeCommand\" prerequisites List of strings [] sources List of strings [\"*.art\"] targetConfiguration String Depends on current operating system targetConfigurationName String \"default\" targetFolder String Name of TC with \"_target\" appended targetRTSLocation String \"${code_rt_home}/TargetRTS\" topCapsule String N/A unitName String \"UnitName\" userLibraries List of strings [] commonPreface This property allows you to write some code that will be inserted verbatimly into the header unit file (by default called UnitName.h ). Since the header unit file is included by all files that are generated from the TC, you can use the common preface to define or include definitions that should be available everywhere in generated code. compileArguments Specifies the arguments for the C++ compiler used for compiling generated C++ code. Note that some compiler arguments may already be specified in the TargetRTS configuration that is used, and the value of this property will be appended to those standard compiler arguments. compileCommand Specifies which C++ compiler to use for compiling generated C++ code. The default value for this property is $(CC) which is a variable that gets its value from the TargetRTS configuration that is used. copyrightText This property may be used to insert a common comment block in the beginning of each generated file, typically a copyright text. cppCodeStandard Defines the C++ language standard to which generated code will conform. The default value for this property is C++ 17 . Other valid values are C++ 98 , C++ 11 , C++ 14 and C++ 20 . Note that the latest version of the TargetRTS requires at least C++ 11, so if you use an older code standard you have to set TargetRTSLocation to an older version of the TargetRTS that doesn't contain any C++ 11 constructs. If you need to compile generated code with a very old compiler that doesn't even support C++ 98 you can set this preference to Older than C++ 98 . inclusionPaths Specifies additional include paths for the C++ preprocessor in addition to \"standard\" ones such as the location of TargetRTS include files. If your application links with a user library or user object file you need to add the location of the header file(s) that belong to the library or object file. tc.inclusionPaths = [\"/libs/myLib/includes\"]; Note that you don't need to add inclusion paths for target folders of prerequisite TCs. They are added automatically by the make file generator. linkArguments Specifies the arguments for the C++ linker used for linking object files and libraries into an executable. This property is only applicable for TCs that build executables. linkCommand Specifies which C++ linker to use for linking object files and libraries into an executable. The default value for this property is $(LD) which is a variable that gets its value from the TargetRTS configuration that is used. This property is only applicable for TCs that build executables. makeArguments Specifies the arguments for the make command to be used. makeCommand Specifies which make command to use for processing the generated make file. By default the make command is $defaultMakeCommand which gets its value from which TargetRTS configuration that is used. prerequisites This property is a list of references to other TCs that need to be built before the current TC. It's typically used to express that a library TC is a prerequisite of an executable TC, which means the library TC needs to be built before the executable TC. Below is an example where an executable TC has a library TC as a prerequisite: tc.prerequisites = [\"../MyLibrary/lib.tcjs\"]; Prerequisite TCs can either be specified using absolute or relative paths. Relative paths are resolved against the location of the TC that has the property set. For more information about this property see Transformation Configuration Prerequisites . sources By default all Art files that are located in the same folder as the TC will be transformed to C++. Sometimes you may want to exclude some Art files, for example because they are built with another TC, or they contain something you want to temporarily exclude from your application without having to delete the files or comment out their contents. In these cases you can set the sources property to specify exactly which Art files that should be built by the TC. The value of the property is a list of strings that specify glob-style patterns and anti-patterns. An Art file will be transformed if it matches at least one pattern and doesn't match any anti-pattern. Anti-patterns start with the ! character. In both patterns and anti-patterns you can use the wildcards * (matches any sequence of characters) and ? (matches a single character). Below are a few examples: tc.sources = [\"*.art\"]; // Transform all Art files in the folder that contains the TC. This is the default behavior if the \"sources\" property is not set. tc.sources = [\"cap1.art\", \"cap2.art\"]; // Only transform two specific Art files tc.sources = [\"*.art\", \"!code_rt_gen.art\"]; // Transform all Art files except one tc.sources = [\"source??.art\", \"!*_gen.art\"]; // Transform all Art files with names starting with \"source\" and followed by two arbitrary characters. Art files with a name that ends with \"_gen\" are excluded. Example You can find a sample application that has a TC with the \"sources\" property set here . targetConfiguration Specifies which TargetRTS configuration to use. The TargetRTS location specified in the targetRTSLocation property defines valid values for this property. If this property is not specified, and the default TargetRTS location from the Code RealTime installation is used, then it will get a default value according to the operating system that is used. For Windows a MinGw-based configuration will be used, while for Linux a GCC-based configuration will be used. targetConfigurationName This property maps to a subfolder of the target folder where all generated files that are not source code will be placed. This includes for example makefiles and the files that are produced by these makefiles (typically binaries). The default value of this property is default . targetFolder Specifies where files generated from the TC will be placed. This property is usually just set to a name, and then a target folder with that name will be created. When the build runs from the UI, that target folder is then added as a workspace folder, which will cause you to be prompted about if you trust the authors of the files in that folder. It's safe to answer yes since all files in that folder are automatically generated by Code RealTime. You can specify an absolute path to a target folder if you prefer generated files to be placed in a certain location that is accessible to everyone in the team, for example a shared network drive. If you instead use a relative path it will get resolved relative to a desired output folder. For a UI build the output folder is set using the setting code-rt.build.outputFolder . When building with the Art Compiler the output folder is instead set using the --out option. If you haven't set the desired output folder, relative paths will instead be resolved against the folder that contains the TC where the targetFolder property is set. Use forward slashes as path separator in this property. If this property is not specified it defaults to the name of the TC, with _target appended. For example, if the TC is called app.tcjs , the target folder will default to app_default . targetRTSLocation Specifies the location of the TargetRTS to use. If no value is set for this property the TargetRTS from the Code RealTime installation will be used. If you want to use another TargetRTS specify the full path to the TargetRTS folder (including that folder itself). Use forward slashes as path separator. For example: tc.targetRTSLocation = \"C:/git/rsarte-target-rts/rsa_rt/C++/TargetRTS\"; threads Specifies the threads used by the application. If no value is set for this property the application will have two default threads: MainThread Runs all capsule instances in the application. It's implemented in the TargetRTS by the RTPeerController class. TimerThread Runs all timers in the application. It's implemented in the TargetRTS by the RTTimerController class. Both these threads will have a stack size of 20kB and run at a normal priority. If your application needs a different thread configuration, or threads with different properties, you need to set the threads property. Note that you cannot just specify threads in addition to the default ones mentioned above, but must always specify all threads. Here is an example where the default threads are present, plus one additional user-defined thread: tc.threads = [ { name: 'MainThread', implClass: 'RTPeerController', stackSize: '20000', priority: 'DEFAULT_MAIN_PRIORITY' }, { name: 'TimerThread', implClass: 'RTTimerController', stackSize: '20000', priority: 'DEFAULT_TIMER_PRIORITY' }, { name: 'MyThread', implClass: 'RTPeerController', stackSize: '20000', priority: 'DEFAULT_MAIN_PRIORITY', logical: [ 'MyLogicalThread' ] } ]; Note that for user-defined threads, like MyThread above, you need to specify one or many logical threads that are mapped to it. These are references to threads that your application use instead of refering directly to a physical thread. This indirection makes it possible to change how capsule instances of your application are run by threads by only modifying the threads property in the TC, without the need to change any application code. Only executable TCs can define physical threads. A library TC can, however, define logical threads. An executable TC that has such a library TC as its prerequisite must map those logical threads to physical threads. Here is an example of a library TC that defines a logical thread. tc.threads = [ `LibraryThread` ]; Note that in this case the threads property contains a list of strings rather than a list of objects as is the case for an executable TC. Read more about threads here . topCapsule Specifies the capsule that should be automatically incarnated when the executable starts to run. Hence this property is only applicable for TCs that build executables, and for those TCs it's a mandatory property. The top capsule is the entry point of the realtime application. If you don't specify a value for this property, the TC will build a library instead of an executable. unitName Specifies the base name of the so called unit header and implementation files that are generated from the TC. By default the value of this property is UnitName which means that these unit files will be called UnitName.cpp and UnitName.h . The unit files contain certain information that applies to the whole unit of code that is generated from a TC. The header unit file is included by all files that are generated from the TC. userLibraries This property is a list of user libraries that should be linked with the application. The property is only applicable for TCs that build executables. tc.userLibraries = [\"../../libs/libMyLib.a\"]; Each library should be specified with a full or relative path so the linker can find it. If no path is provided you may need to provide a link argument to specify the location(s) where the linker should look for the user libraries. userObjectFiles This property is a list of user object files that should be linked with the application. The property is only applicable for TCs that build executables. tc.userObjectFiles = [\"../../objs/extra.obj\"]; Each object file should be specified with a full or relative path so the linker can find it. If no path is provided you may need to provide a link argument to specify the location(s) where the linker should look for the object files.","title":"Transformation Configurations"},{"location":"building/transformation-configurations/#creating-transformation-configurations","text":"To create a new TC select a file in the workspace folder that contains the Art files you want to transform to C++. Then invoke the command File - New File - Transformation Configuration . In the popup that appears specify the name of the TC or keep the suggested default name. A .tcjs file will be created with the minimal contents. Specify the mandatory topCapsule property (if you are building an executable) and any other properties needed.","title":"Creating Transformation Configurations"},{"location":"building/transformation-configurations/#setting-a-transformation-configuration-as-active","text":"You can have more than one TC in your workspace, and also multiple TCs in the same workspace folder, but at most one TC in each workspace folder can be active . Code RealTime uses the active TC in several ways: It controls how to automatically generate C++ code from the Art files in the workspace folder. In this respect it corresponds directly to the --tc option for the Art Compiler . It's used for automatically propagating changes you make in generated files back to the source Art files (see Making Changes in Generated C++ ). It affects how references in Art files are bound to Art elements in other Art files. More precisely, it's the sources and prerequisites properties of the active TC that have an influence on the binding of references (since these properties control which Art files that are visible when building the active TC). Note If you don't set a TC as active none of the above will work (or will work incorrectly). It's therefore strongly recommended to create a TC and set it as active as early as possible when you start to work in a new Art workspace folder. Set a TC as active by right-clicking on it and perform the command Set as Active . An active TC is marked with a checkmark. If the active TC has prerequisites , those too will be set as active. This ensures that the results you get when working with Art files in the IDE will be the same as when you will build the TC using the Art Compiler . You can deactivate an individual TC by removing the file art_build_settings.json in the .vscode folder. To deactivate all TCs in the workspace use the Deactivate All command in the Art Build view .","title":"Setting a Transformation Configuration as Active"},{"location":"building/transformation-configurations/#editing-transformation-configurations","text":"You can edit a TC directly as a JavaScript file in the text editor. Features such as content assist, navigation and hover tooltips work very similar to how they work for an Art file: Use content assist ( Ctrl + Space ) after typing tc. to get the list of all available TC properties that can be set. You can also use content assist in many places to get suggestions for valid TC property values, for example the list of available top capsules. Certain references in the TC can be navigated by Ctrl + click. For example, you can navigate to the top capsule. Rest the cursor on a TC property name to get more information about the property. TC properties are validated when edited and found problems will be reported. Click the \"More information\" hyperlink for a more detailed description of a problem, including suggestions for how to fix it. As an alternative to editing a TC as a JavaScript file Code RealTime also provides a form-based editor which may be easier to use, especially until you are familiar with all TC properties that exist and what they mean. To open the form-based TC editor, right-click on a TC file and invoke the context menu command Edit Properties (UI) . Each available TC property has its own widget for viewing and editing the value. The type of widget depends on the type of TC property. For example, an enumerated property like \"C++ Code Standard\" uses a drop down menu. Click the info button to view documentation about a certain TC property. Click the button again to hide the documentation. Certain TC properties have default values. Such values are not stored in the TC file, but the TC editor still shows them so you can know what value will actually be used unless you set a custom value for such a property. You can tell which TC properties that have a custom (i.e. non-default) value set by looking at the color of the property name. Properties with custom values set have names shown in blue which are hyperlinks that will navigate to the value in the TC file. Such properties also have a \"Delete\" button which can be used for deleting the property value (i.e. to restore the property to use its default value). You can freely choose if you want to edit TC files as text files or using the form-based TC editor, and you can even use both at the same time. The form-based TC editor is automatically updated as soon as you edit the TC file, and the TC file is automatically updated when a widget with a modified value loses focus.","title":"Editing Transformation Configurations"},{"location":"building/transformation-configurations/#transformation-configuration-prerequisites","text":"A TC can either build a library or an executable. This is controlled by the topCapsule property. If this property is set the TC will build an executable, otherwise it will build a library. To ensure that a library gets built before an executable that links with it, you can set the prerequisites property of the executable TC to reference the library TC. Doing so will also cause the executable to link with the library automatically (i.e. you then don't need to manually set-up necessary preprocessor include paths or linker paths using other TC properties). If you change the prerequisites of a TC you should again set it as active so that the prerequisite TCs also become active.","title":"Transformation Configuration Prerequisites"},{"location":"building/transformation-configurations/#art-build-view","text":"Code RealTime provides a view called Art Build which makes several workflows related to TCs easier. The view shows all TCs that are present in the workspace so you don't have to find them in the Explorer view under each workspace folder. For each TC its prerequisites are shown below in a tree structure. This allows to quickly see which TCs a certain TC depends on through its prerequisites without having to open the TC editor. The smaller gray text to the right of the TC name tells in which workspace folder the TC is located. This helps since it's common to have TCs with the same name in a workspace. You can edit a TC by double-clicking on it. This will open the TC in a text editor. When a TC is selected in the Art Build view you can use the toolbar buttons for building, cleaning and running it. Tip It's common to build the same TC many times when developing an Art application. By keeping that TC selected in the Art Build view you can quickly build it by just pressing its Build toolbar button. Building the TC from the Explorer view requires you to first find it which can be cumbersome since the Explorer view selection changes frequently. There are also a few useful commands in the Art Build view toolbar: Refresh In most cases the Art Build view refreshes automatically when TCs are modified. However, if needed you can force a refresh by pressing this button. Clean All Cleans all TCs by removing all target folders in the workspace. Everything contained in the target folder will be deleted (generated code, makefiles, built binaries, etc). A message will be printed in the Art Server channel in case all target folders could be successfully removed, or if not, which ones that could not be deleted. Collapse All Collapses all TCs to not show any prerequisites. Deactivate All Makes all TCs non-active. This makes it easier to switch from building one set of active TCs to another.","title":"Art Build View"},{"location":"building/transformation-configurations/#properties","text":"Below is a table that lists all properties that can be used in a TC. Note that many TC properties have default values and you only need to specify a value for a TC property if its different from the default value. Each property is described in a section of its own below the table. Property Type Default Value commonPreface String N/A compileArguments String N/A compileCommand String \"$CC\" copyrightText String N/A cppCodeStandard Enum string \"C++ 17\" linkArguments String N/A linkCommand String \"$LD\" makeArguments String N/A makeCommand String \"$defaultMakeCommand\" prerequisites List of strings [] sources List of strings [\"*.art\"] targetConfiguration String Depends on current operating system targetConfigurationName String \"default\" targetFolder String Name of TC with \"_target\" appended targetRTSLocation String \"${code_rt_home}/TargetRTS\" topCapsule String N/A unitName String \"UnitName\" userLibraries List of strings []","title":"Properties"},{"location":"building/transformation-configurations/#commonpreface","text":"This property allows you to write some code that will be inserted verbatimly into the header unit file (by default called UnitName.h ). Since the header unit file is included by all files that are generated from the TC, you can use the common preface to define or include definitions that should be available everywhere in generated code.","title":"commonPreface"},{"location":"building/transformation-configurations/#compilearguments","text":"Specifies the arguments for the C++ compiler used for compiling generated C++ code. Note that some compiler arguments may already be specified in the TargetRTS configuration that is used, and the value of this property will be appended to those standard compiler arguments.","title":"compileArguments"},{"location":"building/transformation-configurations/#compilecommand","text":"Specifies which C++ compiler to use for compiling generated C++ code. The default value for this property is $(CC) which is a variable that gets its value from the TargetRTS configuration that is used.","title":"compileCommand"},{"location":"building/transformation-configurations/#copyrighttext","text":"This property may be used to insert a common comment block in the beginning of each generated file, typically a copyright text.","title":"copyrightText"},{"location":"building/transformation-configurations/#cppcodestandard","text":"Defines the C++ language standard to which generated code will conform. The default value for this property is C++ 17 . Other valid values are C++ 98 , C++ 11 , C++ 14 and C++ 20 . Note that the latest version of the TargetRTS requires at least C++ 11, so if you use an older code standard you have to set TargetRTSLocation to an older version of the TargetRTS that doesn't contain any C++ 11 constructs. If you need to compile generated code with a very old compiler that doesn't even support C++ 98 you can set this preference to Older than C++ 98 .","title":"cppCodeStandard"},{"location":"building/transformation-configurations/#inclusionpaths","text":"Specifies additional include paths for the C++ preprocessor in addition to \"standard\" ones such as the location of TargetRTS include files. If your application links with a user library or user object file you need to add the location of the header file(s) that belong to the library or object file. tc.inclusionPaths = [\"/libs/myLib/includes\"]; Note that you don't need to add inclusion paths for target folders of prerequisite TCs. They are added automatically by the make file generator.","title":"inclusionPaths"},{"location":"building/transformation-configurations/#linkarguments","text":"Specifies the arguments for the C++ linker used for linking object files and libraries into an executable. This property is only applicable for TCs that build executables.","title":"linkArguments"},{"location":"building/transformation-configurations/#linkcommand","text":"Specifies which C++ linker to use for linking object files and libraries into an executable. The default value for this property is $(LD) which is a variable that gets its value from the TargetRTS configuration that is used. This property is only applicable for TCs that build executables.","title":"linkCommand"},{"location":"building/transformation-configurations/#makearguments","text":"Specifies the arguments for the make command to be used.","title":"makeArguments"},{"location":"building/transformation-configurations/#makecommand","text":"Specifies which make command to use for processing the generated make file. By default the make command is $defaultMakeCommand which gets its value from which TargetRTS configuration that is used.","title":"makeCommand"},{"location":"building/transformation-configurations/#prerequisites","text":"This property is a list of references to other TCs that need to be built before the current TC. It's typically used to express that a library TC is a prerequisite of an executable TC, which means the library TC needs to be built before the executable TC. Below is an example where an executable TC has a library TC as a prerequisite: tc.prerequisites = [\"../MyLibrary/lib.tcjs\"]; Prerequisite TCs can either be specified using absolute or relative paths. Relative paths are resolved against the location of the TC that has the property set. For more information about this property see Transformation Configuration Prerequisites .","title":"prerequisites"},{"location":"building/transformation-configurations/#sources","text":"By default all Art files that are located in the same folder as the TC will be transformed to C++. Sometimes you may want to exclude some Art files, for example because they are built with another TC, or they contain something you want to temporarily exclude from your application without having to delete the files or comment out their contents. In these cases you can set the sources property to specify exactly which Art files that should be built by the TC. The value of the property is a list of strings that specify glob-style patterns and anti-patterns. An Art file will be transformed if it matches at least one pattern and doesn't match any anti-pattern. Anti-patterns start with the ! character. In both patterns and anti-patterns you can use the wildcards * (matches any sequence of characters) and ? (matches a single character). Below are a few examples: tc.sources = [\"*.art\"]; // Transform all Art files in the folder that contains the TC. This is the default behavior if the \"sources\" property is not set. tc.sources = [\"cap1.art\", \"cap2.art\"]; // Only transform two specific Art files tc.sources = [\"*.art\", \"!code_rt_gen.art\"]; // Transform all Art files except one tc.sources = [\"source??.art\", \"!*_gen.art\"]; // Transform all Art files with names starting with \"source\" and followed by two arbitrary characters. Art files with a name that ends with \"_gen\" are excluded. Example You can find a sample application that has a TC with the \"sources\" property set here .","title":"sources"},{"location":"building/transformation-configurations/#targetconfiguration","text":"Specifies which TargetRTS configuration to use. The TargetRTS location specified in the targetRTSLocation property defines valid values for this property. If this property is not specified, and the default TargetRTS location from the Code RealTime installation is used, then it will get a default value according to the operating system that is used. For Windows a MinGw-based configuration will be used, while for Linux a GCC-based configuration will be used.","title":"targetConfiguration"},{"location":"building/transformation-configurations/#targetconfigurationname","text":"This property maps to a subfolder of the target folder where all generated files that are not source code will be placed. This includes for example makefiles and the files that are produced by these makefiles (typically binaries). The default value of this property is default .","title":"targetConfigurationName"},{"location":"building/transformation-configurations/#targetfolder","text":"Specifies where files generated from the TC will be placed. This property is usually just set to a name, and then a target folder with that name will be created. When the build runs from the UI, that target folder is then added as a workspace folder, which will cause you to be prompted about if you trust the authors of the files in that folder. It's safe to answer yes since all files in that folder are automatically generated by Code RealTime. You can specify an absolute path to a target folder if you prefer generated files to be placed in a certain location that is accessible to everyone in the team, for example a shared network drive. If you instead use a relative path it will get resolved relative to a desired output folder. For a UI build the output folder is set using the setting code-rt.build.outputFolder . When building with the Art Compiler the output folder is instead set using the --out option. If you haven't set the desired output folder, relative paths will instead be resolved against the folder that contains the TC where the targetFolder property is set. Use forward slashes as path separator in this property. If this property is not specified it defaults to the name of the TC, with _target appended. For example, if the TC is called app.tcjs , the target folder will default to app_default .","title":"targetFolder"},{"location":"building/transformation-configurations/#targetrtslocation","text":"Specifies the location of the TargetRTS to use. If no value is set for this property the TargetRTS from the Code RealTime installation will be used. If you want to use another TargetRTS specify the full path to the TargetRTS folder (including that folder itself). Use forward slashes as path separator. For example: tc.targetRTSLocation = \"C:/git/rsarte-target-rts/rsa_rt/C++/TargetRTS\";","title":"targetRTSLocation"},{"location":"building/transformation-configurations/#threads","text":"Specifies the threads used by the application. If no value is set for this property the application will have two default threads: MainThread Runs all capsule instances in the application. It's implemented in the TargetRTS by the RTPeerController class. TimerThread Runs all timers in the application. It's implemented in the TargetRTS by the RTTimerController class. Both these threads will have a stack size of 20kB and run at a normal priority. If your application needs a different thread configuration, or threads with different properties, you need to set the threads property. Note that you cannot just specify threads in addition to the default ones mentioned above, but must always specify all threads. Here is an example where the default threads are present, plus one additional user-defined thread: tc.threads = [ { name: 'MainThread', implClass: 'RTPeerController', stackSize: '20000', priority: 'DEFAULT_MAIN_PRIORITY' }, { name: 'TimerThread', implClass: 'RTTimerController', stackSize: '20000', priority: 'DEFAULT_TIMER_PRIORITY' }, { name: 'MyThread', implClass: 'RTPeerController', stackSize: '20000', priority: 'DEFAULT_MAIN_PRIORITY', logical: [ 'MyLogicalThread' ] } ]; Note that for user-defined threads, like MyThread above, you need to specify one or many logical threads that are mapped to it. These are references to threads that your application use instead of refering directly to a physical thread. This indirection makes it possible to change how capsule instances of your application are run by threads by only modifying the threads property in the TC, without the need to change any application code. Only executable TCs can define physical threads. A library TC can, however, define logical threads. An executable TC that has such a library TC as its prerequisite must map those logical threads to physical threads. Here is an example of a library TC that defines a logical thread. tc.threads = [ `LibraryThread` ]; Note that in this case the threads property contains a list of strings rather than a list of objects as is the case for an executable TC. Read more about threads here .","title":"threads"},{"location":"building/transformation-configurations/#topcapsule","text":"Specifies the capsule that should be automatically incarnated when the executable starts to run. Hence this property is only applicable for TCs that build executables, and for those TCs it's a mandatory property. The top capsule is the entry point of the realtime application. If you don't specify a value for this property, the TC will build a library instead of an executable.","title":"topCapsule"},{"location":"building/transformation-configurations/#unitname","text":"Specifies the base name of the so called unit header and implementation files that are generated from the TC. By default the value of this property is UnitName which means that these unit files will be called UnitName.cpp and UnitName.h . The unit files contain certain information that applies to the whole unit of code that is generated from a TC. The header unit file is included by all files that are generated from the TC.","title":"unitName"},{"location":"building/transformation-configurations/#userlibraries","text":"This property is a list of user libraries that should be linked with the application. The property is only applicable for TCs that build executables. tc.userLibraries = [\"../../libs/libMyLib.a\"]; Each library should be specified with a full or relative path so the linker can find it. If no path is provided you may need to provide a link argument to specify the location(s) where the linker should look for the user libraries.","title":"userLibraries"},{"location":"building/transformation-configurations/#userobjectfiles","text":"This property is a list of user object files that should be linked with the application. The property is only applicable for TCs that build executables. tc.userObjectFiles = [\"../../objs/extra.obj\"]; Each object file should be specified with a full or relative path so the linker can find it. If no path is provided you may need to provide a link argument to specify the location(s) where the linker should look for the object files.","title":"userObjectFiles"},{"location":"releases/","text":"All releases of Code RealTime are available on the Visual Studio Marketplace and the Open VSX Registry . Release notes can be found here .","title":"Releases"},{"location":"releases/CHANGELOG/","text":"1.0.0 (2023-12-12) The product is now renamed to DevOps Code RealTime and in addition to the Community Edition a Commercial Edition is also available. With the Commercial Edition comes support entitlement, the right to use the product and generated applications for commercial purposes, and access to the TargetRTS source files which makes it possible to build applications for any target platform. The Clang language server clangd is now supported. It is available both for Visual Studio Code and Eclipse Theia . The C++ code generator now supports \"receive-any\" events, i.e. the use of an asterisk for specifying a trigger that handles any event received on a port. For an example, see this sample . 0.0.11 (2023-11-09 10:30) A new validation rule was implemented in the C++ code generator to detect if there are ambiguous outgoing transitions for a state, i.e. transitions with identical triggers and no guard conditions. Such unreachable transitions are now reported as a problem (with warning severity as default). A comment is also added in generated code to mark the unreachable code where functions of such unreachable transitions are called. Several new validation rules now check the correctness of the threads property in a TC. For example, an attempt to map the same logical thread to different physical threads are reported as a problem. Previously, such problems were only detected when compiling or linking the application, or even at run-time. The C++ code generator now supports the deep history pseudostate ( history* ). For an example, see this sample . The C++ code generator now supports the const_rtdata property. By setting this property to false on a transition, the rtdata parameter of the transition function will be non-const. This, for example, allows it to be moved instead of copied, which can be more efficient. For an example, see this sample . The validation rule ART_0001_invalidNameCpp has been extended to now also detect if names chosen for Art elements will clash with names in generated code or the TargetRTS. The C++ code generator now supports excluded transitions. For an example, see this sample . It's now possible to delete ports and parts from a structure diagram by selecting them and then pressing the Delete key or using the Delete command in the popup menu that appears when pressing Ctrl+Space. The C++ code generator now supports junctions and the guards on their outgoing transitions. For an example, see this sample . A new validation rule CPP_4002_guardedInitialTransition now detects if there are junctions in the initial transition without unguarded outgoing transitions. With such initial transitions there is a risk that no initial state will be entered, which would break the functioning of the state machine. A new command \"Deactivate All\" in the Art Build view can be used for quickly making all TCs in the workspace non-active. This makes it faster to switch from building one set of active TCs to another. Several validation rules have been updated to mark problems more accurately in an Art file. If an element spans multiple lines in the Art file (e.g. a capsule or state machine) then if the whole element would be marked, problems within the element cannot be seen in the Art file. Now smaller parts of such elements are marked such as only the element name or a certain keyword within the element. In addition to a cleaner look this also makes navigation from problems arrive closer to where the problem is located. The TC property \"userLibraries\" is now supported (both in TC editor and UI). It can be used for specifying a list of libraries to pass to the linker. The C++ code generator now supports capsule factories on parts by means of the rt::create and rt::destroy code snippets. For an example, see this sample . The TargetRTS and C++ code generator now supports the predefined type long long . A target configuration for the Clang compiler for MacOs is now provided. The Art Compiler now prints related elements for validation problems. This means that you now get the same amount of details about a validation problem when building from command-line as from the UI. When building from the UI, TCs are now validated and found problems are reported in the Art Build output channel. Any error found during this validation will stop the build. Previously such errors were only reported when building from the command-line, and the UI build would proceed even in case errors were found, which often lead to other problems later in the build process. The TC property \"userObjectFiles\" is now supported (both in TC editor and UI). It can be used for specifying a list of object files to pass to the linker. The TC property \"inclusionPaths\" is now supported (both in TC editor and UI). It can be used for specifying a list of include paths for the preprocessor. Some new code actions (\"quick fixes\") were implemented for certain validation rules. 0.0.10 (2023-09-13 14:22) The C++ code generator now supports generation of type descriptors. When you declare a type in an rt::decl code snippet you can tag it with a C++ attribute to tell the code generator how it should generate the type descriptor. Currently two attributes are supported: rt::auto_descriptor (for fully automatic type descriptor generation) and rt::manual_descriptor (when you prefer to write the type descriptor manually). Read more about this feature in the documentation . The C++ code generator now supports local bindings (i.e. a connector between two behavior ports on the same capsule). This makes it possible for a capsule to send events to itself. Read more about this feature here . The support for state machine inheritance in the C++ code generator has been much improved. For an example, see this sample . Two new validation rules were implemented for checks related to ports. See ART_0034_servicePortWithoutEvents and ART_0035_timerServicePort . The C++ code generator now performs additional validation of an Art file when it's translated to C++. Dedicated validation rules are used for this purpose and they can be enabled/disabled and have their severity customized in the same way as other validation rules. Found problems appear in the Art file, in the Problems view and in diagrams. For more information see the documentation . You can now use colors on most symbols and lines also in class and structure diagrams. Use of certain colors have been improved to ensure that diagrams remain readable when custom symbol colors are used. For example, background patterns printed on optional and plugin parts in structure diagrams now use a light color if the background color is dark, and a dark color if the background color is light. Navigation from code snippets in generated C++ files to the source Art files is now supported. The file URIs in the USR-comments surrounding the code snippets can now be ctrl-clicked in order to perform the navigation. Structure diagrams can now be edited. You can create ports and parts, and also use the Properties view for viewing and editing some of the properties of these elements. A new \"Art Build\" view is now available. It shows all TCs in the workspace and for each TC its prerequisites are shown as a tree structure. Common commands are available on the TCs, such as Clean, Build and Run. A TC that is often built can be selected in the \"Art Build\" view, so that it's not necessary to find it in the Explorer view each time it should be built. The new view also provides a button for invoking the \"Clean All\" command that previously only could be invoked through the Command Palette. It's now possible to specify physical and logical threads in a TC. The C++ code generator uses this information for creating those physical threads and application code can reference the logical threads when a capsule instance is created. For more information see the documentation . Note that currently thread information can only be specified in the TC text editor (the form-based editor doesn't yet support it). Validation markers for showing problems in diagrams are now also supported on labels within class diagram symbols. Hence, it's now possible to see validation problems on ports, parts and events. 0.0.9 (2023-07-20 07:39) It's now possible to build multiple variants of an application by means of a feature called Build Variants . You can use JavaScript for dynamically customizing a TC at build-time, in order to implement high-level build variant settings. Build variants are implemented in the Art Compiler by means of two new options: --buildConfig and --buildVariants . For an example, see this sample . A new command \"Clean All\" is now available. It will remove all generated code in the workspace and also remove all generated workspace folders. It's equivalent to, but more convenient than, invoking the \"Clean\" command on each TC individually. Invoke \"Clean All\" from the command palette (Ctrl+Shift+P). The C++ code generator now supports multiple inheritance for capsules. A capsule can at most inherit one other capsule, but now it's in addition also possible to inherit any number of C++ types. For an example, see this sample . The C++ code generator now assigns the correct type for the rtdata parameter in transition functions generated for non-triggered transitions. Previously this only worked for triggered transitions, and rtdata in a non-triggered transition would become untyped (const void *). Now the code generator analyzes the whole transition chain to use the more specific type also for functions generated for non-triggered transitions. For an example, see this sample . The C++ code generator now supports specifying a guard condition either using a C++ boolean expression, or a C++ return statement that returns a boolean expression. In the former case the code generator will automatically add the return keyword in generated code. Code-to-art synchronization also handles both these cases. When a TC is built from the UI using the context menu command Build (or Run on a TC that was not built already), the Problems view is now scanned to check if it contains at least one error related to the built TC, or a prerequisite TC. If so, a dialog will appear to ask if you really want to proceed with the build. It's recommended to cancel the build, fix the error, and then redo the build. If you choose to proceed with the build you may get either build or run-time errors in the built application. A new setting rtistic.build.cancelOnError can be used to control this behavior. Redefined elements are now drawn in diagrams with a different line style (\"dashed-dot-dot\"), to make them easier to distinguish from inherited elements (that are still drawn with a dashed line style). Labels for redefined elements are still drawn with green color to further emphasize the difference between a redefined and an inherited element in diagrams. RTist in Code is now available as a Docker image on DockerHub . You can deploy this image to get the latest version of RTist in Code running in Eclipse Theia. The presence of elements in the global scope with clashing names is now detected across the whole workspace. All source files that will be built by the active TC are checked. Previously such problems were not detected until linking the built application. Launch configurations are now supported for running an application built by a TC. This is a more flexible way to launch applications than using the Run context menu of a TC. You can set environment variables and command-line arguments for the launched application, as well as its current working directory. You can also easily terminate and relaunch the application using the launch toolbar. The C++ code generator now supports compound transitions. Each individual transition of the compound transition is translated to a separate C++ function to avoid code duplication. Also, for increased code readability the numbers representing states are now followed by the state name in a comment. For an example, see this sample . A new sample PiComputer is now available. It contains a few collaborating capsules with hierarchical state machines and implements a computation of Pi. The C++ code generator now supports choices. For an example, see this sample . 0.0.8 (2023-05-31 06:09) A new setting rtistic.build.outputFolder is now available. It can be used for setting a common output folder for generated code, and TCs where the targetFolder specifies a relative path will now be resolved against that output folder. This new setting hence plays the same role for a UI build as the --out option does when building with the Art Compiler from the command-line. Several small sample applications are now available in the RTist in Code GitHub Repo . These are written as tests of the Art Compiler and the TargetRTS, but can also be useful for learning more about the Art language and RTist in Code. TC prerequisites are now taken into account when generating the c_cpp_properties.json file. This prevents references to definitions in prerequisite libraries to appear as broken in the UI when looking at generated code, and it also enables features such as Content Assist, hover tooltips etc for those definitions. TC prerequisites and the \"sources\" TC property are now taken into account when binding references in the UI. It's required to set the TC as active so name lookup can find the correct prerequisites. This means that name binding rules used in the UI now are aligned with how the build works. It's now possible to redirect a transition in a state diagram. Select the transition to redirect and the new source or target element in the diagram. Then use one of the new commands in the Ctrl+Space popup menu: Set Transition Source or Set Transition Target . Both commands have keybindings so that you don't need to always open the popup menu. The C++ code generator now supports event inheritance for protocols. For an example, see this sample . Redefined events are also supported. For an example, see this sample . The C++ code generator now supports part inheritance for capsules. For an example, see this sample . A new navigation command \"Open Inherited State Diagram\" is available in state diagrams. You can use it for navigating from the state diagram of a derived capsule to the state diagram of the base capsule. If an inherited, excluded or redefined element is selected in the derived diagram the command will open the state diagram where the element is defined. The form-based TC editor now provides graphical widgets for editing the \"prerequisites\" and \"sources\" properties. It also performs some validations to detect errors in these properties. When the \"Set as Active\" command is invoked on a TC, the prerequisites of the TC will also be set as active. This helps to ensure consistency in the UI and when building the TC. A target configuration for building with Clang (ver. 16) on Windows is now provided. A target configuration for building with Clang (ver. 15) for the Windows simulator for the VxWorks RTOS (ver. 7) is now provided. 0.0.7 (2023-04-19 11:56) The popup menu that appears when pressing Ctrl+Space in a state diagram now contains commands for creating elements in the state machine. These commands are the same as appear in the Content Assist menu in the Art text editor. For example, you can create states and pseudo states this way. The created element is added last in the state machine in the Art file. If a state is selected the popup menu contains commands for creating elements inside the state. If required, it will first be converted to a composite state. You can also create transitions using this popup menu. Select first the source and then the target and then invoke a command for creating the transition. You can now open diagrams for an element by selecting it in a diagram and then open the Ctrl+Space popup menu. For example, if you select a capsule part in a structure diagram, the popup menu contains commands for opening the state, structure or class diagram of the capsule that types the part. Previously it was necessary to first navigate to the capsule part in the Art file, then from there to the capsule, and finally from there the diagram could be opened. Now this navigation can be performed in a single step without involving the Art file at all. State diagram elements can now be deleted by using a new Delete command in the popup menu that appears when pressing Ctrl+Space in a state diagram. It's now possible to remove a color from a symbol or line by selecting it in the state diagram and then press the trashcan icon that appears in the Properties view. When performing a diagram command that modifies the Art file, the cursor is now set at an location in the Art file that corresponds to the changed diagram element. If possible, relevant text is also selected in the Art file. This serves two purposes; it becomes easier to notice the impact of the change in the Art file, and Undo/Redo will work correctly. Transformation configurations are now validated to detect inconsistent and incorrect property values. For example, you will get a warning if you build a library but a TC property is used that only is applicable when building an executable. And you will get an error if a TC property specifies a value of incorrect type. A new TC property, \"sources\", can now be used for controlling which Art files that should be transformed to C++ by the code generator. It is a list of glob-style patterns and anti-patterns. A file will be transformed if it matches at least one pattern (e.g. *.art ) and doesn't match any anti-pattern (e.g. !exclude.art ). This property is not yet supported by the form-based TC editor, but can be set in the .tcjs file in order to exclude one or several Art files in the workspace folder where the TC is located. The TC editor description tooltips now have a background color that is dynamically adjusted to make it visible regardless of selected color theme. The Art text editor now provides a \"code lens\" for building and running a capsule without first having to create a TC. The code lens appears as a \"Run\" hyperlink shown just above a capsule. The capsule will be built with default settings into an executable where it runs as the top capsule. Doxygen generated HTML for the TargetRTS C++ API is now included in the RTist in Code documentation and linked from the Target RunTime System chapter . A first version of the Art Compiler is now ready and included in the RTist in Code extension. It is a command-line tool which can be used for building a transformation configuration and a set of Art files into a library or executable, in the same way as can be done from the UI. It makes it possible to automate your builds. Read more about the Art Compiler here . A new TC property, \"prerequisites\", can now be used for expressing build dependencies between TCs. It is a list of references to other TCs (absolute or relative paths) that need to be built first, before the current TC is built. By setting a library TC as a prerequisite of an executable TC, the library will be built before the executable, and the executable will also automatically link with the library. This property is not yet supported by the form-based TC editor, but can be set in the .tcjs file. 0.0.6 (2023-03-09 18:28) Java 17 is now required for running the Art language server. Using Java 17 instead of Java 11 gives some performance improvements and enables use of more modern Java. Information about which Java version that is used is printed in the Art Server output channel when the RTist in Code extension is activated. The popup menu that appears when pressing Ctrl+Space in a diagram now contains commands for navigating to the other kinds of diagram for the same Art element. For example, in a state diagram for capsule \"X\" there are commands for opening the class or structure diagram of capsule \"X\". It's now possible to open more than one diagram in one go. You can select multiple Art files in the Explorer, and then invoke a command for opening diagrams from the context menu. If a file contains multiple root Art elements, the diagram will be opened for the first one. A diagnostic icon (error, warning or information) that is shown in a diagram now has a tooltip that shows the diagnostic message as well as a hyperlink to the documentation. RTist in Code now provides a Walkthrough guide on the Welcome page. The Walkthrough guides new users to how to build and run a sample application. Diagram properties set in the Properties view can now be restored to their default value by means of a \"Restore default\" trashcan button that appears for properties that have a non-default value. The presence of this button also helps to highlight those properties that have been set to a non-default value. States, pseudo states and transitions can now be deleted by selecting them in a state diagram and pressing the Delete key. More than one such element can be deleted at the same time by using Ctrl+click for selecting multiple symbols or lines before pressing the Delete key. The form-based TC editor now shows a TC property name as a hyperlink in case a value is set for that property in the .tcjs file. The hyperlink is useful for navigation and also helps to highlight which TC properties that have non-default values set. The form-based TC editor now shows a trashcan button for properties that have a value set. The button can be used for deleting the value (i.e. to restore the default value of the property) and also helps to highlight which TC properties that have non-default values set. The form-based TC editor now updates immediately when a TC property is modified in the .tcjs file. It's no longer necessary to save the .tcjs file for changes to be reflected. Choices and junctions can now be created with Content Assist in the Art text editor inside a state machine and inside a composite state. It's now possible to build a library, rather than an executable, from a TC. If the built TC has the topCapsule property set an executable will be built. Otherwise a library will be built. 0.0.5 (2023-01-26 06:59) Common diagram commands can now be invoked using the keyboard by pressing Ctrl+Space and selecting the command in the popup menu that appears. The following commands are available: Zoom In, Zoom Out, Center, Expand All, Collapse All The presence of internal transitions on a state is now shown by means of an icon on the state symbol in a state diagram. As before the internal transitions will be shown in the Properties view if such a state symbol is selected. When navigating to an element in an Art file the text editor will now automatically scroll both vertically and horizontally (if necessary) to make sure the element becomes visible. TC properties are now validated when edited (both textually and in the UI), and detected problems are reported. For example, it's validated that the specified top capsule exists and that the C++ language standard is set to a valid value. Custom colors can now be specified for all elements in state diagrams (transitions, states and pseudo states). You can directly change the color from the diagram Properties view (i.e. it's no longer necessary to first navigate to the Art file and change the color there). Code formatting and content assist was improved to make rt::properties sections foldable in the Art editor. A new command \"Fold All Properties\" was added. It collapses all rt::properties sections in an Art file (similar to how \"Fold All C++ Code\" works for C++ code sections). It can be useful for Art files that contain lots of properties. The entry and exit actions of a composite state can now be folded in the Art file, like other C++ code snippets. The command \"Fold All C++ Code\" will therefore be able to fold also these code snippets. Code generation now supports entry and exit actions for states. State diagrams now show diagnostics (errors, warnings and informations) using icons on symbols and lines. A new preference ( rtistic.diagram.showDiagnostics ) controls if they should be shown or not. More information is now printed in the Art Build output channel during a build. For example, various useful messages emitted by the C++ code generator may now be printed there. Messages emitted by build tools, e.g. the C++ compiler, are still printed in the Terminal view. In case the build fails a hyperlink to open the Terminal will be present in the Art Build output channel. A target configuration for the latest version of the GCC compiler (ver. 12) on Linux is now provided. 0.0.4 (2022-12-21 13:11) A target configuration for the latest version of the MinGw compiler (ver. 12.2) is now provided. Better support for Linux platform. Improved makefile generation for incremental builds. More information for internal transitions are now shown in the Properties view. The triggers of the internal transitions are shown in a similar way as in the Outline view. Also, the blue and yellow icons representing the effect and guard code snippets for the internal transitions are shown and can be double-clicked in order to navigate to the code snippets in the Art file. If a port has multiplicity > 1 it is now shown in structure diagrams. The form-based TC editor is now automatically refreshed when the underlying .tcjs file is modified and saved. It's now possible to navigate to the top capsule from a TC file by Ctrl+click on the capsule name. Content assist (Ctrl+space) is now supported for TC property values. Valid values appear in a popup when typing the = character. If there is not a fixed list of valid values, the expected value type (e.g. string) will be shown. Cross-references now bind across workspace folders. This makes it possible to split an application into several workspace folders. For example, Art files built into a library can now be placed in its own folder, and be used from Art files outside that folder. A composite state can now only be expanded if it contains at least one nested state. Previously the Expand button was shown also when the state only contained entry or exit points, which was misleading since expanding such a state didn't reveal anything new that could not already be seen. Attempting to open a diagram using the Art editor context menu now works even when the cursor is not placed within an Art element that can be shown in the diagram. In this case a \"quick pick\" will appear where you can choose one of the elements that are present in the Art file. Hence, this behavior is now the same as when you open diagrams from the Explorer context menu. Protocols now support the rt::header_preface and rt::header_ending code snippets. In particular rt::header_preface is useful for including header files with user-defined types used in the protocol. A new output channel called Art Server is now available and can be seen in the Output view. It's used by the Art language server for printing diagnostic messages (usually internal errors), and can be useful for troubleshooting problems. A new output channel called Art Build is now available and can be seen in the Output view. It's used when building a TC. For example, messages are printed when a build starts and finishes. The editor title for diagrams now contain the name of the Art element. This makes it easier to work with multiple open diagrams at the same time. Content assist now supports creating non-triggered transitions in a state machine. Code generation now supports transition guards, events with parameters of predefined types, connectors between local port and inner structure. It's now possible to set custom colors to be used in diagrams by means of a new color property. Currently this is supported for initial and triggered transitions. 0.0.3 (2022-11-23 12:53) The graphical appearance of symbols in class diagrams has improved. Now a line separates the name from properties such as ports and events. Also, icons were added for the properties to make it easier to understand the diagram. The Expand All/Collapse All commands in the Properties view now work also for structure diagrams. Cycles in the composition hierarchy are detected and reported with an error message if found. It's now possible to build a TC using a context menu command Build . And if it produces an executable it's possible to launch it with another context menu command Run . Of course, it's still possible to manually build and run from the terminal. The RTist in Code documentation was extended with several new topics and the landing page was improved. New color themes for better syntax highlighting of Art files (and embedded C++ code) are now available. See this topic for more information. It's now possible to edit TC properties using a form-based editor, as an alternative to directly editing the .tcjs file. The form-based editor is invoked from a context menu on the TC called Edit Properties (UI) . New TC properties are now supported for specifying which make command to use for building generated code, as well as the make arguments. The new properties are makeCommand and makeArguments . The existing TC properties targetProject and targetServicesLibrary were renamed to targetFolder and targetRTSLocation respectively. Fixed several Linux specific problems in the language server. The GLSP library was uplifted to version 1.0. Read about the improvements it brings to diagrams here . A problem with automatically expanding symbols when doing a Rename from a diagram was fixed. When renaming an element, for which one or several diagrams have been opened, the diagrams stay open (previously they were automatically closed as a side-effect of the rename). Navigation from a C++ code snippet to generated C++ code using the hyperlink in the code snippet tooltip now works even if the cursor is not placed inside the code snippet. Target configurations for the latest version of the Visual Studio compiler (Visual Studio 2022, ver. 17) are now provided, both for 32 and 64 bit builds. 0.0.2 (2022-10-20) First public release. Initial support for the Art language, graphical diagrams, transformation configurations and C++ code generation.","title":"1.0.0 (2023-12-12)"},{"location":"releases/CHANGELOG/#100-2023-12-12","text":"The product is now renamed to DevOps Code RealTime and in addition to the Community Edition a Commercial Edition is also available. With the Commercial Edition comes support entitlement, the right to use the product and generated applications for commercial purposes, and access to the TargetRTS source files which makes it possible to build applications for any target platform. The Clang language server clangd is now supported. It is available both for Visual Studio Code and Eclipse Theia . The C++ code generator now supports \"receive-any\" events, i.e. the use of an asterisk for specifying a trigger that handles any event received on a port. For an example, see this sample .","title":"1.0.0 (2023-12-12)"},{"location":"releases/CHANGELOG/#0011-2023-11-09-1030","text":"A new validation rule was implemented in the C++ code generator to detect if there are ambiguous outgoing transitions for a state, i.e. transitions with identical triggers and no guard conditions. Such unreachable transitions are now reported as a problem (with warning severity as default). A comment is also added in generated code to mark the unreachable code where functions of such unreachable transitions are called. Several new validation rules now check the correctness of the threads property in a TC. For example, an attempt to map the same logical thread to different physical threads are reported as a problem. Previously, such problems were only detected when compiling or linking the application, or even at run-time. The C++ code generator now supports the deep history pseudostate ( history* ). For an example, see this sample . The C++ code generator now supports the const_rtdata property. By setting this property to false on a transition, the rtdata parameter of the transition function will be non-const. This, for example, allows it to be moved instead of copied, which can be more efficient. For an example, see this sample . The validation rule ART_0001_invalidNameCpp has been extended to now also detect if names chosen for Art elements will clash with names in generated code or the TargetRTS. The C++ code generator now supports excluded transitions. For an example, see this sample . It's now possible to delete ports and parts from a structure diagram by selecting them and then pressing the Delete key or using the Delete command in the popup menu that appears when pressing Ctrl+Space. The C++ code generator now supports junctions and the guards on their outgoing transitions. For an example, see this sample . A new validation rule CPP_4002_guardedInitialTransition now detects if there are junctions in the initial transition without unguarded outgoing transitions. With such initial transitions there is a risk that no initial state will be entered, which would break the functioning of the state machine. A new command \"Deactivate All\" in the Art Build view can be used for quickly making all TCs in the workspace non-active. This makes it faster to switch from building one set of active TCs to another. Several validation rules have been updated to mark problems more accurately in an Art file. If an element spans multiple lines in the Art file (e.g. a capsule or state machine) then if the whole element would be marked, problems within the element cannot be seen in the Art file. Now smaller parts of such elements are marked such as only the element name or a certain keyword within the element. In addition to a cleaner look this also makes navigation from problems arrive closer to where the problem is located. The TC property \"userLibraries\" is now supported (both in TC editor and UI). It can be used for specifying a list of libraries to pass to the linker. The C++ code generator now supports capsule factories on parts by means of the rt::create and rt::destroy code snippets. For an example, see this sample . The TargetRTS and C++ code generator now supports the predefined type long long . A target configuration for the Clang compiler for MacOs is now provided. The Art Compiler now prints related elements for validation problems. This means that you now get the same amount of details about a validation problem when building from command-line as from the UI. When building from the UI, TCs are now validated and found problems are reported in the Art Build output channel. Any error found during this validation will stop the build. Previously such errors were only reported when building from the command-line, and the UI build would proceed even in case errors were found, which often lead to other problems later in the build process. The TC property \"userObjectFiles\" is now supported (both in TC editor and UI). It can be used for specifying a list of object files to pass to the linker. The TC property \"inclusionPaths\" is now supported (both in TC editor and UI). It can be used for specifying a list of include paths for the preprocessor. Some new code actions (\"quick fixes\") were implemented for certain validation rules.","title":"0.0.11 (2023-11-09 10:30)"},{"location":"releases/CHANGELOG/#0010-2023-09-13-1422","text":"The C++ code generator now supports generation of type descriptors. When you declare a type in an rt::decl code snippet you can tag it with a C++ attribute to tell the code generator how it should generate the type descriptor. Currently two attributes are supported: rt::auto_descriptor (for fully automatic type descriptor generation) and rt::manual_descriptor (when you prefer to write the type descriptor manually). Read more about this feature in the documentation . The C++ code generator now supports local bindings (i.e. a connector between two behavior ports on the same capsule). This makes it possible for a capsule to send events to itself. Read more about this feature here . The support for state machine inheritance in the C++ code generator has been much improved. For an example, see this sample . Two new validation rules were implemented for checks related to ports. See ART_0034_servicePortWithoutEvents and ART_0035_timerServicePort . The C++ code generator now performs additional validation of an Art file when it's translated to C++. Dedicated validation rules are used for this purpose and they can be enabled/disabled and have their severity customized in the same way as other validation rules. Found problems appear in the Art file, in the Problems view and in diagrams. For more information see the documentation . You can now use colors on most symbols and lines also in class and structure diagrams. Use of certain colors have been improved to ensure that diagrams remain readable when custom symbol colors are used. For example, background patterns printed on optional and plugin parts in structure diagrams now use a light color if the background color is dark, and a dark color if the background color is light. Navigation from code snippets in generated C++ files to the source Art files is now supported. The file URIs in the USR-comments surrounding the code snippets can now be ctrl-clicked in order to perform the navigation. Structure diagrams can now be edited. You can create ports and parts, and also use the Properties view for viewing and editing some of the properties of these elements. A new \"Art Build\" view is now available. It shows all TCs in the workspace and for each TC its prerequisites are shown as a tree structure. Common commands are available on the TCs, such as Clean, Build and Run. A TC that is often built can be selected in the \"Art Build\" view, so that it's not necessary to find it in the Explorer view each time it should be built. The new view also provides a button for invoking the \"Clean All\" command that previously only could be invoked through the Command Palette. It's now possible to specify physical and logical threads in a TC. The C++ code generator uses this information for creating those physical threads and application code can reference the logical threads when a capsule instance is created. For more information see the documentation . Note that currently thread information can only be specified in the TC text editor (the form-based editor doesn't yet support it). Validation markers for showing problems in diagrams are now also supported on labels within class diagram symbols. Hence, it's now possible to see validation problems on ports, parts and events.","title":"0.0.10 (2023-09-13 14:22)"},{"location":"releases/CHANGELOG/#009-2023-07-20-0739","text":"It's now possible to build multiple variants of an application by means of a feature called Build Variants . You can use JavaScript for dynamically customizing a TC at build-time, in order to implement high-level build variant settings. Build variants are implemented in the Art Compiler by means of two new options: --buildConfig and --buildVariants . For an example, see this sample . A new command \"Clean All\" is now available. It will remove all generated code in the workspace and also remove all generated workspace folders. It's equivalent to, but more convenient than, invoking the \"Clean\" command on each TC individually. Invoke \"Clean All\" from the command palette (Ctrl+Shift+P). The C++ code generator now supports multiple inheritance for capsules. A capsule can at most inherit one other capsule, but now it's in addition also possible to inherit any number of C++ types. For an example, see this sample . The C++ code generator now assigns the correct type for the rtdata parameter in transition functions generated for non-triggered transitions. Previously this only worked for triggered transitions, and rtdata in a non-triggered transition would become untyped (const void *). Now the code generator analyzes the whole transition chain to use the more specific type also for functions generated for non-triggered transitions. For an example, see this sample . The C++ code generator now supports specifying a guard condition either using a C++ boolean expression, or a C++ return statement that returns a boolean expression. In the former case the code generator will automatically add the return keyword in generated code. Code-to-art synchronization also handles both these cases. When a TC is built from the UI using the context menu command Build (or Run on a TC that was not built already), the Problems view is now scanned to check if it contains at least one error related to the built TC, or a prerequisite TC. If so, a dialog will appear to ask if you really want to proceed with the build. It's recommended to cancel the build, fix the error, and then redo the build. If you choose to proceed with the build you may get either build or run-time errors in the built application. A new setting rtistic.build.cancelOnError can be used to control this behavior. Redefined elements are now drawn in diagrams with a different line style (\"dashed-dot-dot\"), to make them easier to distinguish from inherited elements (that are still drawn with a dashed line style). Labels for redefined elements are still drawn with green color to further emphasize the difference between a redefined and an inherited element in diagrams. RTist in Code is now available as a Docker image on DockerHub . You can deploy this image to get the latest version of RTist in Code running in Eclipse Theia. The presence of elements in the global scope with clashing names is now detected across the whole workspace. All source files that will be built by the active TC are checked. Previously such problems were not detected until linking the built application. Launch configurations are now supported for running an application built by a TC. This is a more flexible way to launch applications than using the Run context menu of a TC. You can set environment variables and command-line arguments for the launched application, as well as its current working directory. You can also easily terminate and relaunch the application using the launch toolbar. The C++ code generator now supports compound transitions. Each individual transition of the compound transition is translated to a separate C++ function to avoid code duplication. Also, for increased code readability the numbers representing states are now followed by the state name in a comment. For an example, see this sample . A new sample PiComputer is now available. It contains a few collaborating capsules with hierarchical state machines and implements a computation of Pi. The C++ code generator now supports choices. For an example, see this sample .","title":"0.0.9 (2023-07-20 07:39)"},{"location":"releases/CHANGELOG/#008-2023-05-31-0609","text":"A new setting rtistic.build.outputFolder is now available. It can be used for setting a common output folder for generated code, and TCs where the targetFolder specifies a relative path will now be resolved against that output folder. This new setting hence plays the same role for a UI build as the --out option does when building with the Art Compiler from the command-line. Several small sample applications are now available in the RTist in Code GitHub Repo . These are written as tests of the Art Compiler and the TargetRTS, but can also be useful for learning more about the Art language and RTist in Code. TC prerequisites are now taken into account when generating the c_cpp_properties.json file. This prevents references to definitions in prerequisite libraries to appear as broken in the UI when looking at generated code, and it also enables features such as Content Assist, hover tooltips etc for those definitions. TC prerequisites and the \"sources\" TC property are now taken into account when binding references in the UI. It's required to set the TC as active so name lookup can find the correct prerequisites. This means that name binding rules used in the UI now are aligned with how the build works. It's now possible to redirect a transition in a state diagram. Select the transition to redirect and the new source or target element in the diagram. Then use one of the new commands in the Ctrl+Space popup menu: Set Transition Source or Set Transition Target . Both commands have keybindings so that you don't need to always open the popup menu. The C++ code generator now supports event inheritance for protocols. For an example, see this sample . Redefined events are also supported. For an example, see this sample . The C++ code generator now supports part inheritance for capsules. For an example, see this sample . A new navigation command \"Open Inherited State Diagram\" is available in state diagrams. You can use it for navigating from the state diagram of a derived capsule to the state diagram of the base capsule. If an inherited, excluded or redefined element is selected in the derived diagram the command will open the state diagram where the element is defined. The form-based TC editor now provides graphical widgets for editing the \"prerequisites\" and \"sources\" properties. It also performs some validations to detect errors in these properties. When the \"Set as Active\" command is invoked on a TC, the prerequisites of the TC will also be set as active. This helps to ensure consistency in the UI and when building the TC. A target configuration for building with Clang (ver. 16) on Windows is now provided. A target configuration for building with Clang (ver. 15) for the Windows simulator for the VxWorks RTOS (ver. 7) is now provided.","title":"0.0.8 (2023-05-31 06:09)"},{"location":"releases/CHANGELOG/#007-2023-04-19-1156","text":"The popup menu that appears when pressing Ctrl+Space in a state diagram now contains commands for creating elements in the state machine. These commands are the same as appear in the Content Assist menu in the Art text editor. For example, you can create states and pseudo states this way. The created element is added last in the state machine in the Art file. If a state is selected the popup menu contains commands for creating elements inside the state. If required, it will first be converted to a composite state. You can also create transitions using this popup menu. Select first the source and then the target and then invoke a command for creating the transition. You can now open diagrams for an element by selecting it in a diagram and then open the Ctrl+Space popup menu. For example, if you select a capsule part in a structure diagram, the popup menu contains commands for opening the state, structure or class diagram of the capsule that types the part. Previously it was necessary to first navigate to the capsule part in the Art file, then from there to the capsule, and finally from there the diagram could be opened. Now this navigation can be performed in a single step without involving the Art file at all. State diagram elements can now be deleted by using a new Delete command in the popup menu that appears when pressing Ctrl+Space in a state diagram. It's now possible to remove a color from a symbol or line by selecting it in the state diagram and then press the trashcan icon that appears in the Properties view. When performing a diagram command that modifies the Art file, the cursor is now set at an location in the Art file that corresponds to the changed diagram element. If possible, relevant text is also selected in the Art file. This serves two purposes; it becomes easier to notice the impact of the change in the Art file, and Undo/Redo will work correctly. Transformation configurations are now validated to detect inconsistent and incorrect property values. For example, you will get a warning if you build a library but a TC property is used that only is applicable when building an executable. And you will get an error if a TC property specifies a value of incorrect type. A new TC property, \"sources\", can now be used for controlling which Art files that should be transformed to C++ by the code generator. It is a list of glob-style patterns and anti-patterns. A file will be transformed if it matches at least one pattern (e.g. *.art ) and doesn't match any anti-pattern (e.g. !exclude.art ). This property is not yet supported by the form-based TC editor, but can be set in the .tcjs file in order to exclude one or several Art files in the workspace folder where the TC is located. The TC editor description tooltips now have a background color that is dynamically adjusted to make it visible regardless of selected color theme. The Art text editor now provides a \"code lens\" for building and running a capsule without first having to create a TC. The code lens appears as a \"Run\" hyperlink shown just above a capsule. The capsule will be built with default settings into an executable where it runs as the top capsule. Doxygen generated HTML for the TargetRTS C++ API is now included in the RTist in Code documentation and linked from the Target RunTime System chapter . A first version of the Art Compiler is now ready and included in the RTist in Code extension. It is a command-line tool which can be used for building a transformation configuration and a set of Art files into a library or executable, in the same way as can be done from the UI. It makes it possible to automate your builds. Read more about the Art Compiler here . A new TC property, \"prerequisites\", can now be used for expressing build dependencies between TCs. It is a list of references to other TCs (absolute or relative paths) that need to be built first, before the current TC is built. By setting a library TC as a prerequisite of an executable TC, the library will be built before the executable, and the executable will also automatically link with the library. This property is not yet supported by the form-based TC editor, but can be set in the .tcjs file.","title":"0.0.7 (2023-04-19 11:56)"},{"location":"releases/CHANGELOG/#006-2023-03-09-1828","text":"Java 17 is now required for running the Art language server. Using Java 17 instead of Java 11 gives some performance improvements and enables use of more modern Java. Information about which Java version that is used is printed in the Art Server output channel when the RTist in Code extension is activated. The popup menu that appears when pressing Ctrl+Space in a diagram now contains commands for navigating to the other kinds of diagram for the same Art element. For example, in a state diagram for capsule \"X\" there are commands for opening the class or structure diagram of capsule \"X\". It's now possible to open more than one diagram in one go. You can select multiple Art files in the Explorer, and then invoke a command for opening diagrams from the context menu. If a file contains multiple root Art elements, the diagram will be opened for the first one. A diagnostic icon (error, warning or information) that is shown in a diagram now has a tooltip that shows the diagnostic message as well as a hyperlink to the documentation. RTist in Code now provides a Walkthrough guide on the Welcome page. The Walkthrough guides new users to how to build and run a sample application. Diagram properties set in the Properties view can now be restored to their default value by means of a \"Restore default\" trashcan button that appears for properties that have a non-default value. The presence of this button also helps to highlight those properties that have been set to a non-default value. States, pseudo states and transitions can now be deleted by selecting them in a state diagram and pressing the Delete key. More than one such element can be deleted at the same time by using Ctrl+click for selecting multiple symbols or lines before pressing the Delete key. The form-based TC editor now shows a TC property name as a hyperlink in case a value is set for that property in the .tcjs file. The hyperlink is useful for navigation and also helps to highlight which TC properties that have non-default values set. The form-based TC editor now shows a trashcan button for properties that have a value set. The button can be used for deleting the value (i.e. to restore the default value of the property) and also helps to highlight which TC properties that have non-default values set. The form-based TC editor now updates immediately when a TC property is modified in the .tcjs file. It's no longer necessary to save the .tcjs file for changes to be reflected. Choices and junctions can now be created with Content Assist in the Art text editor inside a state machine and inside a composite state. It's now possible to build a library, rather than an executable, from a TC. If the built TC has the topCapsule property set an executable will be built. Otherwise a library will be built.","title":"0.0.6 (2023-03-09 18:28)"},{"location":"releases/CHANGELOG/#005-2023-01-26-0659","text":"Common diagram commands can now be invoked using the keyboard by pressing Ctrl+Space and selecting the command in the popup menu that appears. The following commands are available: Zoom In, Zoom Out, Center, Expand All, Collapse All The presence of internal transitions on a state is now shown by means of an icon on the state symbol in a state diagram. As before the internal transitions will be shown in the Properties view if such a state symbol is selected. When navigating to an element in an Art file the text editor will now automatically scroll both vertically and horizontally (if necessary) to make sure the element becomes visible. TC properties are now validated when edited (both textually and in the UI), and detected problems are reported. For example, it's validated that the specified top capsule exists and that the C++ language standard is set to a valid value. Custom colors can now be specified for all elements in state diagrams (transitions, states and pseudo states). You can directly change the color from the diagram Properties view (i.e. it's no longer necessary to first navigate to the Art file and change the color there). Code formatting and content assist was improved to make rt::properties sections foldable in the Art editor. A new command \"Fold All Properties\" was added. It collapses all rt::properties sections in an Art file (similar to how \"Fold All C++ Code\" works for C++ code sections). It can be useful for Art files that contain lots of properties. The entry and exit actions of a composite state can now be folded in the Art file, like other C++ code snippets. The command \"Fold All C++ Code\" will therefore be able to fold also these code snippets. Code generation now supports entry and exit actions for states. State diagrams now show diagnostics (errors, warnings and informations) using icons on symbols and lines. A new preference ( rtistic.diagram.showDiagnostics ) controls if they should be shown or not. More information is now printed in the Art Build output channel during a build. For example, various useful messages emitted by the C++ code generator may now be printed there. Messages emitted by build tools, e.g. the C++ compiler, are still printed in the Terminal view. In case the build fails a hyperlink to open the Terminal will be present in the Art Build output channel. A target configuration for the latest version of the GCC compiler (ver. 12) on Linux is now provided.","title":"0.0.5 (2023-01-26 06:59)"},{"location":"releases/CHANGELOG/#004-2022-12-21-1311","text":"A target configuration for the latest version of the MinGw compiler (ver. 12.2) is now provided. Better support for Linux platform. Improved makefile generation for incremental builds. More information for internal transitions are now shown in the Properties view. The triggers of the internal transitions are shown in a similar way as in the Outline view. Also, the blue and yellow icons representing the effect and guard code snippets for the internal transitions are shown and can be double-clicked in order to navigate to the code snippets in the Art file. If a port has multiplicity > 1 it is now shown in structure diagrams. The form-based TC editor is now automatically refreshed when the underlying .tcjs file is modified and saved. It's now possible to navigate to the top capsule from a TC file by Ctrl+click on the capsule name. Content assist (Ctrl+space) is now supported for TC property values. Valid values appear in a popup when typing the = character. If there is not a fixed list of valid values, the expected value type (e.g. string) will be shown. Cross-references now bind across workspace folders. This makes it possible to split an application into several workspace folders. For example, Art files built into a library can now be placed in its own folder, and be used from Art files outside that folder. A composite state can now only be expanded if it contains at least one nested state. Previously the Expand button was shown also when the state only contained entry or exit points, which was misleading since expanding such a state didn't reveal anything new that could not already be seen. Attempting to open a diagram using the Art editor context menu now works even when the cursor is not placed within an Art element that can be shown in the diagram. In this case a \"quick pick\" will appear where you can choose one of the elements that are present in the Art file. Hence, this behavior is now the same as when you open diagrams from the Explorer context menu. Protocols now support the rt::header_preface and rt::header_ending code snippets. In particular rt::header_preface is useful for including header files with user-defined types used in the protocol. A new output channel called Art Server is now available and can be seen in the Output view. It's used by the Art language server for printing diagnostic messages (usually internal errors), and can be useful for troubleshooting problems. A new output channel called Art Build is now available and can be seen in the Output view. It's used when building a TC. For example, messages are printed when a build starts and finishes. The editor title for diagrams now contain the name of the Art element. This makes it easier to work with multiple open diagrams at the same time. Content assist now supports creating non-triggered transitions in a state machine. Code generation now supports transition guards, events with parameters of predefined types, connectors between local port and inner structure. It's now possible to set custom colors to be used in diagrams by means of a new color property. Currently this is supported for initial and triggered transitions.","title":"0.0.4 (2022-12-21 13:11)"},{"location":"releases/CHANGELOG/#003-2022-11-23-1253","text":"The graphical appearance of symbols in class diagrams has improved. Now a line separates the name from properties such as ports and events. Also, icons were added for the properties to make it easier to understand the diagram. The Expand All/Collapse All commands in the Properties view now work also for structure diagrams. Cycles in the composition hierarchy are detected and reported with an error message if found. It's now possible to build a TC using a context menu command Build . And if it produces an executable it's possible to launch it with another context menu command Run . Of course, it's still possible to manually build and run from the terminal. The RTist in Code documentation was extended with several new topics and the landing page was improved. New color themes for better syntax highlighting of Art files (and embedded C++ code) are now available. See this topic for more information. It's now possible to edit TC properties using a form-based editor, as an alternative to directly editing the .tcjs file. The form-based editor is invoked from a context menu on the TC called Edit Properties (UI) . New TC properties are now supported for specifying which make command to use for building generated code, as well as the make arguments. The new properties are makeCommand and makeArguments . The existing TC properties targetProject and targetServicesLibrary were renamed to targetFolder and targetRTSLocation respectively. Fixed several Linux specific problems in the language server. The GLSP library was uplifted to version 1.0. Read about the improvements it brings to diagrams here . A problem with automatically expanding symbols when doing a Rename from a diagram was fixed. When renaming an element, for which one or several diagrams have been opened, the diagrams stay open (previously they were automatically closed as a side-effect of the rename). Navigation from a C++ code snippet to generated C++ code using the hyperlink in the code snippet tooltip now works even if the cursor is not placed inside the code snippet. Target configurations for the latest version of the Visual Studio compiler (Visual Studio 2022, ver. 17) are now provided, both for 32 and 64 bit builds.","title":"0.0.3 (2022-11-23 12:53)"},{"location":"releases/CHANGELOG/#002-2022-10-20","text":"First public release. Initial support for the Art language, graphical diagrams, transformation configurations and C++ code generation.","title":"0.0.2 (2022-10-20)"},{"location":"target-rts/","text":"The Target RunTime System (or TargetRTS for short) is a C++ library that is used by the code that is generated by Code RealTime. When building the realtime application from the generated code, it links with a TargetRTS library that has been prebuilt for the platform (hardware, operating system etc) on which the realtime application will run. The TargetRTS provides C++ implementations for the concepts of the Art language . The APIs of these implementations are used by the generated code, but also by the embedded C++ code that you write inside the Art files. This documentation serves the following purposes: Provide a general understanding of how the TargetRTS is structured and how it implements important concepts from the Art language. Document the C++ APIs that you can use in C++ code snippets within an Art file. Describe how to build the TargetRTS for a new target platform, including ways to customize it as required.","title":"Target RunTime System"},{"location":"target-rts/threads/","text":"An Art application consists of capsule instances that each manage a state machine and communicates with other capsule instances by sending and receiving events. Conceptually we can think about each capsule instance as run by its own thread. However, in practise it's often necessary to let each thread run more than one capsule instance. The number of capsule instances in an application can be higher than the maximum number of threads the operating system allows per process. And even if that is not the case, having too many threads can consume too much memory and lead to unwanted overhead. When creating a new Art application it's recommended to start with a minimal number of threads, perhaps only the main thread initially. During the design work you will then add new threads when you identify capsules that need to perform long-running tasks. Such a capsule should not run in the main thread since during the long-running task all other capsules run by that thread will be unresponsive (i.e. cannot respond to incoming events). Another input to which threads to use is how capsule instances communicate with each other. Those capsule instances that communicate frequently with each other benefit from being run by the same thread since sending an event within the same thread is faster than sending it across threads. Example You can find a sample application that uses threads here . Physical and Logical Threads Code RealTime makes a difference between physical and logical threads. Physical threads are the real threads that exist in the application at run-time. A logical thread is a conceptual thread which application code uses when it needs to refer to a thread. Hence, it is an indirection which prevents hard-coding the application against certain physical threads. Logical and physical threads are defined in the transformation configuration (TC) using the threads property. Each logical thread is mapped to a physical thread. Having all information about threads in the TC has several benefits: You can change the thread configuration of an application without changing any C++ code. You can have multiple TCs with different thread configurations for the same application. Some operating systems have a lower limit for the number of threads per process than others. It becomes easy to quickly see which threads will exist at run-time as opposed to if such information is embedded into the C++ code. It becomes easy to experiment with different thread configurations for an application to explore which one gives the best performance. To ensure that each logical thread is mapped to a physical thread, the logical threads are defined implicitly when they are mapped to a physical thread. Here is an example where there are two physical threads MainThread and PT1 , and three logical threads L1 , L2 and L3 . The logical threads L1 and L2 are both mapped to the MainThread while L3 is mapped to PT1 . tc.threads = [ { name: 'MainThread', implClass: 'RTPeerController', stackSize: '20000', priority: 'DEFAULT_MAIN_PRIORITY', logical: [ 'L1', 'L2' ] }, { name: 'PT1', implClass: 'RTPeerController', stackSize: '20000', priority: 'DEFAULT_MAIN_PRIORITY', logical: [ 'L3' ] } ]; Take care to map a logical thread to exactly one physical thread. Library Threads Physical threads can only be defined in executable TCs. A library TC can, however, define logical threads. An executable TC that has such a library TC as its prerequisite must map those logical threads to physical threads. Here is an example of a library TC that defines a logical thread. Note that in this case the threads property contains a list of strings rather than a list of objects as is the case for an executable TC. tc.threads = [ 'LibraryThread' ]; If you anyway define physical threads for a library TC they will be ignored by the C++ code generator, and only the logical threads will be considered. Running a Capsule Instance in a Custom Thread Capsule instances are connected in a tree structure where the top capsule is the root. A capsule instance always lives inside a part of another (container) capsule. The top capsule instance is always run by the main thread, but for all other capsule instances you can choose which thread that should run it. When a new capsule instance is created it will by default be run by the same thread that runs the container capsule instance. This means that by default all capsule instances in the application will be run by the main thread. The picture below outlines the capsule instances of an Art application. C1 is the top capsule. For simplicity we have assumed that all capsule parts are fixed with multiplicity 1 so they only can contain one capsule instance. The capsule instances contained in cp1 and fp1 are run by the logical thread Logical1 while the capsule instances contained in dp1 , cp2 and ep2 are run by the logical thread Logical2 . Other capsule instances are run by the main thread. Note that to accomplish that we need to explicitly reference the MainThread when incarnating ep1 since by default it would be run by the thread that runs its container capsule, i.e. Logical2 . In fact we need to explicitly mention a logical thread for all capsule instances in this example except ep2 since it runs in the same logical thread as its container capsule instance cp2 . If you don't want a capsule instance to be run by the same thread that runs its container capsule you can specify another thread when creating the capsule instance. When incarnating a capsule instance into an optional part this can be done in a call to incarnate() on a Frame port. Here is an example: frame.incarnate(myPart, 0 /* data */, 0 /* type */, LogicalThread, -1); Here LogicalThread refers to a logical thread that must exist in the TC. The physical thread to which it is mapped will run the created capsule instance. If the part is fixed you need to use a capsule factory for specifying the thread that should run a capsule instance that is incarnated into the part. For example: fixed part server : Server [[rt::create]] ` return new Server_Actor(LogicalThread, rtg_ref); `; TargetRTS Implementation The implClass property of a physical thread that is defined in a TC refers to the class in the TargetRTS that implements the thread. This class must inherit from RTController . A default implementation is provided by the RTPeerController . It implements a simple event loop that in each iteration delivers the most prioritized event to the capsule instance that should handle it. You can implement your own controller class by creating another subclass of RTController . As an example, look at RTCustomController . If the application uses timers it needs a timer thread for implementing the timeouts. The TargetRTS provides a default implementation RTTimerController which implements basic support for processing timeout events and timer cancellation. Default Threads and Thread Properties If no threads are specified in the TC the application will use two threads; one main thread that runs all capsule instances and one timer thread that implements support for timers as explained in the documentation of the threads property. If your application is single-threaded and doesn't use timers, it's unnecessary to have a timer thread and you can then remove it by only defining the MainThread in the threads property: tc.threads = [ { name: 'MainThread', implClass: 'RTPeerController', stackSize: '20000', priority: 'DEFAULT_MAIN_PRIORITY' } ]; A thread object defines a physical thread by means of the following properties: name The name of the thread. It's recommended to choose a name that describes what the thread is doing. Many C++ debuggers can show the thread name while debugging, and you can also access it programmatically by calling the RTController ::name() function. Note that names of physical threads in the application must be unique. implClass This is the name of the TargetRTS class that implements the thread. See TargetRTS Implementation . If omitted it will default to RTPeerController . stackSize The thread stack size in bytes. This value is interpreted by the target environment, and some operating systems may have special values (such as 0) that can be used to avoid hard-coding a certain stack size. If omitted it will default to 20000 . priority The thread priority. By default it's DEFAULT_MAIN_PRIORITY (or DEFAULT_TIMER_PRIORITY for a timer thread). These are macros with values that are interpreted by the target environment. logical A list of names of logical threads that are mapped to the physical thread. Logical threads must have unique names and each logical thread must only be mapped to one physical thread. Except for the main thread and timer threads this property should not be empty, since it's through the logical threads that the application code can use the physical thread. Generated Code for Threads Thread information specified in the TC is generated into the unit files (by default called UnitName.h and UnitName.cpp ). You will find there functions _rtg_createThreads() and rtg_deleteThreads() which contain the code for creating and deleting the physical threads that you have added in addition to the default MainThread and TimerThread. There is also a function _rtg_mapLogicalThreads() where the logical threads are mapped to physical threads. Some target environments only support one thread. In this case the macro USE_THREADS will be unset when compiling generated C++ code and the TargetRTS, and it will remove all code related to threads.","title":"Threads"},{"location":"target-rts/threads/#physical-and-logical-threads","text":"Code RealTime makes a difference between physical and logical threads. Physical threads are the real threads that exist in the application at run-time. A logical thread is a conceptual thread which application code uses when it needs to refer to a thread. Hence, it is an indirection which prevents hard-coding the application against certain physical threads. Logical and physical threads are defined in the transformation configuration (TC) using the threads property. Each logical thread is mapped to a physical thread. Having all information about threads in the TC has several benefits: You can change the thread configuration of an application without changing any C++ code. You can have multiple TCs with different thread configurations for the same application. Some operating systems have a lower limit for the number of threads per process than others. It becomes easy to quickly see which threads will exist at run-time as opposed to if such information is embedded into the C++ code. It becomes easy to experiment with different thread configurations for an application to explore which one gives the best performance. To ensure that each logical thread is mapped to a physical thread, the logical threads are defined implicitly when they are mapped to a physical thread. Here is an example where there are two physical threads MainThread and PT1 , and three logical threads L1 , L2 and L3 . The logical threads L1 and L2 are both mapped to the MainThread while L3 is mapped to PT1 . tc.threads = [ { name: 'MainThread', implClass: 'RTPeerController', stackSize: '20000', priority: 'DEFAULT_MAIN_PRIORITY', logical: [ 'L1', 'L2' ] }, { name: 'PT1', implClass: 'RTPeerController', stackSize: '20000', priority: 'DEFAULT_MAIN_PRIORITY', logical: [ 'L3' ] } ]; Take care to map a logical thread to exactly one physical thread.","title":"Physical and Logical Threads"},{"location":"target-rts/threads/#library-threads","text":"Physical threads can only be defined in executable TCs. A library TC can, however, define logical threads. An executable TC that has such a library TC as its prerequisite must map those logical threads to physical threads. Here is an example of a library TC that defines a logical thread. Note that in this case the threads property contains a list of strings rather than a list of objects as is the case for an executable TC. tc.threads = [ 'LibraryThread' ]; If you anyway define physical threads for a library TC they will be ignored by the C++ code generator, and only the logical threads will be considered.","title":"Library Threads"},{"location":"target-rts/threads/#running-a-capsule-instance-in-a-custom-thread","text":"Capsule instances are connected in a tree structure where the top capsule is the root. A capsule instance always lives inside a part of another (container) capsule. The top capsule instance is always run by the main thread, but for all other capsule instances you can choose which thread that should run it. When a new capsule instance is created it will by default be run by the same thread that runs the container capsule instance. This means that by default all capsule instances in the application will be run by the main thread. The picture below outlines the capsule instances of an Art application. C1 is the top capsule. For simplicity we have assumed that all capsule parts are fixed with multiplicity 1 so they only can contain one capsule instance. The capsule instances contained in cp1 and fp1 are run by the logical thread Logical1 while the capsule instances contained in dp1 , cp2 and ep2 are run by the logical thread Logical2 . Other capsule instances are run by the main thread. Note that to accomplish that we need to explicitly reference the MainThread when incarnating ep1 since by default it would be run by the thread that runs its container capsule, i.e. Logical2 . In fact we need to explicitly mention a logical thread for all capsule instances in this example except ep2 since it runs in the same logical thread as its container capsule instance cp2 . If you don't want a capsule instance to be run by the same thread that runs its container capsule you can specify another thread when creating the capsule instance. When incarnating a capsule instance into an optional part this can be done in a call to incarnate() on a Frame port. Here is an example: frame.incarnate(myPart, 0 /* data */, 0 /* type */, LogicalThread, -1); Here LogicalThread refers to a logical thread that must exist in the TC. The physical thread to which it is mapped will run the created capsule instance. If the part is fixed you need to use a capsule factory for specifying the thread that should run a capsule instance that is incarnated into the part. For example: fixed part server : Server [[rt::create]] ` return new Server_Actor(LogicalThread, rtg_ref); `;","title":"Running a Capsule Instance in a Custom Thread"},{"location":"target-rts/threads/#targetrts-implementation","text":"The implClass property of a physical thread that is defined in a TC refers to the class in the TargetRTS that implements the thread. This class must inherit from RTController . A default implementation is provided by the RTPeerController . It implements a simple event loop that in each iteration delivers the most prioritized event to the capsule instance that should handle it. You can implement your own controller class by creating another subclass of RTController . As an example, look at RTCustomController . If the application uses timers it needs a timer thread for implementing the timeouts. The TargetRTS provides a default implementation RTTimerController which implements basic support for processing timeout events and timer cancellation.","title":"TargetRTS Implementation"},{"location":"target-rts/threads/#default-threads-and-thread-properties","text":"If no threads are specified in the TC the application will use two threads; one main thread that runs all capsule instances and one timer thread that implements support for timers as explained in the documentation of the threads property. If your application is single-threaded and doesn't use timers, it's unnecessary to have a timer thread and you can then remove it by only defining the MainThread in the threads property: tc.threads = [ { name: 'MainThread', implClass: 'RTPeerController', stackSize: '20000', priority: 'DEFAULT_MAIN_PRIORITY' } ]; A thread object defines a physical thread by means of the following properties: name The name of the thread. It's recommended to choose a name that describes what the thread is doing. Many C++ debuggers can show the thread name while debugging, and you can also access it programmatically by calling the RTController ::name() function. Note that names of physical threads in the application must be unique. implClass This is the name of the TargetRTS class that implements the thread. See TargetRTS Implementation . If omitted it will default to RTPeerController . stackSize The thread stack size in bytes. This value is interpreted by the target environment, and some operating systems may have special values (such as 0) that can be used to avoid hard-coding a certain stack size. If omitted it will default to 20000 . priority The thread priority. By default it's DEFAULT_MAIN_PRIORITY (or DEFAULT_TIMER_PRIORITY for a timer thread). These are macros with values that are interpreted by the target environment. logical A list of names of logical threads that are mapped to the physical thread. Logical threads must have unique names and each logical thread must only be mapped to one physical thread. Except for the main thread and timer threads this property should not be empty, since it's through the logical threads that the application code can use the physical thread.","title":"Default Threads and Thread Properties"},{"location":"target-rts/threads/#generated-code-for-threads","text":"Thread information specified in the TC is generated into the unit files (by default called UnitName.h and UnitName.cpp ). You will find there functions _rtg_createThreads() and rtg_deleteThreads() which contain the code for creating and deleting the physical threads that you have added in addition to the default MainThread and TimerThread. There is also a function _rtg_mapLogicalThreads() where the logical threads are mapped to physical threads. Some target environments only support one thread. In this case the macro USE_THREADS will be unset when compiling generated C++ code and the TargetRTS, and it will remove all code related to threads.","title":"Generated Code for Threads"},{"location":"working-with-art/","text":"An Art file is primarily edited using its textual syntax in the text editor . However, many parts of the Art language also has a graphical syntax which can be shown (and to some extent also edited) from graphical diagrams . Visual Studio Code and Eclipse Theia also provide a few views that provide value for Art, such as the Outline view and the References view . These views do not support any editing, but provide useful overview and navigation possibilities.","title":"Working with Art"},{"location":"working-with-art/art-editor/","text":"You can use any text editor for editing Art files, but it's highly recommended to edit them in Code RealTime. Thereby you will have access to features such as syntax coloring , content assist and semantic validation . Syntax Coloring Code RealTime provides color themes that have been specifically designed for being used for editing Art files. Activate one of these color themes from File - Preferences - Color Theme . Art Dark This is a dark theme that colorizes Art keywords, properties and comments. All embedded C++ code will be shown in gray color. This theme can be useful if you mostly edit C++ code snippets in generated files and propagate those changes back to the Art files automatically (see Making Changes in Generated C++ ). Showing C++ code in gray color makes it easier to see what parts you have to edit in the Art file, and what parts (i.e. the C++ code) that you can edit in generated files. Art Dark++ This is a dark theme that colorizes Art keywords, properties and comments. In addition it colorizes embedded C++ code using the same colors as are used for a C++ file. To help in separating Art from C++, all Art code uses a bold font, while C++ code uses a regular font. This theme can be useful if you prefer to edit both Art and C++ code in the Art file. Art Light This is a light theme that uses the same colors as Art Dark. Art Light++ This is a light theme that uses the same colors as Art Dark++. Content Assist This feature, which also is known as IntelliSense or Code Completion, helps you when editing an Art file by proposing commonly used Art constructs that are valid at the current cursor position. Invoke Content Assist by pressing Ctrl + Space . Depending on where the cursor is placed you will get different proposals to choose from. There are four kinds of proposals as shown in the picture below: Code Templates are complete Art elements, for example a capsule, protocol or state. The inserted code template often has variables that you should replace as you find appropriate. For example, the code template for a capsule contains one variable for the capsule name and another for the name of the state which its state machine contains. Press Tab to move forward from one variable to the next and if needed Shift + Tab to move backwards to a previous variable. Note that the same variable may occur in multiple places, like the State variable for the capsule code template which occurs both in the state definition and as a state reference in the initial transition. All occurrances of a variable are updated simultaneously when you replace the variable with a string. Note that code templates are also available in some C++ code snippets (e.g. rt::decl and rt::impl ) and can help you insert pieces of C++ code that are commonly used in Art applications. References are references to existing Art elements, for example a state, event or capsule. All Art elements of the correct kind which are visible from the cursor position will be available. References may have a qualifier if necessary, for example when referencing an entry point. Name represents an identifier used as the name of an Art element. It appears as a proposal at positions where the Art language allows a named element. Choosing this proposal just inserts the string \"name\" which probably is not so useful. However, the presence of a name item in the proposals list tells you that you can use an arbitrary identifier as the name of an Art element at that position. For example, in the proposals list shown in the picture above name appears since a triggered transition may have an optional name before its declaration. The code template for the triggered transition will not insert a name, since many transitions don't have names, but you can manually add it afterwards: MyTransition: State -> X on timer.timeout Keywords are keywords from the Art language that are valid to use at the cursor position. This also includes lexical tokens such as : or . where applicable. For example, after you have typed the name for the triggered transition shown above you can use Content Assist to learn that it may be followed by either a -> or : token: Renaming Elements To rename an Art element place the cursor on the element's name and press F2 (or invoke the command Rename Symbol from the context menu). This performs a \"rename refactoring\" that updates all references to the renamed element too. Note Avoid renaming an element by simply editing its name. For Code RealTime to understand that you want to rename an element, you need to use the approach described above.","title":"Text Editor"},{"location":"working-with-art/art-editor/#syntax-coloring","text":"Code RealTime provides color themes that have been specifically designed for being used for editing Art files. Activate one of these color themes from File - Preferences - Color Theme . Art Dark This is a dark theme that colorizes Art keywords, properties and comments. All embedded C++ code will be shown in gray color. This theme can be useful if you mostly edit C++ code snippets in generated files and propagate those changes back to the Art files automatically (see Making Changes in Generated C++ ). Showing C++ code in gray color makes it easier to see what parts you have to edit in the Art file, and what parts (i.e. the C++ code) that you can edit in generated files. Art Dark++ This is a dark theme that colorizes Art keywords, properties and comments. In addition it colorizes embedded C++ code using the same colors as are used for a C++ file. To help in separating Art from C++, all Art code uses a bold font, while C++ code uses a regular font. This theme can be useful if you prefer to edit both Art and C++ code in the Art file. Art Light This is a light theme that uses the same colors as Art Dark. Art Light++ This is a light theme that uses the same colors as Art Dark++.","title":"Syntax Coloring"},{"location":"working-with-art/art-editor/#content-assist","text":"This feature, which also is known as IntelliSense or Code Completion, helps you when editing an Art file by proposing commonly used Art constructs that are valid at the current cursor position. Invoke Content Assist by pressing Ctrl + Space . Depending on where the cursor is placed you will get different proposals to choose from. There are four kinds of proposals as shown in the picture below: Code Templates are complete Art elements, for example a capsule, protocol or state. The inserted code template often has variables that you should replace as you find appropriate. For example, the code template for a capsule contains one variable for the capsule name and another for the name of the state which its state machine contains. Press Tab to move forward from one variable to the next and if needed Shift + Tab to move backwards to a previous variable. Note that the same variable may occur in multiple places, like the State variable for the capsule code template which occurs both in the state definition and as a state reference in the initial transition. All occurrances of a variable are updated simultaneously when you replace the variable with a string. Note that code templates are also available in some C++ code snippets (e.g. rt::decl and rt::impl ) and can help you insert pieces of C++ code that are commonly used in Art applications. References are references to existing Art elements, for example a state, event or capsule. All Art elements of the correct kind which are visible from the cursor position will be available. References may have a qualifier if necessary, for example when referencing an entry point. Name represents an identifier used as the name of an Art element. It appears as a proposal at positions where the Art language allows a named element. Choosing this proposal just inserts the string \"name\" which probably is not so useful. However, the presence of a name item in the proposals list tells you that you can use an arbitrary identifier as the name of an Art element at that position. For example, in the proposals list shown in the picture above name appears since a triggered transition may have an optional name before its declaration. The code template for the triggered transition will not insert a name, since many transitions don't have names, but you can manually add it afterwards: MyTransition: State -> X on timer.timeout Keywords are keywords from the Art language that are valid to use at the cursor position. This also includes lexical tokens such as : or . where applicable. For example, after you have typed the name for the triggered transition shown above you can use Content Assist to learn that it may be followed by either a -> or : token:","title":"Content Assist"},{"location":"working-with-art/art-editor/#renaming-elements","text":"To rename an Art element place the cursor on the element's name and press F2 (or invoke the command Rename Symbol from the context menu). This performs a \"rename refactoring\" that updates all references to the renamed element too. Note Avoid renaming an element by simply editing its name. For Code RealTime to understand that you want to rename an element, you need to use the approach described above.","title":"Renaming Elements"},{"location":"working-with-art/diagrams/","text":"Art is a textual language but there is also a graphical notation for many parts of the language. You can therefore visualize (and in many cases also edit) some of the Art elements using graphical diagrams. The following diagrams can be used: State Diagram Shows the state machine of a capsule or class. A single diagram can show all states, pseudo states and transitions also for hierarchical state machines. Structure Diagram Shows the composite structure of a capsule. A single diagram can show all parts, ports and connectors also for hierarchical composite structures. Class Diagram Shows how capsules, classes and protocols are related by means of inheritance and composition relationships. Also shows ports and parts of capsules and events of protocols. The picture below shows an example of what these diagrams may look like: Opening Diagrams To open a diagram from an Art file place the cursor inside an Art element. Bring up the context menu and invoke a command for opening a diagram for the Art element: Open State Diagram , Open Structure Diagram or Open Class Diagram . Note that all these three commands are always available, but if the selected Art element cannot be shown in the selected kind of diagram, you will get an error and no diagram will open. If the cursor is placed on an Art element that has a graphic representation in the form of a symbol or line in the diagram, for example a state in a state diagram, the symbol or line will be highlighted in the opened diagram by selecting it. You can use this feature as a way to navigate from an element in an Art file to the corresponding symbol or line in a diagram. If the diagram is already open, it will be made visible and the selection will be updated. You can also open diagrams from the context menu of an Art file in the Explorer view. In this case the Art file will be searched for an element that can be shown in the selected kind of diagram. If more than one such Art element is found, you will be prompted to pick the one to show in the diagram. For example: The same prompting happens if you open a diagram from an Art file when the cursor position doesn't indicate which Art element to open the diagram for. All valid Art elements in the file will be listed and you can choose which one to open the diagram for. You can open multiple diagrams of the same kind in one go by selecting multiple Art files in the Explorer view, and then invoke a command for opening diagrams from the context menu. However, in this case only diagrams for the first element found in each file will be opened (i.e. in this case you will not be prompted in case a file contains multiple elements for which the selected kind of diagram could be opened). Related Diagrams If you already have a diagram open, you can open another diagram that is related to that diagram. And if a symbol or line is selected on the diagram, diagrams related to the selected symbol or line can be opened. Press Ctrl + Space to open the diagram's pop-up menu. If the diagram, or the selected symbol or line, has any related diagrams you may see the following commands: Open State Diagram From a structure diagram that shows a capsule's composite structure, the state diagram of the capsule will be opened. If a part symbol is selected, the state diagram of the capsule that types the part will be opened. From a class diagram that shows relationships for a class or capsule, the state diagram of the class or capsule will be opened. If another class or capsule is selected on the diagram, the state diagram of that selected class or capsule will be opened. Open Structure Diagram From a structure diagram where a part symbol is selected, the structure diagram of the capsule that types the part will be opened. From a state diagram of a capsule, the structure diagram of the capsule will be opened. From a class diagram that shows relationships for a capsule, the structure diagram of the capsule will be opened. If another capsule is selected on the diagram, the structure diagram of that selected capsule will be opened. Open Class Diagram From a structure diagram that shows a capsule's composite structure, the class diagram of the capsule will be opened. If a part symbol is selected, the class diagram of the capsule that types the part will be opened. From a state diagram of a class or capsule, the class diagram of the class or capsule will be opened. From a class diagram where a class, capsule or protocol is selected, the class diagram of that selected class, capsule or protocol will be opened. For a capsule that inherits from another capsule you can open the state diagram of the inherited base capsule by means of the command Open Inherited State Diagram . If this command is performed on an element that is inherited, redefined or excluded in the state diagram, then the corresponding element in the base capsule will be highlighted. This command is therefore useful for navigating in an inherited state machine. Navigating from Diagram to Art File If you double-click a symbol or a line in a diagram, the Art element that corresponds to that symbol or line will be highlighted in the Art file. Note that you need to double-click on the symbol or line itself, and not on a text label shown in the symbol or on the line. However, as an alternative you can instead hold down the Ctrl key and then click on the text label. It will then become a hyperlink that navigates to the Art element that corresponds to that text label. You need to use this approach in case a symbol has multiple text labels each of which represent different Art elements. For example: In state diagrams you can also double-click on icons that are shown for transitions that contain effect and/or guard code. The presence of effect code is indicated by a blue icon, and guard code with a yellow icon. Double-clicking these icons will highlight the code snippets in the Art file. Working with Diagrams Zooming and Panning When a diagram is opened it is initially centered and with medium zoom level which makes all text labels big enough for reading. However, if the diagram is big then all contents may not be visible unless you zoom out. You can zoom the diagram using either the mouse scroll wheel or by means of the two-finger zoom gesture on a touch pad. You can also zoom using the buttons in the Properties view toolbar. There you will also find a Center button which will restore the diagram to its original zoom level. Alternatively you can use the command Fit to Screen which will set the zoom level so that the entire diagram fits the size of the diagram editor. Note that this command must be invoked from the general Command Palette or by means of the keyboard shortcut Ctrl + Shift + F . It's also possible to work with a big diagram without zooming, but instead panning the viewport so that a different part of the diagram becomes visible. To pan the viewport click anywhere on the diagram and drag while holding down the mouse button. Note that there are no limits to panning which means you can move the viewport as far away from the center of the diagram as you like. Use the Center or Fit to Screen command for panning back the viewport to its original position. Note that if a symbol or line is selected, the Center command will move the viewport so that the selected symbol or line appears in the middle. Collapsing and Expanding Symbols State and structure diagrams can be hierarchical. A state diagram is hierarchical if it contains a composite state with a nested state machine. A structure diagram is hierarchical if it contains a part typed by another capsule with nested parts or ports. By default symbols that contain nested symbols are collapsed to minimize the size of the diagram: To expand a collapsed symbol click the yellow button. The symbol will then be resized to show the nested symbols. Click the button again to collapse the symbol and hide the nested symbols. You can use the Expand All and Collapse All buttons in the Properties view toolbar to expand or collapse all symbols so that the full hierarchical diagram becomes visible or hidden. Information about which symbols that are currently expanded will be remembered if you save the diagram. This information is stored in the file .vscode/art_diagram_settings.json . Invoking Diagram Commands from Keyboard Many diagram commands mentioned above can be invoked using the keyboard. Press Ctrl + Space in a diagram to open a pop-up menu from where you can invoke a diagram command. In this pop-up menu you also find convenient commands for navigating to related diagrams . For example, from the state diagram of a capsule you can navigate to the structure and class diagrams of that same capsule. Diagram Appearance Certain properties on Art elements control how they will appear in a diagram. Currently it's possible to configure which color to use for most elements in diagrams. See the color property for more information. Diagram Filters To avoid cluttered diagrams with too many text labels, certain information is by default hidden. If you click in the background of the diagram, the Properties view will show various filters that you can turn on or off for showing or hiding such additional information. Here is an example of the filters available for a state diagram: Information about applied filters will be remembered if you save the diagram. This information is stored in the file .vscode/art_diagram_settings.json . Diagram filter properties that have been modified are shown in boldface, and a \"Restore default\" button appears for them. You can click this button to restore the filter property to its default value. You can also set diagram filters globally using diagram settings . Such filters will apply to all diagrams unless a more specific filter has been set on an individual diagram. You can find these settings by filtering on code-rt.diagram in the Settings editor: Note that some diagram filters can only be set globally, and not for individual diagrams. Elements in the Properties View The Properties view can show additional Art elements when you select a symbol or a line. For example, it shows internal transitions of a state. Showing such elements in the diagram itself would risk making it cluttered, especially when there is a large number of elements. You can double-click the Art elements in the Properties view to highlight them in the Art file. For internal transitions the same blue and yellow dots are shown as for regular transitions in diagrams. Double-click the blue dot to navigate to the transition effect code and the yellow dot for navigating to the transition guard code. Renaming Elements You can rename an Art element shown in a diagram by double-clicking on the text label that shows its name. Alternatively select the symbol or line to which the text label belongs and press F2 . Note that this is a \"rename refactoring\" and all references to the renamed element will be updated too. Creating and Editing Elements Note Creating and editing elements is supported in state and structure diagrams but not in class diagrams. To create a new element in a diagram use one of the New ... commands in the pop-up menu that appears when you press Ctrl + Space . These commands are the same as appear when you use Content Assist in the Art text editor. Which commands that are available depends on what is currently selected in the diagram. If an element is selected in the diagram, a new element will be created inside that element. Otherwise the new element will be created as a top-level element (possible in state diagrams but not in structure diagrams). To edit an existing element, select it in the diagram and use the Properties view for editing it. There are certain properties that are common for many elements, such as the color property, but most properties are specific for the element that is selected. Elements are created and edited by updating the Art file, which in turn will update the diagram. Just like when you use Content Assist in the Art text editor a created element will initially get default values for its properties, for example the name. The default value becomes selected so you can directly type to replace it with something else. You can of course undo a change by pressing Ctrl + z ( Undo ) in the Art text editor. State Diagram Editing In a state diagram where nothing is selected, the New ... commands will create new top-level elements directly in the state machine. If a state is selected you can create the following elements inside it (turning the state into a composite state, if it was not already composite). To create a transition in a state diagram you first need to select the source state (or pseudo-state) and then the target state (or pseudo-state). Then press Ctrl + Space and perform either New Triggered Transition or New Non-Triggered Transition (depending on if the transition needs any triggers or not). You can redirect a transition, i.e. to change either its source (state or pseudo-state) or its target (state or pseudo-state). You can do it from a state diagram by selecting both the transition and the new source or target. Then press Ctrl + Space and perform either Set Transition Source or Set Transition Target . This will redirect the transition by changing its source or target. If you want to change both the source and target just repeat the procedure once more. For example, in the diagram below we have selected the transition between states Ready and Heating and also the CoolOffState. We then select Set Transition Source in the menu. This will redirect the transition to instead go from state CoolOffState to state Heating. Structure Diagram Editing In a structure diagram it's not possible to create anything unless something is selected in the diagram. This is because a structure diagram always has a single capsule as its top-level element. If the capsule is selected you can create parts and ports in it. If a part is selected you can create a port in the capsule that types the part. In the example below a port will be created in capsule BB. Both parts and ports have several properties that can be edited using the Properties view. Deleting Elements Note Deleting elements is supported in state and structure diagrams but not in class diagrams. You can delete an Art element shown in a diagram by selecting the symbol or line that represents the element and then press the Delete key. Alternatively use the command Delete in the Ctrl + Space pop-up menu. Multiple symbols or lines can be selected in order to delete many Art elements in one go. Note that elements are deleted by removing them from the Art file, which in turn will update the diagram. All content within the deleted element will be lost, including any comments. However, you can of course undo the deletion by pressing Ctrl + z ( Undo ) in the Art text editor.","title":"Diagrams"},{"location":"working-with-art/diagrams/#opening-diagrams","text":"To open a diagram from an Art file place the cursor inside an Art element. Bring up the context menu and invoke a command for opening a diagram for the Art element: Open State Diagram , Open Structure Diagram or Open Class Diagram . Note that all these three commands are always available, but if the selected Art element cannot be shown in the selected kind of diagram, you will get an error and no diagram will open. If the cursor is placed on an Art element that has a graphic representation in the form of a symbol or line in the diagram, for example a state in a state diagram, the symbol or line will be highlighted in the opened diagram by selecting it. You can use this feature as a way to navigate from an element in an Art file to the corresponding symbol or line in a diagram. If the diagram is already open, it will be made visible and the selection will be updated. You can also open diagrams from the context menu of an Art file in the Explorer view. In this case the Art file will be searched for an element that can be shown in the selected kind of diagram. If more than one such Art element is found, you will be prompted to pick the one to show in the diagram. For example: The same prompting happens if you open a diagram from an Art file when the cursor position doesn't indicate which Art element to open the diagram for. All valid Art elements in the file will be listed and you can choose which one to open the diagram for. You can open multiple diagrams of the same kind in one go by selecting multiple Art files in the Explorer view, and then invoke a command for opening diagrams from the context menu. However, in this case only diagrams for the first element found in each file will be opened (i.e. in this case you will not be prompted in case a file contains multiple elements for which the selected kind of diagram could be opened).","title":"Opening Diagrams"},{"location":"working-with-art/diagrams/#related-diagrams","text":"If you already have a diagram open, you can open another diagram that is related to that diagram. And if a symbol or line is selected on the diagram, diagrams related to the selected symbol or line can be opened. Press Ctrl + Space to open the diagram's pop-up menu. If the diagram, or the selected symbol or line, has any related diagrams you may see the following commands: Open State Diagram From a structure diagram that shows a capsule's composite structure, the state diagram of the capsule will be opened. If a part symbol is selected, the state diagram of the capsule that types the part will be opened. From a class diagram that shows relationships for a class or capsule, the state diagram of the class or capsule will be opened. If another class or capsule is selected on the diagram, the state diagram of that selected class or capsule will be opened. Open Structure Diagram From a structure diagram where a part symbol is selected, the structure diagram of the capsule that types the part will be opened. From a state diagram of a capsule, the structure diagram of the capsule will be opened. From a class diagram that shows relationships for a capsule, the structure diagram of the capsule will be opened. If another capsule is selected on the diagram, the structure diagram of that selected capsule will be opened. Open Class Diagram From a structure diagram that shows a capsule's composite structure, the class diagram of the capsule will be opened. If a part symbol is selected, the class diagram of the capsule that types the part will be opened. From a state diagram of a class or capsule, the class diagram of the class or capsule will be opened. From a class diagram where a class, capsule or protocol is selected, the class diagram of that selected class, capsule or protocol will be opened. For a capsule that inherits from another capsule you can open the state diagram of the inherited base capsule by means of the command Open Inherited State Diagram . If this command is performed on an element that is inherited, redefined or excluded in the state diagram, then the corresponding element in the base capsule will be highlighted. This command is therefore useful for navigating in an inherited state machine.","title":"Related Diagrams"},{"location":"working-with-art/diagrams/#navigating-from-diagram-to-art-file","text":"If you double-click a symbol or a line in a diagram, the Art element that corresponds to that symbol or line will be highlighted in the Art file. Note that you need to double-click on the symbol or line itself, and not on a text label shown in the symbol or on the line. However, as an alternative you can instead hold down the Ctrl key and then click on the text label. It will then become a hyperlink that navigates to the Art element that corresponds to that text label. You need to use this approach in case a symbol has multiple text labels each of which represent different Art elements. For example: In state diagrams you can also double-click on icons that are shown for transitions that contain effect and/or guard code. The presence of effect code is indicated by a blue icon, and guard code with a yellow icon. Double-clicking these icons will highlight the code snippets in the Art file.","title":"Navigating from Diagram to Art File"},{"location":"working-with-art/diagrams/#working-with-diagrams","text":"","title":"Working with Diagrams"},{"location":"working-with-art/diagrams/#zooming-and-panning","text":"When a diagram is opened it is initially centered and with medium zoom level which makes all text labels big enough for reading. However, if the diagram is big then all contents may not be visible unless you zoom out. You can zoom the diagram using either the mouse scroll wheel or by means of the two-finger zoom gesture on a touch pad. You can also zoom using the buttons in the Properties view toolbar. There you will also find a Center button which will restore the diagram to its original zoom level. Alternatively you can use the command Fit to Screen which will set the zoom level so that the entire diagram fits the size of the diagram editor. Note that this command must be invoked from the general Command Palette or by means of the keyboard shortcut Ctrl + Shift + F . It's also possible to work with a big diagram without zooming, but instead panning the viewport so that a different part of the diagram becomes visible. To pan the viewport click anywhere on the diagram and drag while holding down the mouse button. Note that there are no limits to panning which means you can move the viewport as far away from the center of the diagram as you like. Use the Center or Fit to Screen command for panning back the viewport to its original position. Note that if a symbol or line is selected, the Center command will move the viewport so that the selected symbol or line appears in the middle.","title":"Zooming and Panning"},{"location":"working-with-art/diagrams/#collapsing-and-expanding-symbols","text":"State and structure diagrams can be hierarchical. A state diagram is hierarchical if it contains a composite state with a nested state machine. A structure diagram is hierarchical if it contains a part typed by another capsule with nested parts or ports. By default symbols that contain nested symbols are collapsed to minimize the size of the diagram: To expand a collapsed symbol click the yellow button. The symbol will then be resized to show the nested symbols. Click the button again to collapse the symbol and hide the nested symbols. You can use the Expand All and Collapse All buttons in the Properties view toolbar to expand or collapse all symbols so that the full hierarchical diagram becomes visible or hidden. Information about which symbols that are currently expanded will be remembered if you save the diagram. This information is stored in the file .vscode/art_diagram_settings.json .","title":"Collapsing and Expanding Symbols"},{"location":"working-with-art/diagrams/#invoking-diagram-commands-from-keyboard","text":"Many diagram commands mentioned above can be invoked using the keyboard. Press Ctrl + Space in a diagram to open a pop-up menu from where you can invoke a diagram command. In this pop-up menu you also find convenient commands for navigating to related diagrams . For example, from the state diagram of a capsule you can navigate to the structure and class diagrams of that same capsule.","title":"Invoking Diagram Commands from Keyboard"},{"location":"working-with-art/diagrams/#diagram-appearance","text":"Certain properties on Art elements control how they will appear in a diagram. Currently it's possible to configure which color to use for most elements in diagrams. See the color property for more information.","title":"Diagram Appearance"},{"location":"working-with-art/diagrams/#diagram-filters","text":"To avoid cluttered diagrams with too many text labels, certain information is by default hidden. If you click in the background of the diagram, the Properties view will show various filters that you can turn on or off for showing or hiding such additional information. Here is an example of the filters available for a state diagram: Information about applied filters will be remembered if you save the diagram. This information is stored in the file .vscode/art_diagram_settings.json . Diagram filter properties that have been modified are shown in boldface, and a \"Restore default\" button appears for them. You can click this button to restore the filter property to its default value. You can also set diagram filters globally using diagram settings . Such filters will apply to all diagrams unless a more specific filter has been set on an individual diagram. You can find these settings by filtering on code-rt.diagram in the Settings editor: Note that some diagram filters can only be set globally, and not for individual diagrams.","title":"Diagram Filters"},{"location":"working-with-art/diagrams/#elements-in-the-properties-view","text":"The Properties view can show additional Art elements when you select a symbol or a line. For example, it shows internal transitions of a state. Showing such elements in the diagram itself would risk making it cluttered, especially when there is a large number of elements. You can double-click the Art elements in the Properties view to highlight them in the Art file. For internal transitions the same blue and yellow dots are shown as for regular transitions in diagrams. Double-click the blue dot to navigate to the transition effect code and the yellow dot for navigating to the transition guard code.","title":"Elements in the Properties View"},{"location":"working-with-art/diagrams/#renaming-elements","text":"You can rename an Art element shown in a diagram by double-clicking on the text label that shows its name. Alternatively select the symbol or line to which the text label belongs and press F2 . Note that this is a \"rename refactoring\" and all references to the renamed element will be updated too.","title":"Renaming Elements"},{"location":"working-with-art/diagrams/#creating-and-editing-elements","text":"Note Creating and editing elements is supported in state and structure diagrams but not in class diagrams. To create a new element in a diagram use one of the New ... commands in the pop-up menu that appears when you press Ctrl + Space . These commands are the same as appear when you use Content Assist in the Art text editor. Which commands that are available depends on what is currently selected in the diagram. If an element is selected in the diagram, a new element will be created inside that element. Otherwise the new element will be created as a top-level element (possible in state diagrams but not in structure diagrams). To edit an existing element, select it in the diagram and use the Properties view for editing it. There are certain properties that are common for many elements, such as the color property, but most properties are specific for the element that is selected. Elements are created and edited by updating the Art file, which in turn will update the diagram. Just like when you use Content Assist in the Art text editor a created element will initially get default values for its properties, for example the name. The default value becomes selected so you can directly type to replace it with something else. You can of course undo a change by pressing Ctrl + z ( Undo ) in the Art text editor.","title":"Creating and Editing Elements"},{"location":"working-with-art/diagrams/#state-diagram-editing","text":"In a state diagram where nothing is selected, the New ... commands will create new top-level elements directly in the state machine. If a state is selected you can create the following elements inside it (turning the state into a composite state, if it was not already composite). To create a transition in a state diagram you first need to select the source state (or pseudo-state) and then the target state (or pseudo-state). Then press Ctrl + Space and perform either New Triggered Transition or New Non-Triggered Transition (depending on if the transition needs any triggers or not). You can redirect a transition, i.e. to change either its source (state or pseudo-state) or its target (state or pseudo-state). You can do it from a state diagram by selecting both the transition and the new source or target. Then press Ctrl + Space and perform either Set Transition Source or Set Transition Target . This will redirect the transition by changing its source or target. If you want to change both the source and target just repeat the procedure once more. For example, in the diagram below we have selected the transition between states Ready and Heating and also the CoolOffState. We then select Set Transition Source in the menu. This will redirect the transition to instead go from state CoolOffState to state Heating.","title":"State Diagram Editing"},{"location":"working-with-art/diagrams/#structure-diagram-editing","text":"In a structure diagram it's not possible to create anything unless something is selected in the diagram. This is because a structure diagram always has a single capsule as its top-level element. If the capsule is selected you can create parts and ports in it. If a part is selected you can create a port in the capsule that types the part. In the example below a port will be created in capsule BB. Both parts and ports have several properties that can be edited using the Properties view.","title":"Structure Diagram Editing"},{"location":"working-with-art/diagrams/#deleting-elements","text":"Note Deleting elements is supported in state and structure diagrams but not in class diagrams. You can delete an Art element shown in a diagram by selecting the symbol or line that represents the element and then press the Delete key. Alternatively use the command Delete in the Ctrl + Space pop-up menu. Multiple symbols or lines can be selected in order to delete many Art elements in one go. Note that elements are deleted by removing them from the Art file, which in turn will update the diagram. All content within the deleted element will be lost, including any comments. However, you can of course undo the deletion by pressing Ctrl + z ( Undo ) in the Art text editor.","title":"Deleting Elements"},{"location":"working-with-art/outline-view/","text":"The Outline view shows information about the Art elements that are defined in an Art file. You can see the most important information for each element, such as its name and other important properties. You can also see the containment hierarchy, i.e. which elements that contain other elements. Below is an example of what it can look like: You can use the Outline view for getting an overview of what elements an Art file contains, and for searching and navigating to elements. Navigating To navigate to an element in the Art file, double-click on the element in the Outline view. The cursor will be placed just before the element's name in the Art file (or where the name would be in case it has no name). You can also single-click on elements to just make the clicked element visible in the Art editor, without changing the cursor position. In this case the element is marked with a thin rectangle: If you hold down the Ctrl key when clicking, a new Art editor showing the same Art file will open to the side, in a new editor area to the right. The element will then be made visible and marked in that new editor. This can be useful if you don't want to change the original Art editor, for example when comparing two elements located in the same Art file. It's also possible to navigate in the other direction, i.e. from the Art editor to the Outline view. To do this, set the Outline view to follow the cursor: Now the Outline view will automatically highlight the element that corresponds to the cursor position in the Art editor. Searching You can use the Outline view when searching for one or many Art elements, as an alternative to searching textually in the Art editor. Start by selecting the element shown first in the Outline view, and then type quickly the first few characters of the element name. After every keystroke the selection will move downwards to an element with a name that matches the typed characters. If you make a brief pause, you can then start to type again to proceed searching further down in the Outline view. Another way to search is to press Ctrl + f when the Outline view has focus. A small popup will then appear where you can type a few characters. Nodes in the Outline view with a label that matches the typed characters will be highlighted. The matching allows additional characters between the typed characters which is why the typed string \"init\" also matches the transition Waiting -> Terminated : When the search has matched a few elements that look interesting you can press the Filter button next to the text field to filter the Outline view so it only shows the matching elements. This can avoid lots of scrolling if the matching elements are far apart.","title":"Outline View"},{"location":"working-with-art/outline-view/#navigating","text":"To navigate to an element in the Art file, double-click on the element in the Outline view. The cursor will be placed just before the element's name in the Art file (or where the name would be in case it has no name). You can also single-click on elements to just make the clicked element visible in the Art editor, without changing the cursor position. In this case the element is marked with a thin rectangle: If you hold down the Ctrl key when clicking, a new Art editor showing the same Art file will open to the side, in a new editor area to the right. The element will then be made visible and marked in that new editor. This can be useful if you don't want to change the original Art editor, for example when comparing two elements located in the same Art file. It's also possible to navigate in the other direction, i.e. from the Art editor to the Outline view. To do this, set the Outline view to follow the cursor: Now the Outline view will automatically highlight the element that corresponds to the cursor position in the Art editor.","title":"Navigating"},{"location":"working-with-art/outline-view/#searching","text":"You can use the Outline view when searching for one or many Art elements, as an alternative to searching textually in the Art editor. Start by selecting the element shown first in the Outline view, and then type quickly the first few characters of the element name. After every keystroke the selection will move downwards to an element with a name that matches the typed characters. If you make a brief pause, you can then start to type again to proceed searching further down in the Outline view. Another way to search is to press Ctrl + f when the Outline view has focus. A small popup will then appear where you can type a few characters. Nodes in the Outline view with a label that matches the typed characters will be highlighted. The matching allows additional characters between the typed characters which is why the typed string \"init\" also matches the transition Waiting -> Terminated : When the search has matched a few elements that look interesting you can press the Filter button next to the text field to filter the Outline view so it only shows the matching elements. This can avoid lots of scrolling if the matching elements are far apart.","title":"Searching"},{"location":"working-with-art/references/","text":"The References view shows how Art elements reference each other. Depending on what kind of reference you are interested in, there are different commands to use. Referencing Elements To find all elements that reference a certain Art element, right-click on the name of the Art element (it must have a name, otherwise it cannot be referenced) and perform the context menu command Find All References . The References view will in this case list all referencing elements, and group them by the Art file where they are located. For example, it could look like this if the command was invoked on a state. Double-click the items in the References view to navigate to the referencing element in the Art file. You can remove a referencing element from the view by clicking the Dismiss (x) button. This can for example be useful if you are going through a large list of references and want to remove those you have already examined to make the list more manageable. You can restore all referenced element to be shown again by pressing the Refresh button in the toolbar. An alternative way of finding and going through all referencing elements is to instead use the context menu command Go to References . This commands works the same as Find All References but will show the referencing elements inline in a popup in the Art editor instead of using the References view. Type Hierarchy To find how Art elements relate to each other in terms of inheritance, right click on the name of an Art element that can be inherited (i.e. a class, capsule or protocol) and perform the context menu command Show Type Hierarchy . The References view will show the subtypes or supertypes of the selected Art element. For example: Use the leftmost toolbar button to toggle between showing subtypes or supertypes. Double-click on items in the tree to navigate to a subtype or supertype. Note that an alternative to using the References view for looking at type hierarchies is to visualize them graphically using class diagrams (see Diagrams ).","title":"References View"},{"location":"working-with-art/references/#referencing-elements","text":"To find all elements that reference a certain Art element, right-click on the name of the Art element (it must have a name, otherwise it cannot be referenced) and perform the context menu command Find All References . The References view will in this case list all referencing elements, and group them by the Art file where they are located. For example, it could look like this if the command was invoked on a state. Double-click the items in the References view to navigate to the referencing element in the Art file. You can remove a referencing element from the view by clicking the Dismiss (x) button. This can for example be useful if you are going through a large list of references and want to remove those you have already examined to make the list more manageable. You can restore all referenced element to be shown again by pressing the Refresh button in the toolbar. An alternative way of finding and going through all referencing elements is to instead use the context menu command Go to References . This commands works the same as Find All References but will show the referencing elements inline in a popup in the Art editor instead of using the References view.","title":"Referencing Elements"},{"location":"working-with-art/references/#type-hierarchy","text":"To find how Art elements relate to each other in terms of inheritance, right click on the name of an Art element that can be inherited (i.e. a class, capsule or protocol) and perform the context menu command Show Type Hierarchy . The References view will show the subtypes or supertypes of the selected Art element. For example: Use the leftmost toolbar button to toggle between showing subtypes or supertypes. Double-click on items in the tree to navigate to a subtype or supertype. Note that an alternative to using the References view for looking at type hierarchies is to visualize them graphically using class diagrams (see Diagrams ).","title":"Type Hierarchy"}]}